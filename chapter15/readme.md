## Lab 15-1
### Basic Static Analysis
- **strings**: "Good Job!", "Son, I am disappoint.".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: _very_ few imports. `printf`, `exit`, and a few others from _MSVCRT.DLL_.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
This program is _very_ simple. Procmon shows almost nothing, and the only output I could get was "Son, I am disappoint." whether or not I supplied input.

### Advanced Dynamic/Static Analysis
In IDA it's easy to see how simple this application is, but that could be deceptive. `_main` cannot be shown in graph mode, and there are many calls to what are probably actuall instructions. We see the `jmp <loc>+1` and can fix them by pressing `D` on the location, moving down a byte, and then pressing `C` to turn it back to code. There are cases where soon after a new code segment IDA interprets more raw data, but these can be fixed again with `C`. OllyDBG actually does an impressive job of figuring out which instructions to disassemble, but isn't needed for this simple lab. Although IDA doesn't show the arguments to `_main` correctly, this can be fixed by selecting the function from the prologue to the return and then pressing `P`. Now it's simple enough to see that they are accessing _argc_ with `[epb+8]` and comparing it to 2, and then getting the first string _argv[1]_. After this, it's simple single byte comparisons, done out of order. First it checks that the first byte is 'p', then that the third is 'q', and finally that the second is 'd'. Sure enough, running the executable with "pdq" as the argument prints out "Good Job!". Since there are no extra checks, you can tack on anything else after that first argument, but because _argc_ is tested to be exactly 2, you cannot add distinct new args.

### Questions
1. This executable uses the technique of using a condition jump with a constant condition.
2. The 'E8' opcode, which corresponds to `call` is the single byte that the executable tricks IDA into disassembling.
3. This technique is used five times in `_main`.
4. Passing the executable a single argument that starts with "pdq" will print out "Good Job!".

## Lab 15-2
### Basic Static Analysis
- **strings**: "not enough name", "internet unable", "Bamboo::".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Low-level c imports from _MSVCRT.DLL_, `InternetOpenUrlA` and similar from _WININET.DLL_, `gethostname` and `WSAStartup` (by ordinal) from _WS2_32.DLL_, and `ShellExecuteA` from _SHELL32.DLL_.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
This program seems rather simple. Run from the command line we only see "not enough name", even if provided a varying number of arguments. Fakedns doesn't even see any dns requests come through. This was found to be some sort of bug, perhaps caused by my RE VM having a short hostname. With this check patched out, we do indeed see a request made to "http://www.practicalmalwareanalysis.com/bamboo.html".

### Advanced Dynamic/Static Analysis
Again IDA has a hard time recognizing `main` as a function. This can be remedied by finding those red Xrefs and using `D` and `C` to get around them. This time around, however, there are cases where there code jumps into the code that itself is executing. Since a single byte is used in more than one legal opcode, IDA doesn't know how to follow the flow. While it's easy enough to follow through, it prevents us from being able to use the graph view. This can be remedied by patching the executable so that unneeded extra bytes are replaced with _NOPs_. I did this in IDA Free by running the IDC command `PatchByte(<ea>, 0x90)` There are also cases where instead of using conditional jumps with constant conditions, there are just two jumps with opposite condition, for example _JZ_ followed by _JNZ_. With all of these fixed we can finally see `main` in a nice graph view.

Now looking in main, we see `_alloca_probe` used to allocate a huge buffer on the stack. `WSAStartup` is then called, and then the host name of the pc is fetched used `gethostname`. For some reason there is a check that expects an error message here, but it looks like a bug. We can circumvent this in the debugger or IDA by patching out the JNZ and replacing it with JZ or JMP. After this there is a somewhat complicated-looking loop that appears to run over a buffer. Looking at the byte constants mentioned, we see 'a', 'A', 'z', 'A', '0' and '9', plus we see a spot where a byte is retrieved, incremented, and then saved back. It appears that the hostname string has each character moved up by one, but all letters and numbers loop around, remaining in their original case. Since IDA named this buffer szAgent, it's clear that this string will be used as the User-Agent. This is done at 0x40114E where `InternetOpenA` is called.

Another function, `sub_401394` is called, and its return value is used as the URL passed to `InternetOpenURLA`, and its response is read using `InternetReadFile`. Finally, the handle is closed using `InternetCloseHandle`. Looking into this function we see that it is simply building a string on the stack, one byte at a time, and then calling `strdup` to get an copy on the heap. This is likely done to avoid having the URL found with `strings`. The URL that pops out is "http://www.practicalmalwareanalysis.com/bamboo.html".

The buffer is then searched through for the string "Bamboo::", and from there looks for another "::". The last "::" is patched with a null byte, and the after the first is used as a second URL. This URL is opened and whatever is in its response is saved to a file "Account Summary.xls.exe". This URL was built by another function `sub_40130F`, which uses a method identical to `sub_401394` to build and copy a string. Once this response is saved to disk, `ShellExecuteA` is used to execute it. Because of a bug in the program, the wrong "::" is patched, so the URL pulled from the page will have a trailing set of colons and run until the end of the page.

### Questions
1. "http://www.practicalmalwareanalysis.com/bamboo.html", which wasn't found with `strings` because it is written into a buffer one byte at a time.
2. The User-Agent is generated by getting the host name of the victim machine and rotating all the letters by one.
3. The malware looks for "Bamboo::" on the page that is immediately followed by a URL.
4. It downloads the file located at the provided URL, saves is as "Account Summary.xls.exe", and then executes it.
