## Lab 15-1
### Basic Static Analysis
- **strings**: "Good Job!", "Son, I am disappoint.".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: _very_ few imports. `printf`, `exit`, and a few others from _MSVCRT.DLL_.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
This program is _very_ simple. Procmon shows almost nothing, and the only output I could get was "Son, I am disappoint." whether or not I supplied input.

### Advanced Dynamic/Static Analysis
In IDA it's easy to see how simple this application is, but that could be deceptive. `_main` cannot be shown in graph mode, and there are many calls to what are probably actuall instructions. We see the `jmp <loc>+1` and can fix them by pressing `D` on the location, moving down a byte, and then pressing `C` to turn it back to code. There are cases where soon after a new code segment IDA interprets more raw data, but these can be fixed again with `C`. OllyDBG actually does an impressive job of figuring out which instructions to disassemble, but isn't needed for this simple lab. Although IDA doesn't show the arguments to `_main` correctly, this can be fixed by selecting the function from the prologue to the return and then pressing `P`. Now it's simple enough to see that they are accessing _argc_ with `[epb+8]` and comparing it to 2, and then getting the first string _argv[1]_. After this, it's simple single byte comparisons, done out of order. First it checks that the first byte is 'p', then that the third is 'q', and finally that the second is 'd'. Sure enough, running the executable with "pdq" as the argument prints out "Good Job!". Since there are no extra checks, you can tack on anything else after that first argument, but because _argc_ is tested to be exactly 2, you cannot add distinct new args.

### Questions
1. This executable uses the technique of using a condition jump with a constant condition.
2. The 'E8' opcode, which corresponds to `call` is the single byte that the executable tricks IDA into disassembling.
3. This technique is used five times in `_main`.
4. Passing the executable a single argument that starts with "pdq" will print out "Good Job!".

## Lab 15-2
### Basic Static Analysis
- **strings**: "not enough name", "internet unable", "Bamboo::".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Low-level c imports from _MSVCRT.DLL_, `InternetOpenUrlA` and similar from _WININET.DLL_, `gethostname` and `WSAStartup` (by ordinal) from _WS2_32.DLL_, and `ShellExecuteA` from _SHELL32.DLL_.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
This program seems rather simple. Run from the command line we only see "not enough name", even if provided a varying number of arguments. Fakedns doesn't even see any dns requests come through. This was found to be some sort of bug, perhaps caused by my RE VM having a short hostname. With this check patched out, we do indeed see a request made to "http://www.practicalmalwareanalysis.com/bamboo.html".

### Advanced Dynamic/Static Analysis
Again IDA has a hard time recognizing `main` as a function. This can be remedied by finding those red Xrefs and using `D` and `C` to get around them. This time around, however, there are cases where there code jumps into the code that itself is executing. Since a single byte is used in more than one legal opcode, IDA doesn't know how to follow the flow. While it's easy enough to follow through, it prevents us from being able to use the graph view. This can be remedied by patching the executable so that unneeded extra bytes are replaced with _NOPs_. I did this in IDA Free by running the IDC command `PatchByte(<ea>, 0x90)` There are also cases where instead of using conditional jumps with constant conditions, there are just two jumps with opposite condition, for example _JZ_ followed by _JNZ_. With all of these fixed we can finally see `main` in a nice graph view.

Now looking in main, we see `_alloca_probe` used to allocate a huge buffer on the stack. `WSAStartup` is then called, and then the host name of the pc is fetched used `gethostname`. For some reason there is a check that expects an error message here, but it looks like a bug. We can circumvent this in the debugger or IDA by patching out the JNZ and replacing it with JZ or JMP. After this there is a somewhat complicated-looking loop that appears to run over a buffer. Looking at the byte constants mentioned, we see 'a', 'A', 'z', 'A', '0' and '9', plus we see a spot where a byte is retrieved, incremented, and then saved back. It appears that the hostname string has each character moved up by one, but all letters and numbers loop around, remaining in their original case. Since IDA named this buffer szAgent, it's clear that this string will be used as the User-Agent. This is done at 0x40114E where `InternetOpenA` is called.

Another function, `sub_401394` is called, and its return value is used as the URL passed to `InternetOpenURLA`, and its response is read using `InternetReadFile`. Finally, the handle is closed using `InternetCloseHandle`. Looking into this function we see that it is simply building a string on the stack, one byte at a time, and then calling `strdup` to get an copy on the heap. This is likely done to avoid having the URL found with `strings`. The URL that pops out is "http://www.practicalmalwareanalysis.com/bamboo.html".

The buffer is then searched through for the string "Bamboo::", and from there looks for another "::". The last "::" is patched with a null byte, and the after the first is used as a second URL. This URL is opened and whatever is in its response is saved to a file "Account Summary.xls.exe". This URL was built by another function `sub_40130F`, which uses a method identical to `sub_401394` to build and copy a string. Once this response is saved to disk, `ShellExecuteA` is used to execute it. Because of a bug in the program, the wrong "::" is patched, so the URL pulled from the page will have a trailing set of colons and run until the end of the page.

### Questions
1. "http://www.practicalmalwareanalysis.com/bamboo.html", which wasn't found with `strings` because it is written into a buffer one byte at a time.
2. The User-Agent is generated by getting the host name of the victim machine and rotating all the letters by one.
3. The malware looks for "Bamboo::" on the page that is immediately followed by a URL.
4. It downloads the file located at the provided URL, saves is as "Account Summary.xls.exe", and then executes it.

## Lab 15-3
### Basic Static Analysis
- **strings**: A big menu that show features of a "Process Viewer v1.3", plues a bunch of format strings used to generate output
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Low level imports from _MSVCRT.DLL_, `URLDownloadToFileA` from _URLMON.DLL_, `CreateToolhelp32Snapshot`, `{Module/Process/Thread}32{First/Next}` (to iterated through modules, processes, and threads), `OpenProcess`, `WinExec`, and other process-related imports from _KERNEL32.DLL_.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Running the program with `nc` listning on port 80 with fakedns and procmon running, we see the application print out information about each process running (including all their threads and all the loaded modules). A request is also seen to "http://www.practicalmalwareanalysis.com/tt.html", which we do not see in the `strings` output. We don't see anything really interesting in the output from procmon, other than the socket created to make the http request.

### Advanced Dynamic/Static Analysis
The `main` function actually looks very simple: `CreateToolhelp32Snapshot` is used with `Process32First` and `Process32Next` to iterate over running processes. For each process that is iterated over, some information is printed and `sub_4011E1` is called to do similar, but this time on the modules loaded in that process. `sub_40130C` is then called to do the same, but to iterate over that process's threads. There are even very nice error messages that are printed should any of these calls fail.

Since we saw this program making network calls, we obviously want to see how (and why). Finding the XRef to `URLDownloadToFileA`, we see it at 0x401510, but it's in a blob of code that is surrounded by what IDA sees as raw data. IDA cannot find a path to this code. Scrolling up to the previous return statement we do see a function prologue immediately underneath, at 0x40148C. We can follow down from here, using our `D`, `C` routine to fix the tricky jumps. There are a few cases where we see jumps that jump one byte into their own opcode. These can be fixed by decoding from the jump target, and then using `PatchByte` on the byte just before it (replacing with NOP). After cleaning up the weird jumps you can create a function using `P`, but there are no references to it. For this I ran the binary in OllyDBG. Before starting it I searched for all intermodular calls and set a breakpoint on the call to `InternetOpenURLA`. I then ran the malware. Once I hit the breakpoint, I clicked the 'K' button to view the stack, but unfortunately it didn't show anything. Setting a breakpoint at the earliest point straight before this call, at 0x4014C0, I see that when hit the code is working it's way through the SEH linked list: First it changes the stack to point to the SEH, and then it gets the address pointed to by FS:[0]. This is the **Thread Environment Block**, and at offset zero is the **Thread Information Block**. The first element of this is a pointer to the SEH chain. This piece of code basically just fixes the SEH chain by popping the previous handler and writing it back into the TIB[0]. This means that we are in an exception handler, which explains why no call graph leads to this point. In IDA we can, however, see a reference to `loc_4014C0`. It is used at 0x401497, where is it pushed to the stack. After this, FS:[0] is pushed to the stack. These two values on the stack now fit the format of an SEH node, and sure enough, the next instruction writes ESP back into FS:[0]. This is followed by a guaranteed divide by zero, triggering the exception and jumping to our code at 0x4014C0.

```asm
.text:00401497 push    offset loc_4014C0 ; push address of handler
.text:0040149C push    large dword ptr fs:0 ; push SEH node onto stack (acts as prev node)
.text:004014A3 mov     large fs:0, esp ; write new seh start address to TIB[0]
.text:004014AA xor     ecx, ecx        ; set ecx = 0
.text:004014AC div     ecx             ; div by 0 here, causing exception, jumping to loc_4014C0
```

Building a SEH node on the stack and writing into the chain.

```asm
.text:004014C0 mov     esp, [esp+8]    ; remove OS added stack stuff
.text:004014C4 mov     eax, large fs:0 ; get SEH chain
.text:004014CA mov     eax, [eax]      ; get first node
.text:004014CC mov     eax, [eax]      ; get prev node
.text:004014CE mov     large fs:0, eax ; write it back to TIB[0]
.text:004014D4 add     esp, 8          ; Remove SEH node from stack
```

In the handler, repairing the chain and the stack.

Now finally looking at what this function does, we see two calls to `sub_401534`. This function is provided a pointer and simply XORs each byte by 0xFF. The first invocation yields the URL we saw requested. The second call does nothing, because the buffer it points to _starts_ with a null byte. This is probably a bug, because if we pass that function one byte later, it decodes to "spoolsrv.exe". These two strings are passed to `URLDownloadToFileA`, and then the saved file is executed with `WinExec`.

While we know how the exception handle is setup and triggered, we still don't know how the function that does the setup is called. We can find where it's called by doing a binary search. I saved my patches to the binary so that I can safely set breakpoints at 0x40148C, and then set breakpoints at different points in `_main`. If the breakpoint isn't hit by the time my `_main` breakpoint is, we know it's triggered later. First setting it at the start, we hit immediately. This confirms that they aren't doing anything tricky in `start`. Next, setting it at the end, at 0x4011E0, we see still that this function has not hit. What the hell? Stepping we see that `_main` somehow _returns_ to `sub_40148C`. There must be some point where the return address is patched on the stack. We can find out where the return address is changed by setting a memory breakpoint. Obviously it will be written to when we first call `_main`, so I replaced my breakpoint at 0x401000 and then set a memory breakpoint at the address stored in ESP.

Just a few instructions from the top of main we find our culprit. The return value is replaced, as clear as day, with the value of 0x40148C. The malware avoided having the XRef show up by setting the value 0x400000 and then ORing in 0x148C.

```asm
.text:0040100C mov     eax, 400000h
.text:00401011 or      eax, 148Ch
.text:00401016 mov     [ebp+4], eax
```

### Questions
1. This code is called by setting up a exception handler that points to 0x4014C0 and then divides by zero, triggering an exception and jumping there. The exception handler is set up by patching the return address from main on the stack.
2. The malware attempts to download the file from a URL and then execute it.
3. "http://www.practicalmalwareanalysis.com/tt.html".
4. "spoolsrv.exe".
