# Lab 19

## Lab 19-1
### Basic Static Analysis
- **strings**: A long sequence of "A"s as well as another sequence of seemingly random ascii characters.

### Advanced Static/Dynamic Analysis
Loading the binary into IDA, we see a bunch of 'A' bytes (0x41) which correspond to `inc ecx`, a sort of NOP that remains in the ascii range. After this, there's a call/ret combo to get a pointer to the 'random' ascii string after our main shellcode, and it is pushed back onto the stack. The shellcode appears to decode each byte of this string, by decoding each byte as so: `c[i] = (c[2*i] - 0x41) << 4 + (c[2*i+1] - 0x41)`, meaning each byte of plaintext comes from the bottom nybble of two bytes of ascii. Once this is done, the newly decoded instructions are returned to. To see what this decodes so, I loaded the `shellcode_launcher.exe` into Olly and set the args to load the binary. I then set a hardware breakpoint at 0x350300, which is 0x200 bytes past where it was loaded, but right after where all the 0x41 bytes end. I then walked through until just before the return.

At this point most of the ascii has been decoded into valid instructions, and there are also two strings at the end: "URLMON" and "http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe". The same call/ret combo is used to get a pointer to the "URLMON" string.

`sub_35039E` is used to find the address of _kernel32.dll_ by parsing the `PEB_LDR_Data` linked list which it finds through the `PEB`, from FS:[0x30].

After this there is a call to a function, `sub_350352`, used to find some functions. It is passed a handle to the module (kernel32 for most) and a hash of the function name, and loops over the functions in the import table, hashing their name `sub_350331`, until it finds a match. It is called repeatedly, finding a handful of different functions, including `LoadLibraryA`. `LoadLibraryA` is used to load URLMON, and then the address of `URLDownloadToFileA` is found using `sub_350352` again. The system path is resolved using `GetSystemDirectoryA` and the _annoy_user.exe_ file is downloaded to _%SYSTEM%/1.exe_, and finally executed.

### Questions
1. The shellcode is encoded by getting each nybble of the original byte and storing it across two bytes, adding 0x41 to each to move it into ASCII range.
2. `LoadLibraryA`, `GetSystemDirectoryA`, `TerminateProcess`, `GetCurrentProcess`, `WinExec`, and `URLDownloadToFileA`.
3. www.practicalmalwareanalysis.com
4. The downloaded file remains at _%SYSTEM%/1.exe_.
5. The shellcode downloads and executes a binary found at http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe.

## Lab 19-2
### Basic Static Analysis
- **strings**: Nothing interesting besides some error messages and "\\http\\shell\\open\\command".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Many imports from KERNEL32.DLL, including `WriteProcessMemory`, and `VirtualAllocEx`. `AdjustTokenPrivileges`, `LookupPrivilegeValueA`, `OpenProcessToken`, plus registry imports from ADVAPI.DLL.
- **PEview**: Normal section names and headers.

### Advanced Static/Dynamic Analysis
Knowing that this process will write shellcode into another process, I opened the binary in IDA and immediately found where `WriteProcessMemory` was called. It's called from `sub_401230`, where both the buffer and the size were provided as args. Finding the xref to the call from `_main`, we see it writes 423 bytes from `unk_407030`. Jumping to this address and hitting `C` to turn it to code, we see a simple shellcode that uses call/ret to get a pointer to part of the shellcode, which is decrypted by xoring each byte with 0xE7. While this could be done easily dynamically by letting the shellcode itself do it, I didn't feel like tracing two processes at once, so I wrote an IDC script to get it done.

```c
static decrypt(){
    auto i, start;
    start = 0x407048;
    for(i = 0; i < 0x18E; i++) {
        PatchByte(start+i, Byte(start+i) ^ 0xE7);
    }
}
```

I could have of course written one that took the start, length, and key as an argument, but this was quick and dirty. Once I ran this I again hit `C` with my cursor on 0x407048 to get more assembly to analyze. Following the first jump/call to `sub_4070E3`, there's another call to `sub_4070C2`, which again looks like code to find the address of KERNEL32.DLL in memory. `sub_407076` looks like another function that is provided a library and a hash and returns the address of the function whose hash matches. `loc_407055` appears to be the hashing function.

Going back to the loader (though still in the same IDA binary), tracing back from `OpenProcess`, we find that the handle was returned from a call to `CreateProcessA`. The name of the application that is created comes from `sub_401000`, which reads from the registry key "\\http\\shell\\open\\command".

Hopping into a debugger and tracing through this function forward, we see that the path to my default browser is what's returned here. Following forward we can clearly see the process follows what we expect. Opening a second Olly instance and attaching to chrome, I can pause the application and then break on the call to `WriteProcessMemory` in the first process. Stepping past we see the shellcode copied into chrome. Now setting the "Break on new thread" option in the Chrome olly, we can step through in the malware olly until `CreateRemoteThread` and confirm it is created. Setting a breakpoint at the address where the shellcode was copied in allows us to walk through the decoding process. The malware should be finished now, which we can see as `_main` returns.

Walking through the loading process we confirm that a handle to kernel32 is acquired, and we can see that the first function they find is `LoadLibraryA`. Next is `CreateProcessA`, `TerminateProcess`, and `GetCurrentProcess`. `LoadLibraryA` is called to load ws2_32, and then `WSAStartup`, `WSASocketA`, and `connect`'s addresses are found in that library, and they are called in turn. Looking at the call to `connect` we see a struct being built on the stack and then its address pushed as an argument. In the struct there is the value 0x2C8A8C0, which corresponds to the IP address 192.168.200.2, and 0x12340002 corresponds to the family _AF_INET_ and port 13330.

`CreateProcessA` is called, creating a `cmd` process, with the streams hooked up to the socket, effectively giving a remote callback shell to the attacked, and then the browser process is killed.

### Questions
1. The operating system's default browser.
2. The shellcode is located in the malware's .data section at 0x407030.
3. The shellcode is simply encrypted with a one-byte xor key or 0xE7.
4. The shellcode imports `LoadLibraryA`, `CreateProcessA`, `TerminateProcess`, `GetCurrentProcess`, `WSAStartup`, `WSASocketA`, and `connect`.
5. The shellcode connects to 192.168.200.2 on port 13330.
6. The shellcode connects back to the host and runs a `cmd` process, connecting the process's streams to the socket.

