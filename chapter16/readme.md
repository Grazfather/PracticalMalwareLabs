## Lab 16-1

This lab is the same as Lab 9-1, which is the same as the one in Lab 3-1.

### Basic Static Analysis
- **strings**: "http://www.practicalmalwareanalysis.com", "Manager Service", ".exe", "%SYSTEMROOT%/system32", plus what looks like command strings and command line options.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `ShellExecuteA`, from _SHELL32.DLL_, service and registry-related imports from _ADVAPI32.DLL_, many from _KERNEL32.DLL_, including `CreatePipe`, many that relate to querying the process's environment. There are also raw socket imports from _WS2_32.DLL_, imported by ordinal.
- **PEview**: Normal section names and headers.

### Advanced Dynamic Analysis
Because other than anti-dissassembly this malware is the same as a previous, we know that the malware runs only if provided correct arguments as well as a password.

Since we know that the malware has anti-debug tactics in play, we want to see how it behaves when run in a debugger. Following through we see it call `ShellExecuteA`, executing `cmd` to delete itself. Scrolling up to the start of this function (at 0x401000) we can set a break point and re-run. Once we hit this bp we can look at the stack for the RA and jump there. As expected there is a `JZ` instruction just before the called. We can patch this jump and rerun to avoid this call. Despite avoiding this check, we still hit the `sub_401000` bp (hereafter `delete_self`). We can follow this procedure as many times as needed, patching out all of the checks, but after a few it's clear that there are _many_. Let's see how they determine we are using a debugger to see if there's a better solution.

Right in `_main`, we see three immediate conditional calls to `delete_self`. The first checks fs:[30h] (PEB)'s second byte. This corresponds to the _BeingDebugged_ flag. Next is a check for PEB[18][10], which corresponds to _ForceFlags_, and then a third checks PEB[68], which is compared to 0x70, with corresponds to _NTGlobalFlag_. Using IDA to find other XRefs to `delete_self`, we can see that each call is preceded by one of these three checks.

These three methods can be circumvented by using a plugin that changes them when the debugger starts the process, by patching them manually in memory, by patching out the calls to `delete_self` (though there or many), or simply NOP all but the prologue and epilogue of the function. I went for the latter, which allowed me to save it to the binary, not worrying about which debugger I may decide to use in the future.

With the patched function in place, I can easily analyze the malware and confirm that it is otherwise identical to Lab 9-1

### Questions
1. This malware uses three anti-debugging technics:
  1. Check _BeingDebugged_ flag.
  2. Check _ForceFlags_ flag.
  3. Check _NTGlobalFlag_ flag.
2. The malware attempts to delete its binary from the disk and then terminates.
3. You can basically avoid having the `delete_self` function get called. This can be done many ways, the easiest two probably NOPing the function, or using a plugin that patches the PEB for you to trick the checks.
4. You can simply open the memory that is being checked in the memory dump view and then overwrite the values with 0. You can click on the memory dump view and press `<Ctrl-G>` to enter an expression similar to what the checking code does (e.g. fs:[30h] + 2).
5. 'StrongOD' and 'PhantomOm' both seem popular plugins for OllyDBG used to avoid anti-debug.
