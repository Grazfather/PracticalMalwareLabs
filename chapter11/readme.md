# Chapter 11 labs
## Lab 11-1
### Basic Static Analysis
- **strings**: "Software\Microsoft\Windows NT\CurrentVersion\Winlogon", "GinaDLL", "\MSGina", "msgina32.dll", "gina.dll", "??2@YAPAXI@Z", "UN %s DM %s PW %s OLD %s", "msutil32.sys", plus a bunch of imports/exports including 'Wlx*'-named functions.
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports a normal set from KERNEL32.DLL, including 'LoadLibraryA' (probably to load gina.dll) and 'FindResourceA', as well as 'RegCreateKeyExA' and 'RegSetValueExA' from ADVAPI32.DLL.
- **PEview**: Includes a .rsrc section.
- **Resource Hacker**: Includes one binary resource which appears to be another PE file.

Running the same analysis on the included resource:
- **strings**: All of the interesting strings from above were found in the included binary, implying that the binary that held the resource did not contain these strings directly.
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0 DLL. I renamed the file to 'Lab11-01.resource.dll' with this information.
- **Dependency Walker**: Imports a small set including 'lstrcatW', 'lstrcpyW', and 'lstrlenW' from KERNEL32.DLL, some low-level functions from MSVCRT.DLL, 'RegCloseKey', 'RegCreateKeyW', and 'RegSetValueExW' from ADVAPI32.DLL, and 'wsprintfA' from USER32.DLL. Appears to export 'DllRegister', 'DllUnregister', 'ShellShutdownDialog', plus a bunch of 'Wlx*'-named functions, implying that this dll implements gina.dll: This malware is very likely used to steal user credentials.
- **PEview**: Nothing out of the ordinary.

### Basic Dynamic Analysis
Since I didn't see any network-related imports, I just used procmon and Regshot to get a picture of what the malware was doing. In Regshot I see three values added and two values modified. Only one of these changes seem relevant: The key "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GinaDLL" was created with a value "C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis Labs\BinaryCollection\Chapter_11L\msgina32.dll". Looking at Procmon and we see sure enough that a file called 'msgina32.dll' was created and the registry key was added, but we don't see too much else done. Comparing the md5sum of resource we extracted and this new file we see that they are identical.

### Advanced Static Analysis
Loading the binary into IDA we see a very straightforward process. First it calls 'GetModuleHandleA' with a null argument to get a handle to its own module, and then calls sub_401080. sub_401080 uses the passed handle to grab that module's (its own) resource and then saves it as msgina32.dll. After sub_401080 returns the malware calls 'GetModuleFileNameA' to get the full filename. It then uses '_strchr' to get the location of the last backslash and from than point appends "\msgina32.dll" and then calls sub_401000. sub_401000 is a simple function that simply uses 'RegCreateKeyExA' to write the file path that was created earlier to the registry key "SOFTWARE\Microsoft\Window NT\CurrentVersion\Winlogon'.

Now looking at the DLL we can see quickly it does all of the heavy lifting. Looking at DllMain we see one big branch on _fdwReason_. One branch is for reason DLL_PROCESS_ATTACH and the other is for all other reasons. The attach branch gets the local system directory usinng 'GetSystemDirectoryW', appends "\MSGina" to it, and then calls 'LoadLibraryW' with the resulting string. Once this is done it saves the handle to the global variable IDA called 'hModule'. The other branch checks if the reason is DLL_PROCESS_DETACH and if it is it loads the module handle and then calls 'FreeLibrary'. If the reason is anything else then it just returns.

Since we know this DLL must implement all of the gina.dll exports we will see how it does this. Looking at a few functions we see quickly that the ordinal/function name is simply passed to sub_10001000 most of the time, and then there is a jump to the return value of this function. sub_10001000 seems simple enough: It calls 'GetProcAddess' with the passed function ordinal/name, tests if it is returned an address, and then prints the pointer address into a local buffer and then calls 'ExitProcess' on failure. On success it returns the address of the function. Looking at more functions for something more interesting than a call to sub_10001000, I eventually find WlxLoggedOutSAS.

WlxLoggedOutSAS calls sub_10001000 like every other exported function, but it holds on to the passed pointer and then follows up by allocating 100 bytes with 'new', which was labeled as "??2@YAPAXI@Z" and seen earlier with strings. After 'new' is called it appears to repush all of its arguments and then call the real 'WlxLoggedOutSAS' whose address it received earlier. If 'WlxLoggedOutSAS' doesn't return 1 then it calls sub_10001570, passing it a format string "UN %s DM %s PW %s OLD %s" as well as four pointers it pulled from an array that was in esi. Tracing back to where esi was last written we see that it contains the address of the _pNprNotifyInfo_ argument, and looking on MSDN we see that this argument is indeed a struct that holds the address to four strings: username, domain, password, and old password.

We can take a pretty fair guess and say that sub_10001570 is the function that does the logging, but we need to investigate more to see just where it logs _to_. Looking at this function we see a lot of stack space as well as calls '_vsnwprintf', '_wfopen', and 'fwprintf', as well as the string "msutil32.sys". To avoid wasting time to analyze this more closely I am going to run it to confirm that it logs my password as expected. Because the function that is used to do the logging is 'Wlx__LoggedOut__SAS' it probably won't do anything until I log out and to make sure the malware is loaded I will need to restart the computer first.

Sure enough, if I restart the computer I can find the surreptitiously-named text file "msutil32.sys" in C:\WINDOWS\system32 and it contains my credentials. I noticed immediately, though, that my login screen as well as the shutdown prompt had changed after running the malware. Instead of just the one button to log in and restart, it now had the drop down box and asked me for my credentials. Probably something that is enforced when GINA is used, but I would be curious to see if there could be a way to avoid it so that a victim has would be less likely to notice anything is out of the ordinary.

### Questions
1. The malware reads from its own resource section a dll which it writes to disk as msgina32.dll.
2. The malware writes to the registry's 'GinaDLL' key the address of this new dll.
3. GINA is a system created by Microsoft to allow third parties to customize the login process. Winlogon.exe uses this dll to help authenticate. This malware takes advantage of this feature by implementing the functions required to implement a valid GINA dll so that winlogon.exe will happily pass it any credentials it receives.
4. The malware logs all logoff attempts with a timestamp and the username, group, password, and old password at C:\WINDOWS\system32\msutil32.sys
5. Simply running the malware and then doing a full restart (a simple logout/login didn't work) had my credentials stored in the file.

## Lab 11-2
### Basic Static Analysis
- **strings**: "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows", "RCPT TO: <", "THEBAT.EXE", "OUTLOOK.EXE", "MSIMN.EXE", "wsock32.dll", "spoolvxx32.dll", "AppInit_DLLs", and "\Lab11-02.ini". Lab11-02.ini contains "CHMMXaL@MV@SD@O@MXRHRCNNJBNL".
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0 DLL.
- **Dependency Walker**: Imports lost level memory and string functions from MSVCRT.DLL, functions to write to the registry from ADVAPI32.DLL, and some interesting functions from KERNEL32.DLL including 'VirtualProtect', 'CreateToolhelp32Snapshot' (used to enumerate active processes), and 'LoadLibraryA'. Exports a function called 'installer'.
- **PEview**: Normal headers and sections.

### Basic Dynamic Analysis
Although this DLL doesn't important any functions used for network connectivity, it does have the string "wsock32.dll" and the import 'LoadLibraryA', so it could easily import this functionality at run time. For that reason I will set up fakedns.py and keep netcat listening on port 80. I will also use regshot and procmon to try and see what it's doing at a high level. I can run this dll using `rundll32.exe Lab11-02.dll,installer`.

Looking through procmon, I see that this malware is trying to find Lab11-02.dll using 'QueryOpen'. It looks in windows, system and system32, as well as the local directory, where it was found. This is probably just how rundll32.exe searched for the specified DLL. It creates/opens a file called "Lab11-02.ini" in system32 and creates a registry key "AppInit_DLLs" at "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" with value "spoolvxx32.dll". It finishes up by creating the file "C:\WINDOWS\system32\spoolvxx32.dll". Regshot's only interesting change is the one we caught with procmon. It doesn't appear that the malware made any attempts call out: There were no DNS requests (but it's possible it could be using a hard-coded IP).

### Advanced Static Analysis
Loading the DLL into IDA we first look at the 'installer' function. It is very straightforward: It writes the "AppInit_DLLs" key to the registry and then copies the file stored in 'ExistingFileName' to "\spoolvxx32.dll". We will look at DllMain to see what else the DLL is up to.

As is typical for DLLs, DLLMain branches based on _fdwReason_. If the reason is not DLL_PROCESS_ATTACH then it just returns. Looking quickly at the main branch, it looks like it simply opens "Lab11-02.ini" from the system directory and reads it into a buffer. If the bytes read is zero then it closes the file. This means that the malware will not behave normally unless the ini file is present before execution. There are calls to three functions we haven't seen: sub_1000105B, sub_100010B3, and sub_100014B6.

sub_1000105B just seems to call 'GetSystemDirectoryA' and supply a global buffer for it to write to, and then just returns a pointer to this buffer, populated with a string describing where the system directory is. Later on this is appended with the name of the ini and when this file is opened the buffer is reused to hold the file's contents.

sub_100010B3 is passed the address of a global buffer that should contain the contents of the ini file. It reads the first byte of the file and if it's null, 0x0D, or 0x0A then it calls sub_10001097, passing it the first byte of the file and the value 50. sub_10001097 multiplies the '50' argument by 666 and then it shifted right by 4, keeping the sign bit intact, the remaining value is xored with the passed in byte. Since this would be tiresome to do manually, I will hop to a debugger to see what this function does.

Loading the DLL into OllyDBG prompts me to use 'LOADDLL.EXE'. Clicking OK and putting a breakpoint on 'ReadFile' I can step through to make sure it can read the ini I placed in the system directory. sub_100010B3 calls sub_10001097 at 0x100010E5, and a few instructions later it copies the result back to the buffer. Placing a breakpoint at 0x100010F5 and hitting 'go' a few times I can see the string decode to "billy@malwareanalysisbook.com".

sub_100014B6 looks to be the most interesting function so far. It makes calls to many other mystery functions and has string references to "THEBAT.EXE", "OUTLOOK.EXE", "MSIMN.EXE", "send", and "wsock32.dll". A quick search shows that these EXEs are all email clients. Looking at the first function that's called from here, sub_10001075, it seems simple enough: It calls 'GetModuleFileNameA' with the _hModule_ set to 0 to get the name of the application it's loaded in. It stores this in the global 'Filename' variable and sets the passed in pointer to point to 'Filename'. sub_10001104 uses 'strrchr' and passes in the '\' character with the full process name to get the location of the last slash and then it adds one to that. This serves to get a pointer to the first character of the filename (and ignore the path). sub_1000102D loops over the string and calls 'toupper' on each character to convert the filename to upper case.

Once sub_100014B6 has a pointer to the filename in uppercase, it compares it to the mail client filenames seen earlier. If it finds a match it calls sub_100013BD. sub_100013BD gets the id of its own process and passes it to sub_100012FE. sub_100012FE uses 'CreateToolhelp32Snapshot' and 'Thread32First' which are commonly used to iterate over processes and/or threads. In this case it iterates over all of the threads that belong to the current process and if it isn't the thread that's currently running, it calls 'SuspendThread'. This would effectively halt the mail client while allowing the DLL to continue to work. Since we figure the malware intention wouldn't be to just break mail clients, it must resume these threads at some point.

Since sub_100012A3 seems to do most of the work, I am going to peek ahead to look for where the threads are resumed. Searching for xrefs to 'ResumeThread' we see only sub_100013DA, which is called from sub_10001499, which is called right after sub_100012A3! Clearly most of the work is done in sub_100012A3 and sub_100013BD and sub_10001499 are for set up and teardown. Indeed, sub_100013DA looks very similar to sub_100012FE, and their calling functions (sub_10001499 and sub_100013BD, respectively), are identical. If fact, they do the exact opposite of eachother. sub_100012FE stops all threads in the current process that aren't the DLL's (using 'SuspendThread'), and sub_100013DA resumes them (using 'ResumeThread').

Now we get to look at sub_100012A3. We see first that it is passed four arguments: "wsock32.dll", "send", the address of sub_1000113D, and the address of dword_10003484. Looking for xrefs to sub_1000113D we find there are none other than here where it's pushed. Clearly this function is used in another way. It could be called from the passed argument, but I think it's probably a hook into the 'send' function in wsock32.dll. dword_10003484 stores an address that is _called_ from sub_1000113D, but it's in the .data section and initialized to 0. Clearly some pointer to code will be copied here.

sub_100012A3 starts by loading the module that was passed in (wsock32.dll) if it hasn't been loaded already, otherwise it just gets its handle. It then calls 'GetProcAddress' to get the address of the function name that was passed in ('send'). It gets this address and passes it to sub_10001203 along with the address of the function (sub_1000113D) and the global variable (dword_10003484).

sub_10001203 is where the hook is placed. It calls 'VirtualProtect' on the first five bytes of the target function to make it writeable. It then allocates 255 bytes and copies the first five bytes from the passed in function ('send') to the start of this allocated buffer. This effectively copies the first few instructions from 'send' into the new buffer, and five bytes was selected because it's the number of bytes that are going to be replaced with a `jmp` instruction. In the new buffer, after the copied instruction, a `jmp` opcode (0xE9) is copied over along with the jump target, which is the distance between the buffer start and the target. At this point buf contains the first few instruction to the function and then a jump to just after where those instruction would have been if left untouched. Now the start of the function is overwritten with another `jmp` instruction. This time the jump goes to the supplied hook argument. At this point the function's permissions are restored using 'VirtualProtect' and then the arg_8 pointer has the address of the allocated buffer, where we copied the start of 'send' saved. Interestingly, it looks like the first four bytes of the trampoline aren't used, and the fifth just holds the value '5'.

Now that we know how this malware works, we can investigate what it intends to do. To do this we need to look at what the hook function does. Because the function used the '__stdcall' calling convention (and fixes its own stack when it returns) IDA knows how many arguments it takes (despite it never being called). Since we know that it is hooking the 'send' function, we know the arguments must be the same so we can name them: _socket_, _buf_, _len_, and _flags_. The function starts by calling 'strstr', looking for "RCPT TO:" in the send buffer. If it is not found, then it simply calls the address found in dword_10003484 (which is why the malware wrote the address of the hook target + five bytes in there). If "RCPT TO:" is found, then it copies a new "RCPT TO: <" + the decoded email address + ">\r\n" and then returns to the hookee, replacing the buffer with the new string. It finishes up by calling the hookee again with the original buffer. This effectively causes all outgoing email to also be sent to the specified email address.

### Advanced Dynamic Analysis
Although we know pretty well how this malware works, I'd like to see it in action. To do so I need to set up outlook express as well as a SMTP server on my host machine. I can set up a simple SMTP server on my host machine with the python one-liner `python -m smtpd -n -c DebuggingServer localhost:25` and setup VirtualBox so the VM's only network adapter is a 'host-only' adapter. Using ipconfig on my host machine I can see the IP that I was assigned on that virtual NIC and then set Outlook's outgoing SMTP server to that address. Setting up Wireshark to listen on SMTP only and then getting OllyDBG to attach to the outlook process I can search for 'send' and set a breakpoint there. Once I am setup all I need to do is try to send an email. Immediately the breakpoint hits and I can trace through how the hook works. On the first two packets the hook does nothing, because "RCPT TO: <" is missing (It's the "HELO" and "MAIL FROM" messages), but on the third I can see exactly how a new message is created and then send is actually called twice: Once with this new message and the second time with the intended recipient.

### Questions
1. This DLL only exports a function called 'installer'.
2. The DLL is copied to the system directory and named "spoolvxx32.dll", that path is added to the registry's "AppInit_DLLs" key, and the include INI file is copied to the system directory as well.
3. Lab11-02.ini must reside in the system folder (system32) for the malware to work properly.
4. The malware writes "spoolvxx32.dll" to the "AppInit_DLLs" registry key at "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows". This causes User32.dll, when loaded in a process, to call 'LoadLibrary' to load the malicious malware.
5. This malware hooks into the 'send' function of any popular mail client the user opens.
6. The hooking code checks for "RCPT TO:" in the message, and if it's present it sends an extra message that gets the email also sent to the password encrypted in the included ini file.
7. Any process that has the name "THEBAT.EXE", "OUTLOOK.EXE", or "MSIMN.EXE". These are popular mail clients, so the malware is trying to get a copy of all outgoing mail sent to some presumably malicious third party ("billy@malwareanalysisbook.com").
8. The ini file contains the encrypted email address where the malware will send intercepted mailed.
9. Using Wireshark to capture network traffic, we can filter for SMTP and see that all outgoing email have an additional "RCPT TO:" added to it.

## Lab 11-3
### Basic Static Analysis
- **strings**:
  - **exe**: "C:\WINDOWS\System32\inet_epar32.dll", "net start cisvc", "C:\WINDOWS\System32\%s", "cisvc.exe", and "Lab11-03.dll"
  - **dll**: Long and short versions of the months of the year and the days of the week as well as time/date strings, "<SHIFT>", "C:\WINDOWS\System32\kernel64x.dll".
- **PEiD**:
  - **exe**: Unpacked, Microsoft Visual C++ 6.0.
  - **dll**: Unpacked, Microsoft Visual C++ 6.0 DLL.
- **Dependency Walker**:
  - **exe**: imports 'IsBadReadPtr', file-mapping imports, 'GetOEMCP', 'LoadLibraryA', and a typical set from KERNEL32.DLL
  - **dll**: exports a function 'zzz69806582', imports mutex/critical section imports from KERNEL32.DLL and 'GetForegroundWindow', 'GetWindowTextA', and 'GetAsyncKeyState' from USER32.DLL. This, with the combination of the strings found in the DLL, looks like this DLL is a keylogger.
- **PEview**:
  - **exe**: Normal section names and headers.
  - **dll**: Normal section names and headers.

### Basic Dynamic Analysis
Loading up regshot and procmon we can see that the malware starts a service called "CiSvc". It prints out to the console that the service is being started ("The Indexing Service service is starting."), but we don't see the registry writes in procmon. This is because the service already exists in windows, this malware is just leveraging it. Running `sc query CiSvc` shows that the service is indeed currently running. I seem to be able to stop it with `sc stop CiSvc`. We also see ciscv.exe and cmd.exe being opened and then mapped into the process.

### Advanced Static Analysis (Executable)

Loading up the exe in IDA it looks simple. It copies _Lab11-03.dll_ to _C:\WINDOWS\System32\inet_epar32.dll_ and then uses '__spawnvpe' to create a shell and run "net start cisvc" in it. I confirmed that the DLL copied is the same as the one provided by looking at their md5 sums and they were indeed the same. This allowed me to skim over the copying part confident that I don't need to look for changes to the provided DLL. Before calling '__spawnvpe' it calls sub_401070, passing in the path "C:\Windows\System32\cisvc.exe". It looks like this function attempts to open that file and map it into the process's address space. Looking at sub_401000, which is called from sub_401070, it looks like it is iterating over the 'cisvc.exe' trying to find the .text section.

sub_401070 opens the file passed in and maps it into the process's address space using 'CreateFileMappingA' and 'MapViewOfFile'. It appears to jump through the file using a few offsets as guidance. Following along with PEview we can see what these offsets mean.

1. First, it gets the value at offset 0x3C, which corresponds to the offset of the NT header.
1. Next, it gets offset 0x14 from there, which is the size of the optional header.
1. Adding this size to the address of the NT header plus another 0x18 bytes gets us to the start of the section headers.
1. NT header + 0x6 is the 'Number of Sections'
1. At this point it calls sub_401000, passing in the address of the start of the first section as well as the number of sections.
1. sub_401000 iterates over the sections (jumping 0x28 bytes for each) until it finds one named '.text' and returns its address.
1. With the pointer to the text section it checks that the size is greater than 314 bytes.
1. It subtracts the virtual size (offset 0x8) from the raw data size (offset 0x10) and makes sure there is 314 bytes to spare.
1. At offset 0x14 from the text section header it finds the offset in the file for the section itself.
1. It does some work on a buffer of shellcode (press `C` to convert the buffer to assembly), iterating through the 314 bytes and comparing to some hard coded values.
1. It adds to this the virtual size, finding right where the section ends in the file.
1. With the 'base of code' address it calculates the relative jump that would be needed to jump to the original entry point. It patches the bytes at the end of the 314 byte buffer with this offset.
1. Now that the shellcode is patched, it copies this patched buffer to the end of the text section of the binary.
1. Finally, it patches the 'Address of Entrypoint' at offset 0x28 from the start of the NT header with the address of the shellcode that was inserted at the end of the text section and the file is unmapped.

This comes together to patch the cisvc.exe binary to run shellcode before jumping to the normal entry point. By backing up cisvc.exe and then running the malware we can compare the two versions of the binary, and indeed the patched version has a different entry point and extra code/strings at the end of the text section.

After sub_401070 is called we see the string "net start cisvc" is passed as an argument to sub_4013BC. The function loads the _COMSPEC_ env var using '_getenv', and then calls '__spawnve', passing it (NULL, $COMSPEC, "net start cisvc", NULL). Based on the result of that it calls __spawnvpe(NULL, $SHELL, &$SHELL, NULL), where $SHELL is 'cmd.exe' or 'command.com'. This does nothing more than start the service to execute the patched binary.

### Advanced Dynamic Analysis (Cisvc.exe)

Loading this modified binary in OllyDBG and going to the new entry point (sub_1001A36) allows us to easily examine the shellcode. Stepping through it quickly it appears to get the address to 'LoadLibaryA' and 'GetProcessAddress', which it calls to load the malicious inet_epar32.dll and then call its method 'zzz69806582'. Finally it does a long jump back to the original entry point so the application can run as normal.

### Advanced Static Analysis (dll)

Loading the DLL into IDA we jump immediately to the exported function 'zzz69806582' because we know it is called explicitly by the shellcode. It appears to create a thread (in Cisvc's context), passing in the address to 'StartAddress' at 0x10001410 as the entry point. The thread starts off trying to acquire a mutex named 'MZ' and quit if it cannot. This is probably to ensure only one copy of the malware can run at a time. With the mutex acquired it tries to open "C:\WINDOWS\System32\kernel64x.dll" and then calls 'SetFilePointer' to jump to the end of the file and then sub_10001380.

sub_10001380 appears to run in an infinite loop. In this loop there is a call to sub_10001030, followed by a call to sprintf, formatting a string in the format: "%s: %s\n" and then writing to the opened file. sub_10001030 must be where the malware gets the actualy key presses and any other info that is saved to the log file. Indeed, looking at sub_10001030 we see many calls to GetAsyncKeyState all well as mentions of "<SHIFT> " and calls to 'GetForegroundWindow' and 'GetWindowTextA' (in sub_10001000, called at the start of sub_10001030). This must be how the keylogger logs in which application the keyboard is being used.

By running the malware we can open the 'kernel64x.dll' file to verify that our keystrokes are indeed being written there, including the name of the application that was opened when the keys were pressed.

### Questions
1. Based on the "net start cisvc" string and a non-standard DLL (inet_epar32.dll) we can guess that it both uses the DLL and starts some service. Some of the strings in the DLL such as "<SHIFT>" and the imports such as 'GetAsyncKeyState' further imply that what this malware is doing is installing a keylogger.
2. The malware copies the included DLL into your system folder and installs a new service. It also modifies cisv.exe and starts its service.
3. The malware patches the cisvc.exe so that its entry point points to some shellcode that was inserted at the end of its text section. This shellcode loads the malware's 'inet_epar32.dll' and calls the method 'zzz69806582'.
4. cisvc.exe, the Windows Indexing Service.
5. Lab11-03.dll is a user-space keylogger that continuously checks the state of the keyboard with 'GetAsyncKeyState' and logs open applications and keys presses.
6. Key presses are logged to C:\WINDOWS\system32\kernel64x.dll.
