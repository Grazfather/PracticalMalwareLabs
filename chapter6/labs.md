# Chapter 6 labs
## Lab 6-1
### Basic Static Analysis
- strings: We see normal imports/imports (not packed) and an error message and success message "Error 1.1: No Internet", and "Success: Internet Connection".
- PEiD: Unpacked, Microsoft Visual C++ 6.0.
- Dependency Walker: Imports 'InternetGetConnectedState' from WININET.DLL as well as a bunch from KERNEL32.DLL but nothing out of the ordinary.
- PEview: Normal section names and headers.

### Basic Dynamic Analysis
Because the malware didn't import any functions to make internet connections I didn't bother with Wireshark or fakedns.py and just ran it. Procmon doesn't show anything interesting, and all we see in the shell is that it prints the success string from above.

### Advanced Static Analysis
Loaded into IDA we see a very simple main function that calls into sub_401000. Viewing this function in graph view easily shows it's an if/else statement, and we can see the addresses pushed on the stack before calling sub_40105F are strings.

### Questions
1. sub_401000 contains a simple if/else block that tests the result of 'InternetGetConnectedState'.
2. sub_40105F is called from both cases of the if/else block in sub_401000 and is passed a pointer to a success/failure string. Since we know these strings can get printed to the shell (from running the application) we can surmise that this function is something analogous to printf.
3. It appears this program does nothing more than check if the system has an internet connection and print a success/failure message.

## Lab 6-2
### Basic Static Analysis
- strings: References "http://www.practicalmalwareanalysis.com/cc.htm", "Internet Explorer 7.5/pma", some error messages, and imports/exports.
- PEiD: Unpacked, Microsoft Visual C++ 6.0.
- Dependency Walker: Imports 'InternetCloseHandle', 'InternetGetConnectedState', 'InternetOpenA', 'InternetOpenUrlA', and 'InternetReadFile' from WININET.DLL, as well as the typical fare from KERNEL32.DLL.
- PEview: Nothing out of the ordinary.

### Basic Dynamic Analysis
This malware actually tries to connect to the internet so I set up wireshark to sniff traffic, set my DNS to localhost, set up fakedns to point to localhost, and set up netcat listening on port 80. I also ran procmon filtering for Lab06-02.exe and ran it in a shell. Upon running the malware I see a dns request for www.practicalmalwareanalysis.com and a GET request for cc.htm (the string I saw earlier) with "Internet Explorer 7.5/pma" as the user-agent. On my shell I saw "Success: Internet Connection" and then "Error 2.1: Fail to OpenUrl" before the application ended. Procmon did not show the process spawning any children but did show a few tcp-related system calls (which are expected to be made due to the WININET.DLL imports).

### Advanced Static Analysis
Loaded into IDA it is quickly apparent that this program builds upon the previous lab's. It tests for an internet connection before setting up its user-agent and then downloading an html file and parsing the result to interpret it as a command.

### Questions
1. sub_401000 contains the same function as in the previous lab: It checks for an internect connection using 'InternetGetConnectedState' and prints a success or error message.
2. Just like in the previous lab, this function is simply printf.
3. sub_401040 is called if the previous call to sub_401000 successfully detects and internet connection. It then calls 'InternetOpenA' setting the user-agent to "Internet Explorer 7.5/pma" and then calls "InternetOpenUrlA" with the URL "http://www.practicalmalwareanalysis.com/cc.htm". If this call fails it prints an error mesage (which we saw since we faked the DNS) and returns. If it succeeds, then it tries to read this file using "InternetReadFile" and extract a command from it. It either prints another error messages and returns 0 or returns what is presumably the command.
4. It looks like this function uses an if statement with multiple logical ANDs to verify that the first four bytes of the file read match a certain pattern '<!--' (which looks like an html comment. It then returns the next character found in the file.
5. The URL it requests is consistent and is probably the best network-based indicator for this program. Another would be the user-agent that it is configured to use.
6. This command 'calls home' to the URL we saw in strings and parses cc.htm looking for a command string. In this version of the malware it doesn't seem to do anything with the command, it just verifies that the command is valid and then sleeps for a minute.

## Lab 6-3
### Basic Static Analysis
- strings: Same strings as before, plus a registry key, "Software\Microsoft\Windows\CurrentVersion\Run" (probably to persist reboots) and "C:\Temp\cc.exe".
- PEiD: Unpacked, Microsoft Visual C++ 6.0.
- Dependency Walker: Same WININET.DLL imports as Lab 6-2, plus new imports from ADVAPI32.DLL: 'RegOpenKeyExA' and 'RegSetValueExA' (to write to the registry). There is also now 'CopyFileA', 'CreateDirectoryA', and 'DeleteFileA' from KERNEL32.DLL that weren't in the previous lab.
- PEview: Nothing out of the ordinary.

### Basic Dynamic Analysis
With the same setup as before I noticed similar behaviour. Since I knew it would be looking for a comment at the start of the file, I created a simple _cc.htm_ file containing only '<!--G' and served it with a simple python one liner: `python -m SimpleHTTPServer 80` and had a different set of messages appear. This time it received the command fine but complained that 'G' was not a valid command. We will have to look at it in IDA to see what we can get it to do. Searching through the procmon log I don't see the registry key being written, and C:\Temp\cc.exe doesn't exist: It probably won't install unless instructed to.

### Advanted Static Analysis

### Questions
1. This program's main function looks a lot like the previous versions, but this one now calls sub_401130 after verifying that it can parse a command from _cc.html_.
2. This new function is passed the command character it parsed from cc.html argv[0], which is the filename of the program we're running.
3. A value of 61 is subtracted from the byte and then is checked if it's above 4. If it is then the program prints the invalid command message and terminates, but if it isn't (the value is 0 to 4 inclusive) then that value is used as an index into a jump table. It looks like this is a switch case statement. Since 61 is 'a' in ASCII and we allow values from 0 to 4, that means this function expects commands from 'a' to 'e'.
4. The function responds to one of five commands (ASCII values 'a' to 'e') and either: Creates C:\Temp, copies itself to C:\Temp\cc.exe, deletes C:\Temp\cc.exe, adds a new key called 'Malware' with value 'C:\Temp\cc.exe' in the registry key we found with strings, or sleeps for 100 seconds.
5. Host based indicators could be the registry key name 'Malware' or the name of the file that is created 'C:\Temp\cc.exe'.
6. This malware extends on the malware we saw previously to add the ability to install or remove itself from the system.
