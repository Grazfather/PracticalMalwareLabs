# Chapter 6 labs
## Lab 6-1
### Basic Static Analysis
- **strings**: We see normal imports/imports (not packed) and an error message and success message "Error 1.1: No Internet", and "Success: Internet Connection".
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports 'InternetGetConnectedState' from WININET.DLL as well as a bunch from KERNEL32.DLL but nothing out of the ordinary.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Because the malware didn't import any functions to make internet connections I didn't bother with Wireshark or fakedns.py and just ran it from the shell. Procmon doesn't show anything interesting, and all we see in the shell is that it prints the success string from above.

### Advanced Static Analysis
Loaded into IDA we see a very simple main function that calls into sub_401000. Viewing this function in graph view easily shows it's an if/else statement, and we can see the addresses pushed on the stack before calling sub_40105F are strings.

### Questions
1. sub_401000 contains a simple if/else block that tests the result of 'InternetGetConnectedState'.
2. sub_40105F is called from both cases of the if/else block in sub_401000 and is passed a pointer to a success/failure string. Since we know these strings can get printed to the shell (from running the application) we can surmise that this function is something analogous to printf.
3. It appears this program does nothing more than check if the system has an internet connection and print a success/failure message.

## Lab 6-2
### Basic Static Analysis
- **strings**: References "http://www.practicalmalwareanalysis.com/cc.htm", "Internet Explorer 7.5/pma", some error messages, and imports/exports.
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports 'InternetCloseHandle', 'InternetGetConnectedState', 'InternetOpenA', 'InternetOpenUrlA', and 'InternetReadFile' from WININET.DLL, as well as the typical fare from KERNEL32.DLL.
- **PEview**: Nothing out of the ordinary.

### Basic Dynamic Analysis
This malware actually tries to connect to the internet so I set up wireshark to sniff traffic, set my DNS to localhost, set up fakedns to point to localhost, and set up netcat listening on port 80. I also ran procmon filtering for Lab06-02.exe and ran it in a shell. Upon running the malware I see a dns request for www.practicalmalwareanalysis.com and a GET request for cc.htm (the string I saw earlier) with "Internet Explorer 7.5/pma" as the user-agent. On my shell I saw "Success: Internet Connection" and then "Error 2.1: Fail to OpenUrl" before the application ended. Procmon did not show the process spawning any children but did show a few tcp-related system calls (which are expected to be made due to the WININET.DLL imports).

### Advanced Static Analysis
Loaded into IDA it is quickly apparent that this program builds upon the previous labs. It tests for an internet connection before setting up its user-agent and then downloads an html file and parses the result to interpret it as a command.

### Questions
1. sub_401000 contains the same function as in the previous lab: It checks for an internect connection using 'InternetGetConnectedState' and prints a success or error message.
2. Just like in the previous lab, this function is simply printf.
3. sub_401040 is called if the previous call to sub_401000 successfully detects and internet connection. It then calls 'InternetOpenA' setting the user-agent to "Internet Explorer 7.5/pma" and then calls "InternetOpenUrlA" with the URL "http://www.practicalmalwareanalysis.com/cc.htm". If this call fails it prints an error mesage (which we saw since we faked the DNS) and returns. If it succeeds, then it tries to read this file using "InternetReadFile" and extract a command from it. It either prints another error messages and returns 0 or returns what is presumably the command.
4. It looks like this function uses an if statement with multiple logical ANDs to verify that the first four bytes of the file read match a certain pattern '<!--' (which looks like an html comment. It then returns the next character found in the file.
5. The URL it requests is consistent and is probably the best network-based indicator for this program. Another would be the user-agent that it is configured to use.
6. This command 'calls home' to the URL we saw in strings and parses cc.htm looking for a command string. In this version of the malware it doesn't seem to do anything with the command, it just verifies that the command is valid and then sleeps for a minute.

## Lab 6-3
### Basic Static Analysis
- **strings**: Same strings as before, plus a registry key, "Software\Microsoft\Windows\CurrentVersion\Run" (probably to persist reboots) and "C:\Temp\cc.exe".
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Same WININET.DLL imports as Lab 6-2, plus new imports from ADVAPI32.DLL: 'RegOpenKeyExA' and 'RegSetValueExA' (to write to the registry). There is also now 'CopyFileA', 'CreateDirectoryA', and 'DeleteFileA' from KERNEL32.DLL that weren't in the previous lab.
- **PEview**: Nothing out of the ordinary.

### Basic Dynamic Analysis
With the same setup as before I noticed similar behaviour. Since I knew it would be looking for a comment at the start of the file, I created a simple _cc.htm_ file containing only '<!--G' and served it with a simple python one liner: `python -m SimpleHTTPServer 80` and had a different set of messages appear. This time it received the command fine but complained that 'G' was not a valid command. We will have to look at it in IDA to see what we can get it to do. Searching through the procmon log I don't see the registry key being written, and C:\Temp\cc.exe doesn't exist: It probably won't install unless instructed to.

### Advanced Static Analysis

### Questions
1. This program's main function looks a lot like the previous versions, but this one now calls sub_401130 after verifying that it can parse a command from _cc.htm_.
2. This new function is passed the command character it parsed from cc.htm argv[0], which is the filename of the program we're running.
3. A value of 61 is subtracted from the byte and then is checked if it's above 4. If it is, then the program prints the invalid command message and terminates. If it isn't, (the value is 0 to 4 inclusive) then that value is used as an index into a jump table. It looks like this is a switch case statement. Since 61 is 'a' in ASCII and we allow values from 0 to 4, that means this function expects commands from 'a' to 'e'.
4. The function responds to one of five commands (ASCII values 'a' to 'e') and either: Creates _C:\Temp_, copies itself to _C:\Temp\cc.exe_, deletes _C:\Temp\cc.exe_, adds a new key called 'Malware' with value 'C:\Temp\cc.exe' in the registry key we found with strings, or sleeps for 100 seconds.
5. Host based indicators could be the registry key name 'Malware' or the name of the file that is created 'C:\Temp\cc.exe'.
6. This program extends on the malware we saw previously to add the ability to install or remove itself from the system.

## Lab 6-4
### Basic Static Analysis
- **strings**: Same strings as before, but the user-agent string has been changed so that it's followed with an 'int' token: "Internet Explorer 7.50/pma%d".
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Same as previous.
- **PEview**: Nothing out of the ordinary.

### Basic Dynamic Analysis
With the same setup as used previously I observed similar results. I noticed that the user-agent was appended with a '0'. I am guessing that subsequent requests (if we can trigger them) will increment this number. Setting up my _cc.htm_ with a command in the range of 'a' to 'e' gets a success message printed. If I keep the application running it seems to continuously try to fetch this cc.htm page every minute or so.

### Advanced Static Analysis
The program's flow looks the same as before, but now, as long as we don't get any error, it looks like we continue to loop. It looks like a for loop since the condition is checked at the end of the loop and the loop starts with an unconditional jump to the end. It will loop 1440 times.

### Questions
1. sub_401000 is the same (check if there's an internet connection). sub_401040 is the function that grabs the cc.htm file and parses it for commands. sub_4012B5 is printf and sub_401150 executes the command.
2. A for loop around the whole 'fetch command, parse command, execute command, sleep' bit.
3. At the start of the function the user-agent string is formed using the new string we detected in basic static analysis. This function is now passed an integer argument which is passed along with the user-agent string to sprintf to form the user-agent string with the number appended at the end. As predicted, the number passed to this function is incremented with each iteration of the for loop in main.
4. Since the for loop will run 1440 times and on each iteration it sleeps for a minute, it should run for almost one day exactly.
5. Again, the network based indicators would be the URL it fetches and the user-agent string. The difference with the previous labs is that the user-agent string now changes with the number of times it calls home.
6. The purpose of this malware is to 'call home' every minute for 24 hours to receive a small set of commands and execute them on the victim's machine.
