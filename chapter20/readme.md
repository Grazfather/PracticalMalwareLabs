# Lab 20

## Lab 20-1
### Basic Static Analysis
- **strings**: "empdownload.exe", "http://www.practicalmalwareanalysis.com/cpp.html", plus C++ error messages.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `URLDownloadToFileA` from URLMON.DLL, many from KERNEL32.DLL, including `WriteFile`, `LoadLibraryA`, and `VirtualAlloc`.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Starting up Process Monitor and running the malware we can see connections made to 192.0.78.24 over http. This appears to be the IP address of www.practicalmalwareanalysis.com at the time of this writing. After this the process seems to end immediately. Setting up fakedns and `nc` to catch the request, we see it's a simple GET for _cpp.html_, which we've seen in the string.

### Advanced Static Analysis
Popping the binary into IDA we see a call to `new`, creating a _uint_. Its address is stored to two locals on the stack, and then the address of the URL is stored at the start of the returned object. The address of this object is then copied into ecx and `sub_401040` is called, provided no args, but if we look into its body we see that ecx is used. This function simply reads out the pointer from the object and then calls `URLDownloadToFileA` with a target of "c:\tempdownload.exe".

### Questions
1. Yes, it takes a single object (`this`) in ecx.
2. "http://wwww.practicalmalwareanalysis.com/cpp.html", whose pointer was stored in the object we called the method on.
3. The program downloads the file to "c:\tempdownload.exe". `strings` got the string above ("empdownload" incorrect for some reason.

## Lab 20-2
### Basic Static Analysis
- **strings**: "ftp.practicalmalwareanalysis.com", "Home ftp client", "%s-%d.pdf", "%s-%d.doc".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Many from KERNEL32.DLL, most notably `FindFirstFile` and `FindNextFile`. `FtpPutFileA`, `FtpSetCurrentDirectoryA`, `InternetCloseHandle`, `InternetConnectA`, and `InternetOpenA` from WININET.DLL, `gethostname` and `WSAStartup` from WS2_32.DLL (by ordinal).
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
With process monitor and fakedns we see a request to ftp.practicalmalwareanalysis.com as well as traffic on port 21. We also see many many directories being opened.

### Advanced Static Analysis
`WinMain` starts out simple: Starts up the winsock library with `WSAStartup`, calles `gethostname` to get the local machine's hostname and write it to a global buffer, and then calls `sub_401000`, passing in the string "C:\\*".

`sub_401000` has a big loop that starts with `FindFirstFileA` and ends with `FindNextFileA`, so it looks like it's searching the C drive for something. There's also a comparison with the second arg with the value 7, returning once that value is surpased, however the value passed by `WinMain` is zero. Looking at other xrefs we see that the function is recursive, and we see that that value is increment before recursing. This is clearly a depth counter and 7 is the max number of times it can recurse.

Once a file attributes struct is populated with the first file, its _dwFileAttributes_ is checked against 0x10, which is the flag for _FILE_ATTRIBUTE_DIRECTORY_. If this test, or the next two, which check if the filename is _._ or _.._, fail, then it falls through to some alternate branch. The filename has its extension pointer saved into a local and full path is built from the wildcard string and the current file's filename, and then the file's extension is compared with ".doc", and then with ".pdf", and depending on which match (or if none match) a different object is created using `new`. We see the vtable pointer get assigned, and for one of the paths (where a matching ".pdf" was found) the value is assigned twice, first with `off_4060E0` and then with `off_4060D8`. When a matching ".doc" is found the vtable pointer is set to `off_4060DC`. In the case where there are no matches the table is assigned only once, with `off_4060E0`. From this we can infer that those three addresses are vtables, and that the first is a superclass of the two. We know now that there are two classes that inherit from a parent class but not from eachother, and so we name them `vtable1`, `vtable1_1` and `vtable1_2`.

After these file objects are created separately, their paths converge, and we see the full path that was constructed is assigned to to the object at offset +4. After this the vtable is pulled out, the first (and only) function pointer is extracted, the object itself is copied into ecx, and the function pointer is called.

```asm
loc_40132F:                             ; CODE XREF: sub_401000+249
                                        ; sub_401000+2D8
                mov     ecx, [ebp+lastobj] ; Get last obj pointer
                mov     edx, [ebp+filename_bufptr]
                mov     [ecx+4], edx    ; Set object's filename to the one we built from the filename and the current dir
                mov     eax, [ebp+lastobj] ; Get vtable
                mov     edx, [eax]      ; Get address of first func
                mov     ecx, [ebp+lastobj] ; Set `this`
                call    dword ptr [edx] ; Call the method
```

The alternate branch, when we find a directory that isn't named _._ or _.._, we see that a new buffer is allocated, the folder name is appended to the current path and the wild card is appended. From here the depth is incremented and the function recurses. This is clearly simply a recursive file explorer, where each object is encapsulated in an instance of one of three clases, and that class's method is called, but we don't know yet what these three methods do.

The first, parent class's method, `sub_401370` was actually named by IDA `std::_Init_locks::~_Init_locks`, and `~` in C++ represents a _destructor_. This function, however, doesn't seem to do anything.

The second, the ftp class's method, `sub_401380` actually seems to do something. With no branches and a few calls, it's easy to analyze: `InternetOpen`, `InternecConnectA` to "ftp.practicalmalwareanalysis.com" on port 21, `FtpSetCurrentDirectoryA`, `sprintf` to build a filename from a global file counter plus the hostname, `FtpPutFileA`, and `InternetCloseHandle` twice. This simply tries to connect to an ftp server and upload the file there with a simple _\<hostname\>-\<found index\>.pdf_ filename.

The third and final, the doc class's method, `sub_401440` does the exact same the pdf version, except the format string is build so that the extension is .doc

In the end, it looks like this malware tries to find all _*.pdf_ and _*.doc_ files in your C drive and upload them to the attacker's ftp server.

### Question
1. The strings hint that there is ftp functionality, as well as give a filename scheme and a target ftp server.
2. The imports confirm the ftp functionality and `FindFirstFile` and `FindNextFile` suggest that the victim's files will be iterated over.
3. This object encapsulates a doc file and stores a pointer to its full path.
4. There are three functions that can be called, based on the three classes. `sub_401370`, which does nothing, `sub_401380`, which uploads the target file with a .pdf extension, and `sub_401440`, which does the same as the previous but with a .doc extension.
5. Setting up an ftp server that allows anonymous write access, plus changing the DNS server to localhost and then running something like fakedns to resolve all dns requests to point to this server we could see the files get uploaded.
6. Find all _*.pdf_ and _*.doc_ files in your C drive and upload them to the attacker's ftp server.
7. This allows the upload be handled different based on the file type. This malware, ignores non-doc, non-pdfs in this way, but handles it rather poorly (It could skip creating objects for normal files and could use a single object that has a field that contains its extension, for example, removing the need for virtual function entirely).

## Lab 20-3
### Basic Static Analysis
- **strings**: Some mangled strings, HTTP header field format strings, a bunch of error messages, and a few html file names.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `GetUserNameA` from ADVAPI32.DLL, low level socket imports from WS2_32.DLL, and a whole bunch from KERNEL32.DLL.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Running netcat on port 80 (guessed based on the existence of HTTP header fields from `strings`, I see a GET request for index.html, but there is also form data encoded: "data=keqjeb;ktrmg=¦f@;qtbnujsy=RKFM". The malware seems to hang waiting for a response. When I pasted a simple HTTP response and then killed the connection I got a message about an exception in `main`.

### Advanced Static Analysis
Popping the binary into IDA and finding the xrefs to `send`, `recv`, and `connect` let me quickly identify the routines responsible for most of the network stuff. `sub_404480`, `sub_4048E0`, and `sub_403D50`, respectively. Looking at other interesting imports, such at `CreateFileA` found me functions to upload (`sub_4027E0`), download (`sub_402A20`), as well as to read a _config.dat_ (`sub_403180`). Some functions also made calls to `exception::exception`. Finding these xrefs let me quickly find all the different exception constructor methods and the blocks where the are created (and then passed to `__CxxThrowException`) to finish up another chunk of analysis. After this I went to `main`.

`main` does nothing but call another function, which I've called `real_main`. This function creates an object, calls a method on it, passing in "config.dat", then calls another method on it, and finally a third method in a loop with a call to `Sleep`. The first method probably sets up an object, the second probably initializes some connection, and the last is probably the polling function, since it's in an infinite loop.

Starting from the top, `sub_401EE0` starts by allocating another object with `new`, and then calls a method on this object. Here I created two structs to track each one's member attributes. The first method called on the second object is passed on the filename from main. The named file is opened with `CreateFileA` and it's read, and there's a check for a magic number of 0x46414243, or "CBAF". Before this check, however, is a call to another member. Inside this function is a loop and an xor, so it looks like a simple decrypting function. Opening the provided _config.dat_ in a hex editor, I can see that the magic normally wouldn't match "CBAF", and there is repeated 0x4E bytes. Looking before the call to the decrypt function we see a 0x4E written to an attribute on the config object, to be used as the decryption key, confirming our suspicion. Back in `sub_401EE0`, we see that the second object's pointer is saved at +0 in the first object, and a bunch of html file names are written to other members. As guessed, this function sets up the initial state.

Next, in `sub_401F80`, we see that this function is rather large. To get a quick idea of its functionality I graphed the calls from it. Ignoring inlined functions, I looked from some of the interesting imports. There I found `connect`, `htons`, `socket`, `gethostbyname`, and `inet_addr`. Following `gethostbyname` brought me to `sub_4042C0`, which looks to simply resolve the provided domain. This is called by `sub_403DAD`, which does the `socket` and `connect` calls. This function is called many times, always after a call to `new`, so it looks like it's a constructor for a connection-type object.

Next in `sub_401F80` is `sub_402FF0`. This function seems rather simple: It calls `GetComputerNameA` and then builds some strings. It appears to be collecting information about the victim's PC.

Three more function calls are left. The first two are methods on the third type we defined, while the third is just a function. Because we've already defined the functions that send and receive data, we can analyze these quickly. The first, `sub_404ED0` calls `sub_404EF0`, which builds a POST http header and sends the provided data. The second receives some data, parses out part of the expected HTTP response header, and then receives in a loop until it gets everything according to the _Content-Length_ header.

In the end this is a very simple malware, though one that is rather full-featured. It acts as a command and control, querying commands from a webserver. It supports a bunch of functions, including downloading, uploading, running commands, and exfiltrating information. It's also configurable, and the configuration is encrypted, although the encryption is trivial to figure out.

### Questions
1. The strings give away the name of the config file used, and the fact that this malware makes HTTP requests with manually-built headers.
2. Besides the fact that there are many imports (implying a lot of functionality), the imports from WS2_32.DLL show that there is low-level socket control going on.
3. The function only takes the error message, but we know it is a class method (probably a constructor) because ecx is set with the address of a buffer in the calling frame, and that address is later provided to `exception::exception`. This address is then passed (as a normal argument) to `__CxxThrowException`.
4. The six entries do the following: Nothing, sleep, run a command, download a file, upload a file, and send the victim's computer's information.
5. This is a malware that acts as a command and control, receiving commands by pulling them from a web server.
