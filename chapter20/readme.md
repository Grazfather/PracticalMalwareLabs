# Lab 20

## Lab 20-1
### Basic Static Analysis
- **strings**: "empdownload.exe", "http://www.practicalmalwareanalysis.com/cpp.html", plus C++ error messages.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `URLDownloadToFileA` from URLMON.DLL, many from KERNEL32.DLL, including `WriteFile`, `LoadLibraryA`, and `VirtualAlloc`.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Starting up Process Monitor and running the malware we can see connections made to 192.0.78.24 over http. This appears to be the IP address of www.practicalmalwareanalysis.com at the time of this writing. After this the process seems to end immediately. Setting up fakedns and `nc` to catch the request, we see it's a simple GET for _cpp.html_, which we've seen in the string.

### Advanced Static Analysis
Popping the binary into IDA we see a call to `new`, creating a _uint_. Its address is stored to two locals on the stack, and then the address of the URL is stored at the start of the returned object. The address of this object is then copied into ecx and `sub_401040` is called, provided no args, but if we look into its body we see that ecx is used. This function simply reads out the pointer from the object and then calls `URLDownloadToFileA` with a target of "c:\tempdownload.exe".

### Questions
1. Yes, it takes a single object (`this`) in ecx.
2. "http://wwww.practicalmalwareanalysis.com/cpp.html", whose pointer was stored in the object we called the method on.
3. The program downloads the file to "c:\tempdownload.exe". `strings` got the string above ("empdownload" incorrect for some reason.

## Lab 20-2
### Basic Static Analysis
- **strings**: "ftp.practicalmalwareanalysis.com", "Home ftp client", "%s-%d.pdf", "%s-%d.doc".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Many from KERNEL32.DLL, most notably `FindFirstFile` and `FindNextFile`. `FtpPutFileA`, `FtpSetCurrentDirectoryA`, `InternetCloseHandle`, `InternetConnectA`, and `InternetOpenA` from WININET.DLL, `gethostname` and `WSAStartup` from WS2_32.DLL (by ordinal).
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
With process monitor and fakedns we see a request to ftp.practicalmalwareanalysis.com as well as traffic on port 21. We also see many many directories being opened.

### Advanced Static Analysis
`WinMain` starts out simple: Starts up the winsock library with `WSAStartup`, calles `gethostname` to get the local machine's hostname and write it to a global buffer, and then calls `sub_401000`, passing in the string "C:\\*".

`sub_401000` has a big loop that starts with `FindFirstFileA` and ends with `FindNextFileA`, so it looks like it's searching the C drive for something. There's also a comparison with the second arg with the value 7, returning once that value is surpased, however the value passed by `WinMain` is zero. Looking at other xrefs we see that the function is recursive, and we see that that value is increment before recursing. This is clearly a depth counter and 7 is the max number of times it can recurse.

Once a file attributes struct is populated with the first file, its _dwFileAttributes_ is checked against 0x10, which is the flag for _FILE_ATTRIBUTE_DIRECTORY_. If this test, or the next two, which check if the filename is _._ or _.._, fail, then it falls through to some alternate branch. The filename has its extension pointer saved into a local and full path is built from the wildcard string and the current file's filename, and then the file's extension is compared with ".doc", and then with ".pdf", and depending on which match (or if none match) a different object is created using `new`. We see the vtable pointer get assigned, and for one of the paths (where a matching ".pdf" was found) the value is assigned twice, first with `off_4060E0` and then with `off_4060D8`. When a matching ".doc" is found the vtable pointer is set to `off_4060DC`. In the case where there are no matches the table is assigned only once, with `off_4060E0`. From this we can infer that those three addresses are vtables, and that the first is a superclass of the two. We know now that there are two classes that inherit from a parent class but not from eachother, and so we name them `vtable1`, `vtable1_1` and `vtable1_2`.

After these file objects are created separately, their paths converge, and we see the full path that was constructed is assigned to to the object at offset +4. After this the vtable is pulled out, the first (and only) function pointer is extracted, the object itself is copied into ecx, and the function pointer is called.

```asm
loc_40132F:                             ; CODE XREF: sub_401000+249
                                        ; sub_401000+2D8
                mov     ecx, [ebp+lastobj] ; Get last obj pointer
                mov     edx, [ebp+filename_bufptr]
                mov     [ecx+4], edx    ; Set object's filename to the one we built from the filename and the current dir
                mov     eax, [ebp+lastobj] ; Get vtable
                mov     edx, [eax]      ; Get address of first func
                mov     ecx, [ebp+lastobj] ; Set `this`
                call    dword ptr [edx] ; Call the method
```

The alternate branch, when we find a directory that isn't named _._ or _.._, we see that a new buffer is allocated, the folder name is appended to the current path and the wild card is appended. From here the depth is incremented and the function recurses. This is clearly simply a recursive file explorer, where each object is encapsulated in an instance of one of three clases, and that class's method is called, but we don't know yet what these three methods do.

The first, parent class's method, `sub_401370` was actually named by IDA `std::_Init_locks::~_Init_locks`, and `~` in C++ represents a _destructor_. This function, however, doesn't seem to do anything.

The second, the ftp class's method, `sub_401380` actually seems to do something. With no branches and a few calls, it's easy to analyze: `InternetOpen`, `InternecConnectA` to "ftp.practicalmalwareanalysis.com" on port 21, `FtpSetCurrentDirectoryA`, `sprintf` to build a filename from a global file counter plus the hostname, `FtpPutFileA`, and `InternetCloseHandle` twice. This simply tries to connect to an ftp server and upload the file there with a simple _\<hostname\>-\<found index\>.pdf_ filename.

The third and final, the doc class's method, `sub_401440` does the exact same the pdf version, except the format string is build so that the extension is .doc

In the end, it looks like this malware tries to find all _*.pdf_ and _*.doc_ files in your C drive and upload them to the attacker's ftp server.

### Question
1. The strings hint that there is ftp functionality, as well as give a filename scheme and a target ftp server.
2. The imports confirm the ftp functionality and `FindFirstFile` and `FindNextFile` suggest that the victim's files will be iterated over.
3. This object encapsulates a doc file and stores a pointer to its full path.
4. There are three functions that can be called, based on the three classes. `sub_401370`, which does nothing, `sub_401380`, which uploads the target file with a .pdf extension, and `sub_401440`, which does the same as the previous but with a .doc extension.
5. Setting up an ftp server that allows anonymous write access, plus changing the DNS server to localhost and then running something like fakedns to resolve all dns requests to point to this server we could see the files get uploaded.
6. Find all _*.pdf_ and _*.doc_ files in your C drive and upload them to the attacker's ftp server.
7. This allows the upload be handled different based on the file type. This malware, ignores non-doc, non-pdfs in this way, but handles it rather poorly (It could skip creating objects for normal files and could use a single object that has a field that contains its extension, for example, removing the need for virtual function entirely).
