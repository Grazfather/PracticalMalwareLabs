# Chapter 7 labs
## Lab 7-1
### Basic Static Analysis
- strings: A few errors: "runtime error", "TLOSS error", "SING error", and "DOMAIN error", some messages that start with "- " that seem related to memory ("- unable to initialize heap"). "HDL345", "MalService" and "Malservice", "http://www.malwareanalysisbook.com" and "Internet Explorer 8.0" all are suspicious as well.
- PEiD: Unpacked, Microsoft Visual C++ 6.0.
- Dependency Walker: Imports from KERNEL32.LL including to create threads, mutexes, get/free environment strings, and 'TerminateProcess' all seem suspect. From ADVAPI32.LL it imports 'CreateServiceA', 'OpenSCManagerA', and 'SatartServiceCtrlDispatcherA' which suggests it installs this malware as a service (especially considering we see "MalService" with strings above). From WININET.DLL it imports 'InternetOpenA' and 'InternetOpenUrlA'.
- PEview: Normal section names and headers.

### Basic Dynamic Analysis
Set up fakedns, netcat on port 80, regshot and procmon, then ran the malware from the shell. We see a DNS request for www.malwareanalysisbook.com as expected as well as an http request with the user-name set to "Internet Explorer 8.0" and Cache-Control set to "no-cache". The application seems to continue to run. In regshot we see that a service called "Malservice" has been installed. In procmon we see the registry writes for the new service and a bunch of different threads started. The service is installed with the original exe, so it doesn't appear a copy was made. After advanced static analysis I am not sure why we got this far: I expected the http requests and threads being created would not start until 2100.

### Advanced Static Analysis
Right when this application begins it called 'StartServiceCtrlDispatcherA' with the _lpServiceName_ as "MalService" and the lpServiceProc sub_401040. It then calls this sub_401040. This sub_401040 attempts to open a mutex calls "HGL345" if it succeeds it closes, otherwise it proceeds to create a mutex with this name, and then connect to the service control manager using 'OpenSCManagerA'. It then calls 'GetCurrentProcess' and then 'GetModuleFileNameA' with a NULL _hModule_ argument to get the filename of the malware. With this information is forms the arguments to 'CreateServiceA' which it calls next. It sets the _dwServiceType_ to "SERVICE_WIN32_OWN_PROCESS" and the _dwStartType_ to "SERVICE_BOOT_START", so we know it expects to run on every boot. It then appears to create a timer with all fields except the year set to 0, and the year set to 2100 (January 1, 2100) and calls 'WaitForSingleObject' to wait until this time. Once January 1, 2100 hits it then creates 20 new threads in a loop, each starting at the function 'StartAddress'. This function is what makes the connection attempt to "www.malwareanalysisbook.com" in a loop with no delay. Once 20 threads have been created sub_401040 sleeps for 0xFFFFFFFF milliseconds before returning.

### Questions
1. This program is able to resume after the computer is restarted because it installs itself as a service named "MalService".
2. The program uses a mutex presumably to make sure there is only one instance of itself running on the system at a time.
3. A good host-based signature would be the name of the service this program tries to register itself as as well as the name of the mutex it creates.
4. A good network-based signature would probably be the URL it requests as well as the user-agent it uses for its requests.
5. The purpose of this program is to spawn many threads and then spamm requests to "www.practicalmalwarebook.com", probably for DDoS pruposes. It is like some of the malware I have already seen but it in more advanced in that it spawns multiple threads and it achieves persistence through use of Windows Services.
6. This program will finish executing about 4 billion milliseconds, or about 46 days after January 1, 2100.

## Lab 7-2
### Basic Static Analysis
- strings: Only a few strings this time, including "http://www.malwareanalysisbook.com/ad.html".
- PEiD: Unpacked, Microsoft Visual C++ 6.0.
- Dependency Walker: Not the usual set of imports. Imports from OLE32.DLL: 'CoCreateInstance', 'OleInitialize', and 'OleUninitialize'. From OLEAUT32.DLL: 'SysAllocString', 'SysFreeString', and 'VariantInit' (all by ordinal). From MSVCRT.DLL what look like low-level imports: '_exit', 'exit', '__getmainargs', and others.
- PEview: Normal section names and headers.

### Basic Dynamic Analysis
With the same setup as usual I ran this program and it immediately opened internet explorer and made an http request for "http://www.malwareanalysisbook.com/ad.html". The request was different from what we've seen before. Testing with internet explorer requesting another website we see this is just a normal request from Internet Explorer. Regshot did not show any relevant registry changes.

### Advanced Static Analysis
The program starts by calling 'OleInitialize'. Looking this up on MSDN we see it's used to initialize 'COM'. It looks like this malware will leverage another application to do its bidding. If this call succeeds the program proceeds to call 'CoCreateInstance' and then 'VariantInit' and 'SysAllocString' on success. 'CoCreateInstance' is passed a CLSID and an IID. Since these are both GUIDs we know the format is "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" (all hex). Parsing the data into the text encoding we see they are '0002DF01-0000-0000-C000-000000000046' and 'D30C1661-CDAF-11D0-8A3E-00C04FC9E26E', respectively. The CLSID appears to belong to Internet Explorer and the IID is for _IWebBrowser2_, defined in _exdisp.h_. 'SysAllocString' is called with the URL string we saw from the strings output, and looking it up I see it's used to allocate space for (and copy) a string into kernel space. After this the function jumps to add address 0x2C bytes offset into the _ppv_ returned from 'CoCreateInstance'. Searching for _exdisp.h_ we find the method that would be at offset 0x2C is 'Navigate'. This means the program is getting a COM object for Internet Explorer and then calling its 'Navigate' function with the first argument the pointer to the COM object, the second the pointer to the kernel's copy of the URL string (since the Internet Explorer process wouldn't have access to our copy, presumably), the third the pointer to var_10 (which contains value 3), the fourth pointer to pvarg, and the fifth another pointer to pvarg. At this point the program diligently calls SysFreeString on its previous allocation, calls 'OleUninitialize' and then exits.

### Questions
1. It doesn't appear that this program makes any attempt to achieve persistence.
2. It looks like this program only attempts to get Internet Explorer to open a specified URL. Since the page requested is ad.html we can assume it's trying to display an ad.
3. This program finishes executing immediately after making the COM request and executing the COM object's 'Navigate' function.
