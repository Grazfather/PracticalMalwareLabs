# Chapter 7 labs
## Lab 7-1
### Basic Static Analysis
- **strings**: A few errors: "runtime error", "TLOSS error", "SING error", and "DOMAIN error", some messages that start with "- " that seem related to memory ("- unable to initialize heap"). "HGL345", "MalService" and "Malservice", "http://www.malwareanalysisbook.com" and "Internet Explorer 8.0" all are suspicious as well.
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports from KERNEL32.LL including to create threads, mutexes, get/free environment strings, and 'TerminateProcess' all seem suspect. From ADVAPI32.LL it imports 'CreateServiceA', 'OpenSCManagerA', and 'StartServiceCtrlDispatcherA' which suggests it installs this malware as a service (especially considering we see "MalService" with strings above). From WININET.DLL it imports 'InternetOpenA' and 'InternetOpenUrlA'.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Set up fakedns, netcat on port 80, regshot and procmon, then ran the malware from the shell. We see a DNS request for www.malwareanalysisbook.com as expected as well as an http request with the user-name set to "Internet Explorer 8.0" and Cache-Control set to "no-cache". The application seems to continue to run. In regshot we see that a service called "Malservice" has been installed. In procmon we see the registry writes for the new service and a bunch of different threads started. The service is installed with the original exe, so it doesn't appear a copy was made. After advanced static analysis I am not sure why we got this far: I expected the http requests and threads being created would not start until 2100.

### Advanced Static Analysis
Right when this application begins it called 'StartServiceCtrlDispatcherA' with the _lpServiceName_ as "MalService" and the lpServiceProc sub_401040. It then calls this sub_401040. This sub_401040 attempts to open a mutex calls "HGL345" if it succeeds it closes, otherwise it proceeds to create a mutex with this name, and then connect to the service control manager using 'OpenSCManagerA'. It then calls 'GetCurrentProcess' and then 'GetModuleFileNameA' with a NULL _hModule_ argument to get the filename of the malware. With this information is forms the arguments to 'CreateServiceA' which it calls next. It sets the _dwServiceType_ to "SERVICE_WIN32_OWN_PROCESS" and the _dwStartType_ to "SERVICE_BOOT_START", so we know it expects to run on every boot. It then appears to create a timer with all fields except the year set to 0, and the year set to 2100 (January 1, 2100) and calls 'WaitForSingleObject' to wait until this time. Once January 1, 2100 hits it then creates 20 new threads in a loop, each starting at the function 'StartAddress'. This function is what makes the connection attempt to "www.malwareanalysisbook.com" in a loop with no delay. Once 20 threads have been created sub_401040 sleeps for 0xFFFFFFFF milliseconds before returning.

### Questions
1. This program is able to resume after the computer is restarted because it installs itself as a service named "MalService".
2. The program uses a mutex presumably to make sure there is only one instance of itself running on the system at a time.
3. A good host-based signature would be the name of the service this program tries to register itself as as well as the name of the mutex it creates.
4. A good network-based signature would probably be the URL it requests as well as the user-agent it uses for its requests.
5. The purpose of this program is to spawn many threads and then spam requests to "www.malwareanalysisbook.com", probably for DDoS pruposes. It is like some of the malware I have already seen but it in more advanced in that it spawns multiple threads and it achieves persistence through use of Windows Services.
6. This program will finish executing about 4 billion milliseconds, or about 46 days after January 1, 2100.

## Lab 7-2
### Basic Static Analysis
- **strings**: Only a few strings this time, including "http://www.malwareanalysisbook.com/ad.html".
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Not the usual set of imports. Imports from OLE32.DLL: 'CoCreateInstance', 'OleInitialize', and 'OleUninitialize'. From OLEAUT32.DLL: 'SysAllocString', 'SysFreeString', and 'VariantInit' (all by ordinal). From MSVCRT.DLL what look like low-level imports: '_exit', 'exit', '__getmainargs', and others.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
With the same setup as usual I ran this program and it immediately opened internet explorer and made an http request for "http://www.malwareanalysisbook.com/ad.html". The request was different from what we've seen before. Testing with internet explorer requesting another website we see this is just a normal request from Internet Explorer. Regshot did not show any relevant registry changes.

### Advanced Static Analysis
The program starts by calling 'OleInitialize'. Looking this up on MSDN we see it's used to initialize 'COM'. It looks like this malware will leverage another application to do its bidding. If this call succeeds the program proceeds to call 'CoCreateInstance' and then 'VariantInit' and 'SysAllocString' on success. 'CoCreateInstance' is passed a CLSID and an IID. Since these are both GUIDs we know the format is "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" (all hex). Parsing the data into the text encoding we see they are '0002DF01-0000-0000-C000-000000000046' and 'D30C1661-CDAF-11D0-8A3E-00C04FC9E26E', respectively. The CLSID appears to belong to Internet Explorer and the IID is for _IWebBrowser2_, defined in _exdisp.h_. 'SysAllocString' is called with the URL string we saw from the strings output, and looking it up I see it's used to allocate space for (and copy) a string into kernel space. After this the function jumps to add address 0x2C bytes offset into the _ppv_ returned from 'CoCreateInstance'. Searching for _exdisp.h_ we find the method that would be at offset 0x2C is 'Navigate'. This means the program is getting a COM object for Internet Explorer and then calling its 'Navigate' function with the first argument the pointer to the COM object, the second the pointer to the kernel's copy of the URL string (since the Internet Explorer process wouldn't have access to our copy, presumably), the third the pointer to var_10 (which contains value 3), the fourth pointer to pvarg, and the fifth another pointer to pvarg. At this point the program diligently calls SysFreeString on its previous allocation, calls 'OleUninitialize' and then exits.

### Questions
1. It doesn't appear that this program makes any attempt to achieve persistence.
2. It looks like this program only attempts to get Internet Explorer to open a specified URL. Since the page requested is ad.html we can assume it's trying to display an ad.
3. This program finishes executing immediately after making the COM request and executing the COM object's 'Navigate' function.

## Lab 7-3
### Basic Static Analysis
- **strings**:
  - **dll**: An ip address "127.26.152.13", some imports/exports, "sleep", and "hello".
  - **exe**: ".exe", "C:\*", "C:\windows\system32\kerne132.dll" (That's _kerne<one>32.dll_) "Kernel32.", the name of the DLL, "C:\Windows\System32\Kernel32.dll", and "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE".
- **PEiD**:
  - **dll**: Unpacked, Microsoft Visual C++ 6.0 DLL.
  - **exe**: Microsoft Visual C++ 6.0.
- **Dependency Walker**:
  - **dll**: mutex and process-related stuff, low level socket stuff from WS2_32.DLL (by ordinal), and some memory-related functions from MSVCRT.DLL.
  - **exe**: File reading, writing, and mapping stuff from KERNEL32.DLL, and some memory-related functions plus '_except_handler3' from MSVCRT.DLL. Interestingly, the exe does not import the DLL, and the DLL exports no functions.
- **PEview**: Normal section names and headers.

### Static and Dynamic Analysis
Because analyzing this program took multiple iterations of static and dynamic analysis I will group them together.

With the usual dynamic analysis setup I ran this malware and nothing appears to happen. Regshot showed no relevant changes and procmon showed the program did almost nothing. We will have to look to see if this is the proper way to run the malware (maybe we are supposed to use rundll). Running it a second time we see in procmon that it does a lot more work. It opens a bunch of dlls and maps them into the process's address space. It also tries to read some registry keys, some of which don't exist: "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\Lab07-03.exe". This might be normal behaviour (handled by the OS).

Starting with the DLL, we see it starts its DllMain function by trying to open and then creatue a mutex called "SADFHUHF". We saw this in a previous lab: It was used to make sure only one copy of the malware is running at a time. Looking at other calls we see it sets up WINSOCK and tries to connect to the IP address we saw in strings, sending "hello". It looks like it connects to this server to receive commands, parse, and execute in a loop, another pattern we've seen before.

Hopping over to the exe, we look at what it does with the command line argument. It looks like it compares it to "WARNING_THIS_WILL_DESTROY_YOUR_MACHINE". This was probably added for us so we know what we are getting into when we run the malware. Let's set up a snapshot and run it with `Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE` (can't say we weren't warned).

As soon as you run it you can tell something is going on. Procmon shows thousands of events (vs. dozens in other cases) and you can hear it writing a lot to disk. After about a minute it finally finishes and the process closes. Looking at proc mon we see a lot of calls to 'QueryDirectory' with wild cards. It appears to be opening every file on the filesystem and mapping them into memory, eventually closing them all. I don't see the normal process teardown so I think maybe the process crashed because it opened up too many files or ran out of space to map them.

Back in IDA with the EXE we look into what's happening after the argv[1] comparison. It appears to open kernel32.dll and Lab07-03.dll and map them both into memory, overwriting argc and argv with their pointers. It then calls sub_401040 a bunch of times, and we see sub_401040 calls sub_401000, but we will look at these later. It also makes a call to sub_401070. Near the bottom of main we see a call to 'CopyFileA' with the new file being "C:\windows\system32\kerne132.dll" (the string we saw earlier that substitutes an 'l' for a '1') and the source file being "Lab07-03.dll" and then it calls sub_4011E0 with an argument "C:\*" just before ending the process. It looks like this application is hiding the malicious DLL, and I am guessing that the code earlier finds every valid file on the file system and somehow loads _kernel132.dll_.

Moving back to the DLL we are going to look at how it communicated with the server. The DLL calls back to the server and sends the string 'hello' and then waits to receive a response. Once a response is received it compares the start of the response with 'sleep'. If they match, then the process sleeps for 0x60000 seconds (maybe unintentional, probably meant 60'000 in decimal), at which point it loops back and sends another 'hello'. If the command is not 'sleep' it checks for 'exec', and on match calls 'CreateProcessA' with a NULL _lpApplicationName_, but the _lpCommandLine_ is the 'CommandLine' arguments on the stack. Looking at IDA's stack variabled we see that 'CommandLine' is at offset -0xFFB while 'buf', where the received command is stored, is at offset -0x1000. Since 'exec' is only four characters, plus 0x1000-0xFFB = 5, we know that 'CommandLine' starts at the word after 'exec' in the command.

Going back to DllMain and looking for cross-references we see that DllMain is called from DllEntryPoint, which is included in DLLs that are loaded using 'LoadLibrary'. We won't go into too much detail in this function: It looks like it checks the _fdwReason_ argument and then calls DllMain based on that. It looks like this malware is started with LoadLibrary, so the main EXE must modify EXEs so that they explicitly load this DLL. Loading up a compromised EXE in dependency walker we see that it imports KERNE132.LL but not KERNEL32.DLL: Clearly the malware modifies the applications' import tables to replace kernel32.dll with the malware's version. The question is how the applications will work without a proper kernel32.dll? It is only 160KB comparted to 970KB for the real kernel32.dll. Loading the malicious kerne132.dll into Dependency Walker shows that it has the same import and export table as Lab07-03.dll, as well as the exact same filesize. Looking in the .rdata section in PEview we can look at the export table, and we see that kerne132.dll (and the original Lab07-03.dll) exports 0x3BA functions (The same number as our kernel32.dll), and their description is "Forwarded Name RVA". It looks like this malware's DLL imports kernel32.dll so that it can provide all of its functionality while adding some of its own. The malware must read kernel32.dll, look as its exports, and then modify the malicious dll to export the same functions. Restoring back to the snapshot we see that Lab07-03.dll is changed after we run the malware by comparing the md5sum before and after executing the malware.

Now we will look into the details of how the malware modifies all the exes on the filesystem and how it modifies its own dll to adopt kernel32.dll's functionality. Near the end of main we see sub_4011E0 is called with "C:\*" as its argument, which we noted earlier. This must be where it searches the filesystem for exes. Looking in this function for calls, we see that it calls itself -- It's a recursive function, which is very common for functions that traverse trees (and a filesystem is a tree-like structure). The function starts by calling 'FindFirstFileA' with the path it wants, and then looks for the extension. If the extension is .exe it calls sub_4010A0, otherwise it calls 'FindNextFileA' and loops. If the current file is a directory, it recurses, looking for all exes in that subfolder.

sub_4010A0 looks to be where the exes found earlier are patched. The passed in filename is opened with 'CreateFileA' and then mapped into the process's memory with 'CreateFileMappingA' and 'MapViewOfFile'. At some point '_stricmp' is called with an offset into the file and "kernel32.dll" as arguments -- It might be looking for kernel32.dll in the import table. If kernel32.dll is found then it copies over it. IDA shows this as some DWORD, but if we show it as ASCII we see we are actually copying in "kerne132.dll". This confirms that this function is used to patch the executable so that it imports the malicious dll instead of kernel32.dll.

Now that we know what this malware does and how it works, we can patch it so that it can be used to actually remove itself. To do this we need to modify sub_4010A0 to search for "kerne132.dll" and replace it with the original "kernel32.dll". This can easily be done by changing both strings in the binary. This is easily done with a hex editor: Just find the offsets of the strings in the binary using PEview (0x3010 for "kerne132.dll and 0x3020 for "kernel32.dll") and swap the 'l' and '1' bytes. We can replace the calls to patch the malicious binary (though not necessary) and then make sure we remove kerne132.dll. Because we cannot patch every exe (if they cannot be opened for write) there may be some that exe's that still point to the malicious dll, and remove this dll will prevent the program from starting correctly. Unfortunately, when testing, it appears that the malicious exe does not even make it to its main function when run a second time.

### Questions
1. The malware achieves persistence by creating a malicious DLL that replaces kernel32.dll while providing all of its functionality. Any application that imports kernel32.ll is modified to instead import the malicious kerne132.dll.
2. The name of the mutex that the DLL uses: "SADFHUHF" and the sneaky name of the malicious dll we copy to: "C:\windows\system32\kerne132.dll".
3. The purpose of this program is to call home to accept commands. It either accepts 'sleep' or 'exec'. The 'exec' command will run any following arguments directly.
4. This would not be an easy malware to fix. You could, however, probably leverage the malware itself: Modify it so that instead of looking for kernel32.dll and replacing it with kerne132.dll, it does the opposite. Once that is done, remove kerne132.dll and the rest of the malware.
