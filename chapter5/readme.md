# Chapter 5 labs
## Lab 5-1
### Questions
1. `DllMain` is at 0x1000D02E in the .text section.
2. `gethostbyname` is at 0x100163CC in the .idate section.
3. Right-clicking on `gethostbyname` and clicking on 'Chart xrefs to' brings up a WinGraph32 that shows *five* functions make call to it. If we instead highlight gethostbyname and press Ctrl-X we see *nine* references (from the same five functions).
4. We see we first move off_10019040 into eax and then add 0xD to it, then push this onto the stack as the only argument to `gethostbyname`.  Double clicking on this offset shows it points to a string "[This is RDO]pics.praticalmalwareanalysis.com". 0xD bytes into this string is the start of "pics.praticalmalwareanalysis.com". The malware is trying to get the IP address of "pics.praticalmalwareanalysis.com".
5. IDA recognizes 20 local variables spanning 0x675 bytes. Looking at the solution in the book it appears my version of IDA (free) is missing a few function definitions, and is naming a few differently, as well. Apparently the free version limits itself to 20 local variables. However, the full version of IDA Pro recognizes 24 variables.
6. IDA recognizes only one argument.
7. "\\cmd.exe /c" is located at 0x10095B34 in the 'xdoors_d' section.
8. The malware is concatenating "\cmd.exe /c" and whatever string is in the 'CommandLine' local buffer. This buffer would have been filled in the previous call to `GetSystemDirectoryA`. That makes this call part of the process to create a commandline string (for example "C:\WINDOWS\SYSTEM32\cmd.exe /c" for a reverse shell. IDA appears to show double backslashes for literal backslashes to prevent confusion when a string contains special characters, so in IDA the string appeared as "\\cmd.exe /c".
9. dword_1008E5C4 is written to at the start of sub_10001656 right after a call to sub_100036C3. This sub seems to query the OS version by making a call to `GetVersionExA` and then queyring the PlatformID and MajorVersion. If the PlatformId is 2 and the MajorVersion is 5 then it returns 1, otherwise it returns 0. This is probably to make sure cmd.exe exists on the system (instead of command.exe, which we see a string contains at 0x100095B20).
10. At loc_100104449 we see the comparison in question. If the string matches "robotwork" then we call sub_100052A2 where we open a registry key "SOFTWARE\\Microsoft\\Windows\\CurrentVersion" and query the value of the 'WorkTime' key. We then get that value, convert it to an integer and puts it in the string "\r\n\r\n[Robot_WorkTime ;] %d\r\n\r\n" which it sends over the socket s. It then does the same with the 'WorkTimes' key.
11. PSLISt calls sub_100036C3 which we described in question 9. If the OS version is 2,5 (sub_100036C3 returns 1) then it checks the length of the string it was passed if the string is not empty it calls sub_10006518 which appears to iterate over all running processes finding a match. If the string _is_ blank then it calls sub_1000664C which does similar but returns a list of processes. If the OS version is not 2,5 it just returns.
12. sub_10004E79 calls into GetSystemDefaultLangID, sprintf, sub_100038EE, and strlen. sub_100038EE itself calls into send, malloc, and free.  Judging by these calls I would say that this function gets the language setting of the system and sends it to the attacker. It looks like sub_100038EE sends a selected string of choice to the attacker. We could call it 'GetDefaultLanguage'.
13. DllMain calls into `strncpy`, `_strnicmp`, `CreateThread`, and `strlen` (plus a few local functions). At depth 2 it calls into a lot more: `strcpy`, `strncpy`, `strlen`, `memcpy`, `strchr`, `inet_ntoa`, `gethostbyname`, `WinExec`, `Sleep`, `CreateThread`, `CloseHandle`, `WSAStartup`, `select`, `FreeLibrary`, `strncmp`, `closesocket`, `ExitThread`, `LoadLibraryA`, `memcmp`, `GetProcAddress`, `WSAGetLastError`, `__imp_printf`, `recv`, `GetTickCount`, `socket`, `send`, `ntohs`, `memset`, `connect`, `atoi`, and `inet_addr`.
14. This `Sleep` call is passed 30000 as its argument, so it will sleep for 30 seconds. First eax is given a pointer to the string "[This is CTI]30" and then offset by 0xD. This points to "30", and it passed to `atoi`, which would return 30. Finally, this number is multiplied by 1000 to yield 30000.
15. The three arguments to `socket` are 2, 1, and 6 for the af, type, and protocol.
16. These correspond to 'AF_INET', 'SOCK_STREAM', and 'IPPROTO_TCP', respectively.
17. Searching for all instance of 'in' and then sorting by instruction to find the actual instruction we see it at 0x100061DB in sub_10006196. Before running 'in' the malware moves 0x564D5868 which is 'VMXh' in ASCII. Pressing CTRL-X we see three calls to this function, all of which have a reference to a string "Found Virtual Machine,Install Cancel." soon after.
18. At 0x1001D988 we see what looks like random characters (in readable ASCII range).
19. The book suggested I run the provided python script in IDA. Because the script won't run in IDA Free (apparently) I modified the python script by copying the raw bytes from the program and running the 'decoding' function on it and just printing out the decoded output.

    ```python
    import array
    crypt = [0x2D, 0x31, 0x3A, 0x3A, 0x27, 0x75, 0x3C, 0x26, 0x75, 0x21, 0x3D, 0x3C, 0x26, 0x75, 0x37, 0x34,
             0x36, 0x3E, 0x31, 0x3A, 0x3A, 0x27, 0x79, 0x75, 0x26, 0x21, 0x27, 0x3C, 0x3B, 0x32, 0x75, 0x31,
             0x30, 0x36, 0x3A, 0x31, 0x30, 0x31, 0x75, 0x33, 0x3A, 0x27, 0x75, 0x05, 0x27, 0x34, 0x36, 0x21,
             0x3C, 0x36, 0x34, 0x39, 0x75, 0x18, 0x34, 0x39, 0x22, 0x34, 0x27, 0x30, 0x75, 0x14, 0x3B, 0x34,
             0x39, 0x2C, 0x26, 0x3C, 0x26, 0x75, 0x19, 0x34, 0x37, 0x75, 0x6F, 0x7C, 0x64, 0x67, 0x66, 0x61]
    cryptarray = array.array('B', crypt)

    for i in range(len(cryptarray)):
        cryptarray[i] ^= 0x55

    print cryptarray.tostring()
    ```

    The output to this is the string "xdoor is this backdoor, string decoded for Practical Malware Analysis Lab :)1234".
20. Press A to have IDA try and interpret the data as an ASCII string.
21. The script is very simple. It uses `ScrennEA` to get the location of the cursor and then loops over the 0x50 bytes after this position, XORing each with 0x55 and then re-writing it with `PatchByte`.
