# Chapter 5 labs
## Lab 5-1
### Questions
1. 'DllMain' is at 0x1000D02E in the .text section.
2. 'gethostbyname' is at 0x100163CC in the .idate section.
3. Right-clicking on 'gethostbyname' and clicking on 'Chart xrefs to' brings up a WinGraph32 that shows *five* functions make call to it. If we instead highlight gethostbyname and press Ctrl-X we see *nine* references (from the same five functions).
4. We see we first move off_10019040 into eax and then add 0xD to it, then push this onto the stack as the only argument to 'gethostbyname'.  Double clicking on this offset shows it points to a string "[This is RDO]pics.praticalmalwareanalysis.com". 0xD bytes into this string is the start of "pics.praticalmalwareanalysis.com". The malware is trying to get the IP address of "pics.praticalmalwareanalysis.com".
5. IDA recognizes 20 local variables spanning 0x675 bytes. Looking at the solution in the book it appears my version of IDA (free) is missing a few function definitions, and is naming a few differently, as well. Apparently the free version limits itself to 20 local variables.
6. IDA recognizes only one argument.
7. "\\cmd.exe /c" is located at 0x10095B34 in the 'xdoors_d' section.
8. The malware is concatenating "\cmd.exe /c" and whatever string is in the 'CommandLine' local buffer. This buffer would have been filled in the previous call to 'GetSystemDirectoryA'. That makes this call part of the process to create a commandline string (for example "C:\WINDOWS\SYSTEM32\cmd.exe /c" for a reverse shell. IDA appears to show double backslashes for literal backslashes to prevent confusion when a string contains special characters, so in IDA the string appeared as "\\cmd.exe /c".
9. dword_1008E5C4 is written to at the start of sub_10001656 right after a call to sub_100036C3. This sub seems to query the OS version by making a call to 'GetVersionExA' and then queyring the PlatformID and MajorVersion. If the PlatformId is 2 and the MajorVersion is 5 then it returns 1, otherwise it returns 0. This is probably to make sure cmd.exe exists on the system (instead of command.exe, which we see a string contains at 0x100095B20).
10. At loc_100104449 we see the comparison in question. If the string matches "robotwork" then we call sub_100052A2 where we open a registry key "SOFTWARE\\Microsoft\\Windows\\CurrentVersion" and query the value of the 'WorkTime' key. We then get that value, convert it to an integer and puts it in the string "\r\n\r\n[Robot_WorkTime ;] %d\r\n\r\n" which it sends over the socket s. It then does the same with the 'WorkTimes' key.
11. PSLISt calls sub_100036C3 which we described in question 9. If the OS version is 2,5 (sub_100036C3 returns 1) then it checks the length of the string it was passed if the string is not empty it calls sub_10006518 which appears to iterate over all running processes finding a match. If the string _is_ blank then it calls sub_1000664C which does similar but returns a list of processes. If the OS version is not 2,5 it just returns.
