## Lab 14-1
### Basic Static Analysis
- **strings**: The standard base64 alphabet, "http://www.practicalmalwareanalysis.com/%s/%c.png", "%s-%s", "%c%c:%c%c:%c%c:%c%c:%c%c:%c%c".
- **PEiD**: Microsoft Visual C++ 6.0., plus KANAL detected a BASE64 table at 0x50C0.
- **Dependency Walker**: `URLDownloadToCacheFileA`' from _URLMON.DLL_, `GetCurrentHwProfile` and `GetUserNameA` from _ADVAPI32.DLL_, and a bunch from _KERNEL32.DLL_, including `CreateProcessA`.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Using fakedns.py and netcat to listen on port 80 I see that the malware makes a GET request to a resource at "/ODA6NmQ6NjE6NzI6Njk6NmYtRGVidWdnZXIa/a.png", which matches the string found previous. Base64 decoding this string "80:6d:61:72:69:6f-Debugger", which is something that looks like a MAC address (not the mac address of my VM's NIC, though, determined by running `getmac /v`) and my username. The first part of this string looks like it was formatted using the format string found above.

### Advanced Dynamic/Static Analysis
Looking at the binary in IDA I can see immediately where the requested string comes from: `GetCurrentHwProfileA` is called and 12 bytes are picked out of the generated structure, starting at offset 0x19. According to MSDN these bytes correspond to the last 12 bytes of the system's GUID. Next there is a call to `GetUserNameA` and the result there is combined with the partial GUID. This composed string is passed to `sub_4010BB`, which I quickly figured was the base64-encoding function by looking at it in OllyDBG, and this base64-encoded string is passed to `sub_4011A3`. This function gets the last byte of the base64 string, the base64 string itself, and combines it into the full request (This is why the request was _a.png_ -- To match the 'a' at the end of the base64 string).

This URL is finally used with `URLDownloadToCacheFileA`, which saves the response to a file. Because we aren't actually connecting to the server, we must infer what it is doing from here on out. This is rather easily done, since it is calling `CreateProcessA`, and passing in the filename received from the server as the executable.

### Questions
1. `URLDownloadToCache` is used, which simplifies looking up the hostname, building the HTTP header, and saving the output. This interface also uses Windows-generated traffic, so the User-Agent and such looks legitimate.
2. The last 12 digits of the victim computer's GUID and the username of the user that executed the malware.
3. To fingerprint which machine is responsible for which traffic. The remote server could provide a special binary for each request and map that fingerprint to a GUID.
4. This malware uses standard base64 alphabet. (Looking at the solution, it appears it uses 'a' as padding instead of '='. The decoder I used did not complain about the single byte of padding so I did not notice).
5. This malware calls back to a remote server with some information about the victim and then executes the binary that the server responds with.
6. Because we know the GUID is 12 characters plus five colons, and there is presumably a limit to filename length, we can constrain the length of the directory in the request, and of course constrain the available characters to those in the standard base64 alphabet, and constrain the filename of the png to the last character of the directory. Because the colons are equally spaced three characters they show up as the same character consistently in the encoded string ('6'), so we can check for five sixes at regularly spaces intervals (every three characters make four characters in base64). The same can be done with the dash between the GUID and the username.
7. Since most of the time the base64 string will require padding, and because that padding for this implementation is 'a', most of the time the filename will be a.png, but not always (it depends on the length of the victim's username).
8. `/\/[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}t([A-Za-z0-9+\/]{4}){1,}\/[A-Za-z0-9+\/]\.png/` will match a base64 encoded string with 5 regularly spaces colons, a dash, and then some multiple of four base64 characters, followed by a slash, another base64 character, and ".png". This doesn't however, make sure that the character filename matches the last character before the slash.

## Lab 14-2
### Basic Static Analysis
- **strings**: What looks like a base64 alphabet, but shifted by some amount (starting with 'W'), "http://127.0.0.1/tenfour.html", "cmd.exe".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `InternetOpenA` and other functions from _WININET.DLL_, `ShellExecuteEx` and `SHChangeNotify` from _SHELL32.DLL_, `LoadStringA` from _USER32.DLL_, plus process and thread management functions from _KERNEL32.DLL_.
- **PEview**: Resource section
- **Resource Hacker** (Because of the presence of `LoadStringA` and the .rsrc section): A single resource named "String Table", whose value is the URL above.

### Basic Dynamic Analysis
With Regshot we don't see anything, but procmon is interesting. We see it spawn `cmd.exe` to delete the binary itself. We also see some connections made to a web server on the local machine (presumably the URL above).

We can use Python's `SimpleHTTPServer` to verify that the malware is making requests to our local machine, but they look benign... Only GET requests for _tenfour.html_. By writing our own little script we can dump the request headers.

```python
import BaseHTTPServer

HOST_NAME = "127.0.0.1"
PORT = 80

class HeaderDumpHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    def do_GET(self):
        print self.headers
        self.send_response(200)

server = BaseHTTPServer.HTTPServer((HOST_NAME, PORT), HeaderDumpHandler)
try:
    server.serve_forever()
except KeyboardInterrupt:
    pass
server.server_close()
```

This yields more interesting information:

```bash
C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis Labs\
BinaryCollection\Chapter_14L>c:\Python27\python.exe header_dump.py
User-Agent: (!<e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqxUE
73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A6t/C
pVl963p9qDLCLViE2XlBqipB65SDciC4c3H8r1N8qaQdlpHBcDHC+4Go6tHBcLnA7hGebaICpVYA6tHC
/LZBqVQ96i0A6xS7liM87X0973Fhe1hkG==
Host: 127.0.0.1
Cache-Control: no-cache
```

We can try to decode this (it's obviously base64) but it looks like binary data. It could be some custom format, but what's more likely is that it was encoded using the modified base64 alphabet we noticed when we ran `strings` on the binary.

Using another simple script we can decode it:

```python
import string
import base64

STANDARD_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
CUSTOM_ALPHABET = 'WXYZlabcd3fghijko12e456789ABCDEFGHIJKL+/MNOPQRSTUVmn0pqrstuvwxyz'
DECODE_TRANS = string.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)

def decode(input):
    return base64.b64decode(input.translate(DECODE_TRANS))

print decode('e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqxUE73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A6t/CpVl963p9qDLCLViE2XlBqipB65SDciC4c3H8r1N8qaQdlpHBcDHC+4Go6tHBcLnA7hGebaICpVYA6tHC/LZBqVQ96i0A6xS7liM87X0973Fhe1hkG==')
```

Which spits out:

```bash
Microsoft Windows XP [Version 5.1.2600] 
(C) Copyright 1985-2001 Microsoft Corp. 
 
C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis 
Labs\BinaryCollection\Chapter_14L> 
```

We also see requests with the User-Agent set to "Internet-Surf", which could be another network fingerprint. It looks like the application acts as a reverse shell that communicates over HTTP, hiding the output in the 'User-Agent' field of the head, encoded in base64 with a custom alphabet.

### Advanced Dynamic Analysis
Popping the binary into IDA as always, I see that there aren't many functions. The binary is actually only 7KB, which should make this easy. Quickly skimming the calls in `WinMain` we see calls to create a pipe, create a process, duplicate a handle, and spawn `cmd`. This is likely setting up a pipe so that the malware can write into and read from the shell prompt. Two threads are created, and then the function cleans up, calling `sub_401880`. `sub_401880` is simple and not worth too much time: It tries to delete itself, and we saw how using procmon in our dynamic analysis.

The first thread calls `PeekNamedPipe`, `ReadFile` and that's it. It probably exists only to read the shell. The buffer that contains the data written is passed to `sub_401000`, where we see mentions of the custom base64 alphabet, so this function probably encodes it. IDA doesn't correctly decode `loc_401750`, but we can turn it into a function using `P`. In this function we see the "(!<" string we saw prepending our base64 data, and then we see calls to `InternetOpen` and `InternetOpenURL`, so that's probably exactly what this does.

The second thread calls `sub_401800` which makes more internet calls -- presumably to get commands to send to the shell. It then processes this data, writing it to the pipe, but checking also for the word 'exit'. It doesn't look like it needs to decode anything, so it looks like the attacker's client just sends the commands in plain text.

### Network Signatures

The easiest way to determine that this particular piece of malware is running is by the URL that it requests, but because it is pulled from the .rsrc section, it is very likely that other customized version target other IPs and paths. The "Internet Surf" User-Agent is a good one, as well as any request with a User-Agent that starts with "(!<". We could also used a regex to look for base64 encoded user agents.

### Questions
1. Using direct addresses gets around issues like depending on DNS (which we can spoof with _fakedns.py_), but also is less flexible, as the malware could be useless if we ever lose that IP address.
2. This malware uses the libraries from WININET.DLL. These offer less fine grained control than lowere level libraries, but they offer the convenience of forming request headers correctly for you. This also allows you to avoid having strings such as "User-Agent" in the binary itself.
3. The URL that the malware reaches out two is found in the .rsrc section of the binary. If the IP address changes, the attacker can replace the resource without recompiling the binary, which could make customization easier.
4. This malware hides the information it wants to share with the attacker in the 'User-Agent' field of HTTP GET requests, encoded using a custom base64 alphabet.
5. The `cmd` prompt.
6. HTTP doesn't hold connections open, so it isn't a great way to get instant feed back in a way you might want for something like running commands on a shell. A thread must stay alive, continually making new connections to the server to make GET requests just to see if the server has anything it wants to do.
7. It is base64, but uses a custom alphabet. You can decode it simply by mapping each character in the base64 back to it's proper character before decoding.
8. The thread that makes GET requests with the "Internet Surf" User-Agent looks for the word "exit" and quits if it sees it, bringing down the other threads in turn.
9. This malware is a simple backdoor that tries to provide the attacker with a remote shell. Once the attacker is finished with the backdoor, the backdoor tries to delete itself.

## Lab 14-3
### Basic Static Analysis
- **strings**: "http://www.practicalmalwareanalysis.com/start.htm", "C:\autobat.exe", and some HTTP header strings.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `InternetOpenA` and other functions from _WININET.DLL_, `URLDownloadToCacheFileA` from _URLMON.DLL_, plus process and thread management functions from _KERNEL32.DLL_.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Using fakedns.py and `nc` and procmon I see a request to the host and page found in the `strings` output. The User-Agent and other headers show up in strings, but there's an additional header "UA-CPU" which is set to "x86". There must be a bug in the malware, because the User-Agent string itself contains another "User-Agent" string. "Cache-Control" is set to "no-cache" which suggests that this remote web server is used for more than just dumping data, but also for C&C. The fact that the connection is held open further suggests that it expects a response. I see system calls made to open network connections as well as to open "C:\autobat.exe". This file contains only the request URL.

```bash
C:\Program Files\netcat>nc -l -p 80
GET /start.htm HTTP/1.1
Accept: */*
Accept-Language: en-US
UA-CPU: x86
Accept-Encoding: gzip, deflate
User-Agent: User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET
CLR 3.0.4506.2152; .NET CLR 3.5.30729)
Host: www.practicalmalwareanalysis.com
Cache-Control: no-cache
```

### Advanced Analysis
Deciding on a more dynamic approach, I open the malware in both Olly and IDA. Using IDA's graph just speeds me up a lot. Looking first for the file stuff, I search for intermodular calls to `ReadFile` and `WriteFile`. Putting breakpoints on them I see the write happen first, writing the hard coded url to "autobat.exe". Naming that function `write_autobat` and moving on to `ReadFile`, I see it called from the same function that calls our writer. It looks like its read from it if it exists and writes a 'default' url there otherwise. Putting breakpoints on other interesting intermodular calls, I see a call to `InternetOpenA` from a function called directly from main (viewing the stack). Tracing through I had to modify my python server from Lab 14-2 so that it sends a response. Later on in this function, after reading the response, it calls `strstr` on the returned data, looking for "<no". If that string can be found, it passes the addresses where that starts to `sub_401000` which then byte-by-byte, out of order, checks that each character matches a certain value. By single-stepping and then poking the value into memory, I could pass all the checks and see what it was looking for: "<noscript>". Once this is found, it gets the URL it requested and chops off everything after the _last_ '/', found using `strrchr`, and then checks that the buffer that starts with "<noscript>" contains it. It adds the length of the domain to get a pointer right after that part of the response, and then makes sure it can find "96'" in what remains. If so, it chops off that bit by adding a null byte over the '9' char and returns 1.

With a pointer that points to the data between the end of the domain and the end delimeter, `sub_401684` is called, and its use of `strtok` makes it apparent it is doing more parsing. '/' is used as the token, and only the first and second token are saved. The first byte of the first token is compared against 'd', and if  less than 14 characters beyond that, that offset is used as an offset into an offset table at _byte_40173E_, which is used is used in the offset table at _off_40172A_. Most of the offsets just to the fifth case, which 
is actually the same case as if the character is out of range. This leaves four offsets that actually do something.

The first, which is only called if the char is exactly 'd', calls `sub_401565`, which makes calls to `URLDownloadToCacheFileA` and then spawns a process. Digging into this, we see that it is passed the pointer to the string _after_ the '/'. It is likely that the format they expect, then, is a single byte command, follow by any amount of garbage, followed by a slash, and then follow by the argument to that command. This argument is passed to `sub_401147`.

`sub_401147` seems to be a decoding function. If references the alphabet string found earlier. It is provided the second argument and a pointer to a local buffer. First the function makes sure that the encoded string is an even number of bytes long, and if so, enters the processing loop. On each iteration of the loop it grabs the two current characters and calls `atoi` on them. It uses this value as an index into the alphabet we found in the strings, and then stores the corresponding char in the buffer. To test my theory I wrote a simple python script to encode a desired URL as in this format:

```python
s = "http://www.example.com"
lu = "/abcdefghijklmnopqrstuvwxyz0123456789:."
for c in s:
    print("{:02}".format(lu.index(c)), end="")
```

Confirming this decodes back to the provided string, I see this value get passed to `URLDownloadToCacheFile`, whose result gets passed to `CreateProcessA`. This is like Lab 14-1.

The second function, triggered by the 'n' command, causes the function to return 1, which causes the malware to stop running.

The third function, triggered by the 'r' command, calls `sub_401147` again to decode the argument, and then calls the function that was used to write the _autobat.exe_ file. This command is used to replace the default command and control server with a new URL.

The fourth function, triggered by the 's' command, calls a simple function `sub_401613` which tries to parse out a number from the argument and to sleep that many seconds. Failing that, it just sleeps 20 seconds.

### Network Signatures

Probably the easiest way to detect this malware is to look for requests that have a User-Agent header that contains "User-Agent" at the start (The literal string "User-Agent: User-Agent: " in the request). Responses that match the regex `/<noscript>.+/.+96'/` will identify servers trying to control the malware. The other hard-coded headers can also be used.

### Questions
1. A bunch of the headers are hardcoded, including the User-Agent. The url as well. For a signature, the URL would not be as good of a setting since it can be reprogrammed. Because of the double User-Agent we see in the actual request, that's is probably a very unique one.
2. Because the URL can be configured, it is not a very good long-term signature.
3. The malware obtains command by making GET requests to a configured URL. It looks for a string starting with "<noscript>" and ending with "96'", that must also contain the domain that the URL requested from. Because of these delimeters, command can be hidden within legitimate web pages, which was like an example in the chapter where command were hidden in html comments.
4. There are actually a few checks that are done:
  1. Command starts with "<noscript>".
  2. Command ends with "96'".
  3. Command contains domain of URL requested.
  4. Commands are one of 'd', 'n', 'r', and 's'.
  5. Argument are encoded as two digit numbers that index into a lookup table to get each character.
5. Encoding is a simple lookup table, where every two digits are converted to a number using `atoi`, and that value is used as an index into a lookup table. And advantage is that looking at the encoded values does not make it immediately clear what the encoding is, plus it would take more reverse engineering effort to figure out how it works. A down side is that the density is worse than base64.
6. The malware supports four commands, each one character:
  1. 'd', which will run the command present in the response seen when the URL argument is downloaded.
  2. 'n', which quits the malware.
  3. 'r', which takes an encoded URL and causes the malware to use that URL in the future to request commands.
  4. 's', which sleeps a specified amount of time.
7. This malware's purpose is to call back to a server to download and run the programs that the server returns. Probably intended as a first step an attacker can quickly use to gain control and then plant more malware later.
8. We can target traffic that happens at a few steps. The call out uses a specific set of headers. The response follows a specific schema for it to reach the command dispatcher, and finally the commands themselves are expected to have a specific syntax.
9. Although not exhaustive, we could create the following:
  1. Signature on the hard coded headers.
  2. Signature on the response delimiters.
  3. Signature on the specific commands (e.g. arg encoding scheme).
