## Lab 14-1
### Basic Static Analysis
- **strings**: The standard base64 alphabet, "http://www.practicalmalwareanalysis.com/%s/%c.png", "%s-%s", "%c%c:%c%c:%c%c:%c%c:%c%c:%c%c".
- **PEiD**: Microsoft Visual C++ 6.0., plus KANAL detected a BASE64 table at 0x50C0.
- **Dependency Walker**: `URLDownloadToCacheFileA`' from _URLMON.DLL_, `GetCurrentHwProfile` and `GetUserNameA` from _ADVAPI32.DLL_, and a bunch from _KERNEL32.DLL_, including `CreateProcessA`.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Using fakedns.py and netcat to listen on port 80 I see that the malware makes a GET request to a resource at "/ODA6NmQ6NjE6NzI6Njk6NmYtRGVidWdnZXIa/a.png", which matches the string found previous. Base64 decoding this string "80:6d:61:72:69:6f-Debugger", which is something that looks like a MAC address (not the mac address of my VM's NIC, though, determined by running `getmac /v`) and my username. The first part of this string looks like it was formatted using the format string found above.

### Advanced Dynamic/Static Analysis
Looking at the binary in IDA I can see immediately where the requested string comes from: `GetCurrentHwProfileA` is called and 12 bytes are picked out of the generated structure, starting at offset 0x19. According to MSDN these bytes correspond to the last 12 bytes of the system's GUID. Next there is a call to `GetUserNameA` and the result there is combined with the partial GUID. This composed string is passed to `sub_4010BB`, which I quickly figured was the base64-encoding function by looking at it in OllyDBG, and this base64-encoded string is passed to `sub_4011A3`. This function gets the last byte of the base64 string, the base64 string itself, and combines it into the full request (This is why the request was _a.png_ -- To match the 'a' at the end of the base64 string).

This URL is finally used with `URLDownloadToCacheFileA`, which saves the response to a file. Because we aren't actually connecting to the server, we must infer what it is doing from here on out. This is rather easily done, since it is calling `CreateProcessA`, and passing in the filename received from the server as the executable.

### Questions
1. `URLDownloadToCache` is used, which simplifies looking up the hostname, building the HTTP header, and saving the output. This interface also uses Windows-generated traffic, so the User-Agent and such looks legitimate.
2. The last 12 digits of the victim computer's GUID and the username of the user that executed the malware.
3. To fingerprint which machine is responsible for which traffic. The remote server could provide a special binary for each request and map that fingerprint to a GUID.
4. This malware uses standard base64 alphabet. (Looking at the solution, it appears it uses 'a' as padding instead of '='. The decoder I used did not complain about the single byte of padding so I did not notice).
5. This malware calls back to a remote server with some information about the victim and then executes the binary that the server responds with.
6. Because we know the GUID is 12 characters plus five colons, and there is presumably a limit to filename length, we can constrain the length of the directory in the request, and of course constrain the available characters to those in the standard base64 alphabet, and constrain the filename of the png to the last character of the directory. Because the colons are equally spaced three characters they show up as the same character consistently in the encoded string ('6'), so we can check for five sixes at regularly spaces intervals (every three characters make four characters in base64). The same can be done with the dash between the GUID and the username.
7. Since most of the time the base64 string will require padding, and because that padding for this implementation is 'a', most of the time the filename will be a.png, but not always (it depends on the length of the victim's username).
8. `/\/[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}t([A-Za-z0-9+\/]{4}){1,}\/[A-Za-z0-9+\/]\.png/` will match a base64 encoded string with 5 regularly spaces colons, a dash, and then some multiple of four base64 characters, followed by a slash, another base64 character, and ".png". This doesn't however, make sure that the character filename matches the last character before the slash.

## Lab 14-2
### Basic Static Analysis
- **strings**: What looks like a base64 alphabet, but shifted by some amount (starting with 'W'), "http://127.0.0.1/tenfour.html", "cmd.exe".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `InternetOpenA` and other functions from _WININET.DLL_, `ShellExecuteEx` and `SHChangeNotify` from _SHELL32.DLL_, `LoadStringA` from _USER32.DLL_, plus process and thread management functions from _KERNEL32.DLL_.
- **PEview**: Resource section
- **Resource Hacker** (Because of the presence of `LoadStringA` and the .rsrc section): A single resource named "String Table", whose value is the URL above.

### Basic Dynamic Analysis
With Regshot we don't see anything, but procmon is interesting. We see it spawn `cmd.exe` to delete the binary itself. We also see some connections made to a web server on the local machine (presumably the URL above).

We can use Python's `SimpleHTTPServer` to verify that the malware is making requests to our local machine, but they look benign... Only GET requests for _tenfour.html_. By writing our own little script we can dump the request headers.

```python
import BaseHTTPServer

HOST_NAME = "127.0.0.1"
PORT = 80

class HeaderDumpHandler(BaseHTTPServer.BaseHTTPRequestHandler):
    def do_GET(self):
        print self.headers
        self.send_response(200)

server = BaseHTTPServer.HTTPServer((HOST_NAME, PORT), HeaderDumpHandler)
try:
    server.serve_forever()
except KeyboardInterrupt:
    pass
server.server_close()
```

This yields more interesting information:

```bash
C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis Labs\
BinaryCollection\Chapter_14L>c:\Python27\python.exe header_dump.py
User-Agent: (!<e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqxUE
73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A6t/C
pVl963p9qDLCLViE2XlBqipB65SDciC4c3H8r1N8qaQdlpHBcDHC+4Go6tHBcLnA7hGebaICpVYA6tHC
/LZBqVQ96i0A6xS7liM87X0973Fhe1hkG==
Host: 127.0.0.1
Cache-Control: no-cache
```

We can try to decode this (it's obviously base64) but it looks like binary data. It could be some custom format, but what's more likely is that it was encoded using the modified base64 alphabet we noticed when we ran `strings` on the binary.

Using another simple script we can decode it:

```python
import string
import base64

STANDARD_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
CUSTOM_ALPHABET = 'WXYZlabcd3fghijko12e456789ABCDEFGHIJKL+/MNOPQRSTUVmn0pqrstuvwxyz'
DECODE_TRANS = string.maketrans(CUSTOM_ALPHABET, STANDARD_ALPHABET)

def decode(input):
    return base64.b64decode(input.translate(DECODE_TRANS))

print decode('e6LJC+xnBq90daDNB+1TDrhG6aWG6p9LC/iNBqsGi2sVgJdqhZXDZoMMomKGoqxUE73N9qH0dZltjZ4RhJWUh2XiA6imBriT9/oGoqxmCYsiYG0fonNC1bxJD6pLB/1ndbaS9YXe9710A6t/CpVl963p9qDLCLViE2XlBqipB65SDciC4c3H8r1N8qaQdlpHBcDHC+4Go6tHBcLnA7hGebaICpVYA6tHC/LZBqVQ96i0A6xS7liM87X0973Fhe1hkG==')
```

Which spits out:

```bash
Microsoft Windows XP [Version 5.1.2600] 
(C) Copyright 1985-2001 Microsoft Corp. 
 
C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis 
Labs\BinaryCollection\Chapter_14L> 
```

We also see requests with the User-Agent set to "Internet-Surf", which could be another network fingerprint. It looks like the application acts as a reverse shell that communicates over HTTP, hiding the output in the 'User-Agent' field of the head, encoded in base64 with a custom alphabet.

### Advanced Dynamic Analysis
Popping the binary into IDA as always, I see that there aren't many functions. The binary is actually only 7KB, which should make this easy. Quickly skimming the calls in `WinMain` we see calls to create a pipe, create a process, duplicate a handle, and spawn `cmd`. This is likely setting up a pipe so that the malware can write into and read from the shell prompt. Two threads are created, and then the function cleans up, calling `sub_401880`. `sub_401880` is simple and not worth too much time: It tries to delete itself, and we saw how using procmon in our dynamic analysis.

The first thread calls `PeekNamedPipe`, `ReadFile` and that's it. It probably exists only to read the shell. The buffer that contains the data written is passed to `sub_401000`, where we see mentions of the custom base64 alphabet, so this function probably encodes it. IDA doesn't correctly decode `loc_401750`, but we can turn it into a function using `P`. In this function we see the "(!<" string we saw prepending our base64 data, and then we see calls to `InternetOpen` and `InternetOpenURL`, so that's probably exactly what this does.

The second thread calls `sub_401800` which makes more internet calls -- presumably to get commands to send to the shell. It then processes this data, writing it to the pipe, but checking also for the word 'exit'. It doesn't look like it needs to decode anything, so it looks like the attacker's client just sends the commands in plain text.

### Network Signatures

The easiest way to determine that this particular piece of malware is running is by the URL that it requests, but because it is pulled from the .rsrc section, it is very likely that other customized version target other IPs and paths. The "Internet Surf" User-Agent is a good one, as well as any request with a User-Agent that starts with "(!<". We could also used a regex to look for base64 encoded user agents.

### Questions
1. Using direct addresses gets around issues like depending on DNS (which we can spoof with _fakedns.py_), but also is less flexible, as the malware could be useless if we ever lose that IP address.
2. This malware uses the libraries from WININET.DLL. These offer less fine grained control than lowere level libraries, but they offer the convenience of forming request headers correctly for you. This also allows you to avoid having strings such as "User-Agent" in the binary itself.
3. The URL that the malware reaches out two is found in the .rsrc section of the binary. If the IP address changes, the attacker can replace the resource without recompiling the binary, which could make customization easier.
4. This malware hides the information it wants to share with the attacker in the 'User-Agent' field of HTTP GET requests, encoded using a custom base64 alphabet.
5. The `cmd` prompt.
6. HTTP doesn't hold connections open, so it isn't a great way to get instant feed back in a way you might want for something like running commands on a shell. A thread must stay alive, continually making new connections to the server to make GET requests just to see if the server has anything it wants to do.
7. It is base64, but uses a custom alphabet. You can decode it simply by mapping each character in the base64 back to it's proper character before decoding.
8. The thread that makes GET requests with the "Internet Surf" User-Agent looks for the word "exit" and quits if it sees it, bringing down the other threads in turn.
9. This malware is a simple backdoor that tries to provide the attacker with a remote shell. Once the attacker is finished with the backdoor, the backdoor tries to delete itself.
