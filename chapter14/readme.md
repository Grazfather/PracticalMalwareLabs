## Lab 14-1
### Basic Static Analysis
- **strings**: The standard base64 alphabet, "http://www.practicalmalwareanalysis.com/%s/%c.png", "%s-%s", "%c%c:%c%c:%c%c:%c%c:%c%c:%c%c".
- **PEiD**: Microsoft Visual C++ 6.0., plus KANAL detected a BASE64 table at 0x50C0.
- **Dependency Walker**: 'URLDownloadToCacheFileA' from URLMON.DLL, 'GetCurrentHwProfileA' and 'GetUserNameA' from ADVAPI32.DLL, and a bunch from KERNEL32.DLL, including 'CreateProcessA'.
- **PEview**: Normal section names and headers.

### Basic Dynamic Analysis
Using fakedns.py and netcat to listen on port 80 I see that the malware makes a GET request to a resource at "/ODA6NmQ6NjE6NzI6Njk6NmYtRGVidWdnZXIa/a.png", which matches the string found previous. Base64 decoding this string "80:6d:61:72:69:6f-Debugger", which is something that looks like a MAC address (not the mac address of my VM's NIC, though, determined by running `getmac /v`) and my username. The first part of this string looks like it was formatted using the format string found above.

### Advanced Dynamic/Static Analysis
Looking at the binary in IDA I can see immediately where the requested string comes from: 'GetCurrentHwProfileA' is called and 12 bytes are picked out of the generated structure, starting at offset 0x19. According to MSDN these bytes correspond to the last 12 bytes of the system's GUID. Next there is a call to 'GetUserNameA' and the result there is combined with the partial GUID. This composed string is passed to sub_4010BB, which I quickly figured was the base64-encoding function by looking at it in OllyDBG, and this base64-encoded string is passed to sub_4011A3. This function gets the last byte of the base64 string, the base64 string, and combines it into the full request (This is why the request was a.png -- To match the a at the end of the base64 string).

This URL is finally used with 'URLDownloadToCacheFileA', which saves the response to a file. Because we aren't actually connecting to the server, we must infer what it is doing from here on out. This is rather easily done, since it is calling 'CreateProcessA', and passing in the filename received from the server as the executable.

### Questions
1. 'URLDownloadToCache' is used, which simplifies looking up the hostname, building the HTTP header, and saving the output. This interface also uses Windows-generated traffic, so the User-Agent and such looks legitimate.
2. The last 12 digits of the victim computer's GUID and the username of the user that executed the malware.
3. To fingerprint which machine is responsible for which traffic. The remote server could provide a special binary for each request and map that fingerprint to a GUID.
4. This malware uses standard base64 alphabet. (Looking at the solution, it appears it uses 'a' as padding instead of '='. The decoder I used did not complain about the single byte of padding so I did not notice).
5. This malware calls back to a remote server with some information about the victim and then executes the binary that the server responds with.
6. Because we know the GUID is 12 characters plus five colons, and there is presumably a limit to filename length, we can constrain the length of the directory in the request, and of course constrain the available characters to those in the standard base64 alphabet, and constrain the filename of the png to the last character of the directory. Because the colons are equally spaced three characters they show up as the same character consistently in the encoded string ('6'), so we can check for five sixes at regularly spaces intervals (every three characters make four characters in base64). The same can be done with the dash between the GUID and the username.
7. Since most of the time the base64 string will require padding, and because that padding for this implementation is 'a', most of the time the filename will be a.png, but not always (it depends on the length of the victim's username).
8. /\/[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}6[A-Za-z0-9+\/]{3}t([A-Za-z0-9+\/]{4}){1,}\/[A-Za-z0-9+\/]\.png/ will match a base64 encoded string with 5 regularly spaces colons, a dash, and then some multiple of four base64 characters, followed by a slash, another base64 character, and ".png". This doesn't however, make sure that the character filename matches the last character before the slash.
