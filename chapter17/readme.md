## Lab 17-1

This lab is the same as Lab 7-1, but with anti-VMWare techniques. Because I don't use VMWare, this is unlikely to cause much issue, but will try to detect and evade them anyway.

### Basic Static Analysis
All rudimentary checks yield the same results as in Lab 7-1, which means there are no apparent 'VMWare' strings.

### Basic Dynamic Analysis
No HTTP requests were made and no service was installed, so VirtualBox is probably being stopped, even if the malware's target was VMWare.

### Advanced Static Analysis
Opening in IDA and using the search feature, I searched for the use of those instructions mentioned in the chapter (and in the IDAPython script). `sidt` is used at 0x4011B5, `sldt` is used at 0x401121, and `str` is used at 0x401204.

The result of `sidt` is stored on the stack, and then the DWORD starting two bytes later is copied into another local. This local is then shifted to the right by 24 bits and its value is compared to 0xFF. If this check fails, sub_401000 is called, which attemps to delete the malware. This check is known as the "Red Pill". `sidt` writes 6 bytes, so getting the DWORD at +2 just gets the last four bytes, and shifting by 24 gets the last byte of that. The check against 0xFF is to check against the VMWare signature for where the IDTR resides.

`sldt` is called in sub_401100, but first the value 0xDDCCBBA is written to the target of the instruction. The result is returned to `_main`and its value is compared to 0xDDCC0000, and if not equal, the malware returns. This check is known as the "No Pill". In my case the check passes.

The result of `str` has two of its result bytes checked separately, to 0x00 and 0x40 and if both fail, then the malware calls sub_401000 to delete itself as in the first case. In my case the value was 0x0028.

When we run this in a debugger we can set breakpoints at these locations and see how their result affects the behaviour of the malware.

### Advanced Dynamic Analysis
Running the malware in a debugger and setting breakpoints on the two instances of the anti-vim instructions, we see that VirtualBox apparently has no problem fooling the malware.

### Questions
1. This malware uses some special x86 instructions to try to detect if it is running in a VM.
2. Although I don't have IDA Pro on this computer, I manually searched for these instructions and found `sidt`, `sldt`, and `str` instructions used, all with a check on their value followed by some kind of termination.
3. Each check has slightly different behaviour when it fails.
  1. If the `sidt` check fails, the malware attempts to delete the binary.
  2. The `sldt` check will just quit, but isn't performed until after the "Malservice" service is created.
  3. The `str` check is like the `sidt` check in that it attempts to delete the malware binary.
4. Since I am running VirtualBox, none of these checks actually work.
5. Mentioned in analysis, the tests are simply against different values. In the first case the check is against a VMWare signature, and in the others perhaps simply the way that VirtualBox runs doesn't affect the LDT or TSS in the same way that VMWare does.
6. The jumps to the failure code can just be patched to either reverse their condition or make them NOPs or unconditional jumps.

## Lab 17-2

### Basic Static Analysis
- **strings**: A bunch of logging messages, "conime.exe", mentions of injecting and uninjecting, "[This is RDO]newsnews.practicalmalwareanalysis.com" (and other "[This is \_]" strings), as well as HTTP headers some file names as well as device names. This malware does everything.
- **PEiD**: Microsoft Visual C++ 6.0 DLL [Overlay].
- **Dependency Walker**:
  - Exports: `InstallRT`, `InstallSA`, `InstallSB`, `PSLIST`, `ServiceMain`, `StartEXS`, `UninstallRT`, `UninstallSA`, `UninstallSB`, and `DllEntryPoint`.
  - Imports: _Many_, from _GDI.DLL_, _PSAPI.DLL_, _WS2_32.DLL_, _IPHLPAPI.DLL_, _KERNEL32.DLL_, _USER32.LL_, _ADVAPI32.DLL_, _OLE32.DLL_, _OLEAUT32.DLL_, _MSVFW32.LL_, _WINMM.DLL_, and _MSVCRT.DLL_. Along with this malware's large size (132KB) that suggests many features.
- **PEview**: Normal sections, with the addition of a "xdoors_d" section, as well as a _.rsrc_ section.
- **Resource Hacker**: A single resource "Version Info" which contains file information, purporting to be a "File Encryption Utility" made by Microsoft.

### Advanced Static Analysis
Because this is a DLL, instead of a single entry point (`main`), we have a few, so I will attack this malware by guessing the functionality, finding the appropriate imports, and then tracing where they are referenced from.

With all the mentions of services in the imports, it's clear that this malware is installed as a service. Looking up references to `OpenSCManagerA`, or other service-related imports leads us to `sub_1000C183`, which creates and starts a service, and is eventually called from `DllEntryPoint`.

Next, looking for mentions of the bat files or `del` commands leads us to `sub_10005567`, which clearly is used to remove the binary itself. It is called from each of the install functions.

#### Anti-VM
`InstallRT`, `InstallSA`, and `InstallSB` all have very similar behaviour: They call `sub_10006119` and `sub_10006196` and branch to a failure ("Found Virtual Machine,Install Cancel." [sic]). In the failure branch `sub_10003592` is called twice, and then `sub_10005567` which we saw is used to clean up the malware's tracks. Each method has their own function they call do to the actual install: `sub_1000D3D0`, `sub_1000D920`, and `sub_1000DF22`, respectively.

Using the method from Lab 17-1, we will attempt to see how the malware is detecting a VM. Of all of the instructions searched, only `in` was found, and sure enough, is was in `sub_10006196`. Before this instruction, 0x564D5868 is moved into eax, but displaying it as ASCII (`R`) shows that it is the same as "VMXh", which we know is the magic number VMWare uses in its I/O port for communicating with the host. Since I am running VirtualBox, this particular check shouldn't be any trouble, but the `in` instruction could be `nop`ed out to get around this.

#### Installation
The main "RT" function appears to copy the malware itself to the system directory, and then (in `sub_1000D10D`) attempts to inject itself into a process with the name specified, or "iexplore.exe" if not provided.

The "SA" function installs a service named "Irmon" and writes it to the registry.

The "SB" function is the most advanced. It replaces "ntmssvc.dll" with the malware, which will infect `svchost`, installs a service called "NtmsSvc", and also tries to inject itself into a running "svchost.exe" process.

#### Functionality
`PSLIST` seems to be a simple function. It, through a helper at `sub_100065618`, calls `CreateToolhelp32Snapshot` to iterate over all of the processes currently running on the victim machine and writes the results out to a file called "xinstall.dll". This file seems to be where all logging writes to, and this malware does a lot of writing. By following log strings around you can quickly get an idea of the functionality and how everything fits together.

The HTTP headers are used in `sub_10002CCE`, which looks somewhat complicated, and is called from a deep nest of so far unidentified functions.

`ServiceMain` calls `RegisterServiceCtrlHandlerA`, registering to the service named in the args the function that ida called `HandlerProc`. Based on the result of this call, the function either returns, or changes the service status (through `sub_1000C51C`), reads the value from the registry key "SOFTWARE\Microsoft\Windows\CurrentVersion" in `sub_1000569D` and then spawns a thread starting at `sub_1000CC06`

`sub_100C251` seems to be a reverse shell. It connects to a remote host and dispatch to one of eleven different service-related commands.

`sub_100042D8` is used to update the malware itself.

`sub_1000FF58` is another dispatch function, it connects to the master and takes a short command, and then calls the appropriate function which sends the requested data over the socket. These commands inclued "uptime" "language", and "idle".

### Dynamic Analysis
Using `rundll32` to run the malware, I ran it three times using the different install commands. The provided log file was very helpful and pretty much showed exactly how the installs worked. Using Process Explorer I also found an svchost process that had a copy of the malware loaded. Using `sc` I confirmed that the malicious services were indeed installed, but it appears that bothe were in state _STOPPED_.

### Questions
1. Exports are `InstallRT`, `InstallSA`, `InstallSB`, `PSLIST`, `ServiceMain`, `StartEXS`, `UninstallRT`, `UninstallSA`, `UninstallSB`, and `DllEntryPoint`.
2. On failure the malware attempts to delete itself.
3. _xinstall.log_ is created to hold anything the malware logs, as well as a _vmselfdel.bat_ which is used to remove the malware binary itself when a VM is detected.
4. The malware checks the I/O communication port to see if the VMWare magic number is reflected back when communication is established using the `in` instruction.
5. Replacing the `in` instruction with a `nop` would be an easy way to get around this check, since ebx is written by the instruction and the test afterwards will fail (The flag will be zero).
6. The same technique can be used, but the patch must be saved to the binary file.
7. 
  * `InstallRT` works by injecting the DLL into the provided process name, or "iexplore.exe" if not provided.
  * `InstallSA` works by installing a service with the provided name, or "Irmon".
  * `InstallSB` works by copy the malware over "ntmssvc.dll" in the system dir, installs a service that points to it, and also attempts to inject itself into a svchost process.

## Lab 17-3
### Basic Static Analysis
- **strings**: A whole bunch of 'A's, which suggests that sections are encrypted with a simple xor key of 0x41 (the strings of 'A's should likely be zeroes. Other than that, there are few of interest: "vmware", "c:\windows\system32\user32.dll", "\svchost", and "SYSTEM\CurrentControlSet\Control\DeviceClasses".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Registry reading-related imports from _ADVAPI32.DLL_, low level imports from _MSVCRT.DLL_, plus many imports from _KERNEL32.DLL_ including `LoadLibraryA`, `VirtualAlloc`, `VirtualFree`, `WriteProcessMemory`, `ReadProcessMemory`, `ResumeThread`, `CreateProcessA`, `CreateToolhelp32Snapshot`, `CreateRemoteThread`, and `FindResourceA`, which suggests something stored in the resource section and DLL injection.
- **PEview**: Normal sections, as well as a _.rsrc_ section.
- **Resource Hacker**: A single resource "LOCALIZATION" which contains what looks like an encrypted binary. XORing the first three bytes with 0x41 indeed yields the PE magic number "MZ\x90". Probably the DLL that will be injected into a process.

### Basic Dynamic Analysis
Running with Process Monitor and Regshot yields nothing interesting. It looks like this malware is actually detecting my VirtualBox VM and refusing to run, which is interesting, because so far nothing we have seen worked against VirtualBox.

### Advanced Analysis
Running the binary in Olly and walking through, we see that it ends rather quickly. It appears to be based on the value returned from `sub_401670`.

Popping the binary into IDA and searching for occurrences of the commont anti-VM instructions, `in` was found in `sub_401A80`, indeed with the 'VMXh' and 'VX' values. Looking at XREFs we see that it's called immediately in main. We can get around this by replacing the `in` instruction with a simple `nop`.

Looking for XREFs to the "vmware" string we see it's referenced in `sub_4011C0`, which is called from `_main`. It is passed the registry key "SYSTEM\CurrentControlSet\Control\DeviceClasses", reads from it using `RegOpenKeyExA`, `RedQueryInfoKeyA`, and `RegEnumKeyEx`, lower cases it in `sub_401060`, and then sees if that string contains the string "vmware" in `sub_4010B0`. After this check, the function is called recursively, until all sub keys are checked to make sure they don't contain the word "vmware". This second check is also passed with VirtualBox, but could be circumvented by patching out the call to `sub_4010B0` at 0x4012E3 with something that sets EAX to 0 like  `xor eax, eax`.

Next `LoadLibraryA` and `GetProcAddress` are called to get the address of `GetAdaptersInfo` from _Iphlpapi.dll_. The address to this function is stored in global `dword_403114`. Checking XREFs to that global, we see it's called in `sub_401670` at two different points.

Before `sub_401670` is called, `GetModuleHandleA` is called with a NULL argument, fetching a handle to the binary module itself. This handle, along with the pointer to a 0x400 byte stack buffer and the tsing "\svchost" is passed to `sub_401940`. In this function the system directory is simply copied to the buffer and "\svchost" is appended to the end.

Finally, we arrive at the call to `sub_401670`. It is provided a handle to the binary module only. This function is the most complicated so far. It begins by writing seemingly random bytes, one-by-one, to a stack buffer, and then calling the stored `GetAdaptersInfo`. If the return value doesn't match 0x6F, then the function returns 0. In fact, most paths end up returning 0, and we go back to where it's called from main, we see that a 0 value results in `_main` returning.

Looking on MSDN for `GetAdaptersInfo`, we see that the function writes is intended to be called twice: The first time it's called it returns the size required to fit the adapter information. 0x6F corresponds to _ERROR_BUFFER_OVERFLOW_, which is actually expected. The size of the buffer required is written to the provided buffer. This size is then used to allocate a buffer, and then this buffer and its size is passed to a second call to `GetAdaptersInfo`. The buffer is then iterated over, checking each adapter for certain values. These checks appear to be to compare the adapter to one expected in a VM (probably by the MAC address). Quickly verifying in Olly confirms that this is where my VirtualBox VMs fails.

If all of these checks pass, the resource is loaded, and its size, address, and 0x41 value are passed to `sub_401340`. Since 0x41 is our suspected XOR key, we can easily verify that this function 'decrypts' the embedded DLL. Because this decryption happens in the same function that checks the adapters, we cannot simply avoid this function. I found the easiest way to pass this check is to patch the `jz short loc_40184A` with an unconditional `jmp` to the same address.

With these checks done, and now a decrypted ELF in a buffer in memory, the `_main` function continues on to `sub_401400`, providing the path to _svchost.exe_ and the DLL. There is yet _another_ check here: `sub_401130` is passed a seemingly random value and 6 as args. It iterates over all running processes, using `sub_401000` to determine if it's a bad process and comparing its return value with the passed in '6'. Writing a process name "vmware" over a legit process seems to cause the function to fail, so we can conclude that this function does vmware checks based on process name (though I haven't checked if it looks for other words). We can circumvent this check by `nop`-ing the call, so EAX remains 0 and the check passes.

_Finally_ we see normal malware behaviour, which involves opening svchost to inject the decrypted binary. This behaviour is the same that we saw in lab 12-2.

### Questions
1. The malware simply sleeps for a second and then exits.
2. By passing the three checks, by patching out the `in` instruction with a `nop`, skipping over the call to `sub_4010B0` with a `xor eax, eax` at 0x4012E3, changing the `jz short loc_40184A` with an unconditional jump at 0x401841, and replacing the `je` with a `jmp` at 0x401467 we can get past all of the anti-VM stuff and the malware will read and decrypt a keylogger out of its resource section and inject it into a svchost process.
3. This malware uses four different anti VM: io using `in`, looks for "vmware" in the registry, checks the mac addresses of the adapters, and checks the process list for certain process names.
4. Besides using a different VM player (which only fails in one case) you can avoid these checks by uninstalling anything that would add a 'vmware' process, changing your adapters from the default MAC addresses, disable VMware tools, which communicates and responds over the checked io port.
5. 
   1. `nop` out the `in` instruction at 0x401AC8, or replace the `test eax, eax` with `xor eax, eax` at 0x40199F.
   2. `nop` out the `call` at 0x4019BB, or replace the `test eax, eax` with `xor eax, eax` at 0x4019BE.
   3. Change the `jz` to a `jmp` at 0x401841.
   4. `nop` out the `call` at 0x40145D, or replace the `test eax, eax` with `xor eax, eax` at 0x401465.
