## Lab 17-1

This lab is the same as Lab 7-1, but with anti-VMWare techniques. Because I don't use VMWare, this is unlikely to cause much issue, but will try to detect and evade them anyway.

### Basic Static Analysis
All rudimentary checks yield the same results as in Lab 7-1, which means there are no apparent 'VMWare' strings.

### Basic Dynamic Analysis
No HTTP requests were made and no service was installed, so VirtualBox is probably being stopped, even if the malware's target was VMWare.

### Advanced Static Analysis
Opening in IDA and using the search feature, I searched for the use of those instructions mentioned in the chapter (and in the IDAPython script). `sidt` is used at 0x4011B5, `sldt` is used at 0x401121, and `str` is used at 0x401204.

The result of `sidt` is stored on the stack, and then the DWORD starting two bytes later is copied into another local. This local is then shifted to the right by 24 bits and its value is compared to 0xFF. If this check fails, sub_401000 is called, which attemps to delete the malware. This check is known as the "Red Pill". `sidt` writes 6 bytes, so getting the DWORD at +2 just gets the last four bytes, and shifting by 24 gets the last byte of that. The check against 0xFF is to check against the VMWare signature for where the IDTR resides.

`sldt` is called in sub_401100, but first the value 0xDDCCBBA is written to the target of the instruction. The result is returned to `_main`and its value is compared to 0xDDCC0000, and if not equal, the malware returns. This check is known as the "No Pill". In my case the check passes.

The result of `str` has two of its result bytes checked separately, to 0x00 and 0x40 and if both fail, then the malware calls sub_401000 to delete itself as in the first case. In my case the value was 0x0028.

When we run this in a debugger we can set breakpoints at these locations and see how their result affects the behaviour of the malware.

### Advanced Dynamic Analysis
Running the malware in a debugger and setting breakpoints on the two instances of the anti-vim instructions, we see that VirtualBox apparently has no problem fooling the malware.

### Questions
1. This malware uses some special x86 instructions to try to detect if it is running in a VM.
2. Although I don't have IDA Pro on this computer, I manually searched for these instructions and found `sidt`, `sldt`, and `str` instructions used, all with a check on their value followed by some kind of termination.
3. Each check has slightly different behaviour when it fails.
  1. If the `sidt` check fails, the malware attempts to delete the binary.
  2. The `sldt` check will just quit, but isn't performed until after the "Malservice" service is created.
  3. The `str` check is like the `sidt` check in that it attempts to delete the malware binary.
4. Since I am running VirtualBox, none of these checks actually work.
5. Mentioned in analysis, the tests are simply against different values. In the first case the check is against a VMWare signature, and in the others perhaps simply the way that VirtualBox runs doesn't affect the LDT or TSS in the same way that VMWare does.
6. The jumps to the failure code can just be patched to either reverse their condition or make them NOPs or unconditional jumps.
