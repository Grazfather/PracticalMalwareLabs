## Lab 17-1

This lab is the same as Lab 7-1, but with anti-VMWare techniques. Because I don't use VMWare, this is unlikely to cause much issue, but will try to detect and evade them anyway.

### Basic Static Analysis
All rudimentary checks yield the same results as in Lab 7-1, which means there are no apparent 'VMWare' strings.

### Basic Dynamic Analysis
No HTTP requests were made and no service was installed, so VirtualBox is probably being stopped, even if the malware's target was VMWare.

### Advanced Static Analysis
Opening in IDA and using the search feature, I searched for the use of those instructions mentioned in the chapter (and in the IDAPython script). `sidt` is used at 0x4011B5, `sldt` is used at 0x401121, and `str` is used at 0x401204.

The result of `sidt` is stored on the stack, and then the DWORD starting two bytes later is copied into another local. This local is then shifted to the right by 24 bits and its value is compared to 0xFF. If this check fails, sub_401000 is called, which attemps to delete the malware. This check is known as the "Red Pill". `sidt` writes 6 bytes, so getting the DWORD at +2 just gets the last four bytes, and shifting by 24 gets the last byte of that. The check against 0xFF is to check against the VMWare signature for where the IDTR resides.

`sldt` is called in sub_401100, but first the value 0xDDCCBBA is written to the target of the instruction. The result is returned to `_main`and its value is compared to 0xDDCC0000, and if not equal, the malware returns. This check is known as the "No Pill". In my case the check passes.

The result of `str` has two of its result bytes checked separately, to 0x00 and 0x40 and if both fail, then the malware calls sub_401000 to delete itself as in the first case. In my case the value was 0x0028.

When we run this in a debugger we can set breakpoints at these locations and see how their result affects the behaviour of the malware.

### Advanced Dynamic Analysis
Running the malware in a debugger and setting breakpoints on the two instances of the anti-vim instructions, we see that VirtualBox apparently has no problem fooling the malware.

### Questions
1. This malware uses some special x86 instructions to try to detect if it is running in a VM.
2. Although I don't have IDA Pro on this computer, I manually searched for these instructions and found `sidt`, `sldt`, and `str` instructions used, all with a check on their value followed by some kind of termination.
3. Each check has slightly different behaviour when it fails.
  1. If the `sidt` check fails, the malware attempts to delete the binary.
  2. The `sldt` check will just quit, but isn't performed until after the "Malservice" service is created.
  3. The `str` check is like the `sidt` check in that it attempts to delete the malware binary.
4. Since I am running VirtualBox, none of these checks actually work.
5. Mentioned in analysis, the tests are simply against different values. In the first case the check is against a VMWare signature, and in the others perhaps simply the way that VirtualBox runs doesn't affect the LDT or TSS in the same way that VMWare does.
6. The jumps to the failure code can just be patched to either reverse their condition or make them NOPs or unconditional jumps.

## Lab 17-2

### Basic Static Analysis
- **strings**: A bunch of logging messages, "conime.exe", mentions of injecting aind uninjecting, "[This is RDO]newsnews.practicalmalwareanalysis.com" (and other "[This is \_]" strings), as well as HTTP headers some file names as well as device names. This malware does everything.
- **PEiD**: Microsoft Visual C++ 6.0 DLL [Overlay].
- **Dependency Walker**:
  - Exports: `InstallRT`, `InstallSA`, `InstallSB`, `PSLIST`, `ServiceMain`, `StartEXS`, `UninstallRT`, `UninstallSA`, `UninstallSB`, and `DllEntryPoint`.
  - Imports: _Many_, from _GDI.DLL_, _PSAPI.DLL_, _WS2_32.DLL_, _IPHLPAPI.DLL_, _KERNEL32.DLL_, _USER32.LL_, _ADVAPI32.DLL_, _OLE32.DLL_, _OLEAUT32.DLL_, _MSVFW32.LL_, _WINMM.DLL_, and _MSVCRT.DLL_. Along with this malware's large size (132KB) that suggests many features.
- **PEview**: Normal sections, with the addition of a "xdoors_d" section, as well as a _.rsrc_ section.
- **Resource Hacker**: A single resource "Version Info" which contains file information, purporting to be a "File Encryption Utility" make by Microsoft.

### Advanced Static Analysis
Because this is a DLL, instead of a single entry point (`main`), we have a few, so I will attack this malware by guessing the functionality, finding the appropriate imports, and then tracing where they are referenced from.

With all the mentions of services in the imports, it's clear that this malware is installed as a service. Looking up references to `OpenSCManagerA`, or other service-related imports leads us to `sub_1000C183`, which creates and starts a service, and is eventually called from `DllEntryPoint`.

Next, looking for mentions of the bat files or `del` commands leads us to `sub_10005567`, which clearly is used to remove the binary itself. It is called from each of the install functions.

`InstallRT`, `InstallSA`, and `InstallSB` all have very similar behaviour: They call `sub_10006119` and `sub_10006196` and branch to a failure ("Found Virtual Machine,Install Cancel." [sic]). In the failure branch `sub_10003592` is called twice, and then `sub_10005567` which we saw is used to clean up the malware's tracks. Each method has their own function they call do to the actual install: `sub_1000D3D0`, `sub_1000D920`, and `sub_1000DF22`, respectively.

Using the method from Lab 17-1, we will attempt to see how the malware is detecting a VM. Of all of the instructions searched, only `in` was found, and sure enough, is was in `sub_10006196`. Before this instruction, 0x564D5868 is moved into eax, but displaying it as ASCII (`R`) shows that it is the same as "VMXh", which we know is the magic number VMWare uses in its I/O port for communicating with the host. Since I am running VirtualBox, this particular check shouldn't be any trouble, but the `in` instruction could be `nop`ed out to get around this.

The main "RT" function appears to copy the malware itself to the system directory, and then (in `sub_1000D10D`) attempts to inject itself into a process with the name specified, or "iexplore.exe" if not provided.

The "SA" function installs a service named "Irmon" and writes it to the registry.

The "SB" function is the most advanced. It replaces "ntmssvc.dll" with the malware, which will infect `svchost`, installs a service called "NtmsSvc", and also tries to inject itself into a running "svchost.exe" process.

`PSLIST` seems to be a simple function. It, through a helper at `sub_100065618`, calls `CreateToolhelp32Snapshot` to iterate over all of the processes currently running on the victim machine and write the results out to a file called "xinstall.dll".

The HTTP headers are used in `sub_10002CCE`, which looks somewhat complicated, and is called from a deep nest of so far unidentified functions.

`ServiceMain` calls `RegisterServiceCtrlHandlerA`, registering to the service named in the args the function that ida called `HandlerProc`. Based on the result of this call, the function either returns, or changes the service status (through `sub_1000C51C`), reads the value from the registry key "SOFTWARE\Microsoft\Windows\CurrentVersion" in `sub_1000569D` and then spawns a thread starting at `sub_1000CC06`

### Dynamic Analysis
Using `rundll32` to run the malware, I ran it three times using the different install commands. The provided log file was very helpful and pretty much showed exactly how the installs worked. Using Process Explorer I also found an svchost process that had a copy of the malware loaded. Using `sc` I confirmed that the malicious services were indeed installed, but it appears that bothe were in state _STOPPED_.

### Questions
1. Exports are `InstallRT`, `InstallSA`, `InstallSB`, `PSLIST`, `ServiceMain`, `StartEXS`, `UninstallRT`, `UninstallSA`, `UninstallSB`, and `DllEntryPoint`.
2. On failure the malware attempts to delete itself.
3. _xinstall.log_ is created to hold anything the malware logs, as well as a _vmselfdel.bat_ which is used to remove the malware binary itself when a VM is detected.
4. The malware checks the I/O communication port to see if the VMWare magic number is reflected back when communication is established using the `in` instruction.
5. Replacing the `in` instruction with a `nop` would be an easy way to get around this check, since ebx is written by the instruction and the test afterwards will fail (The flag will be zero).
6. The same technique can be used, but the patch must be saved to the binary file.
7. 
  * `InstallRT` works by injecting the DLL into the provided process name, or "iexplore.exe" if not provided.
  * `InstallSA` works by installing a service with the provided name, or "Irmon".
  * `InstallSB` works by copy the malware over "ntmssvc.dll" in the system dir, installs a service that points to it, and also attempts to inject itself into a svchost process.
