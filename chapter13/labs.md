## Lab 13-1
### Basic Static Analysis
- **strings**: The standard base64 alphabet, "Mozilla/4.0", "http://%s/%s/", some prints regarding dialog boxes, and "%02x".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports from WININET.DLL to grab files from the internet, 'gethostname', 'WSAStartup', and 'WSACleanup' from WS2_32.DLL, and a handful from KERNEL32.DLL including 'WriteFile'.
- **PEview**: Normal section names and headers, but includes a .rsrc section.
- **Resource Hacker** (Because of the presence of 'FindResourceA' and the .rsrc section): A single resource named "RCData", which appears to be encrypted in some way.

### Basic Dynamic Analysis
Running the malware with procmon and regshot running we see it attempt to make outgoing connections to ip "192.0.78.25". Nothing interesting was written to the registry, and the process seems to stick around in a console window until I kill it explicitly.

### Advanced Dynamic/Static Analysis
Because these is presumably some decrypting going on and I don't want to have to dig through all the code manually I went ahead with dynamic analysis using OllyDBG. Loading it up (having to pass an access violation exception for some reason) I point breakpoints on a few points of interest. Notably where the string "http://%s/%s/" was used as well as 'InternetOpenUrlA'. I see that the URL requested was "http://www.practicalmalwareanalysis.com/cmVwYw==". Tracing back I see that the base64 alphabet is actually used to encode strings (which explains why we didn't see any base64 encoded strings in the binary: We _encode_ only. No base64 decoding). The domain name wasn't in the binary, so it's presumably encrypted, probably in the 'RCData' resource.

Looking back further we can see where the base64 encoded string came from. There's a call to 'gethostname' which returns "repc" ("reverse engineering pc" is probably what I meant when I set up the VM). sub_4010B1 is passed the hostname and the base64 encoding is copied to the provided buffer.

Tracing back where the hostname came from, we see that there is a loop immediately after a call to 'LoadResource'. Loading the binary in IDA and searching for 'xor's indeed shows many calls to xor, but most are xoring a register with itself (clearing it out) and only one is xoring with a constant. In sub_401190 we see the xor of eax with 0x3B and it is indeed in the same loop we saw in OllyDBG. Stepping through this loop we can see that the resource that was loaded earlier is simply encrypted with a single byte key (0x3B) XOR cipher.

Looking into the base64 encoding implementation, you can see a few references to the alphabet using KANAL with PEiD: There are references at 0x401013, 0x40103E, 0x40106E, and 0x401097. These locations are in sub_401000, whose only call is from sub_4010B1, which is called soon after the call to 'gethostname'. The function probably isn't worth looking into, but we can play with it by placing a breakpoint at 0x40122A and modifying the string that is passed to the encode function. While playing around the only thing I noticed of note is that it won't encode more than 12 characters.

Jumping back to the web request, we see that it simply checks the first byte of the response and returns 1 if it's 'o' and 0 otherwise. This malware doesn't seem to do anything other than advertise that it's running on a host by making a GET request to its C&C server with the (possibly truncated) base64 encoded hostname of the machine it's running on.

### Questions
1. The notable string addition is the hostname "www.practicalmalwareanalysis.com", which comes from the encrypted ciphertext found in the resource section.
2. The hostname was decrypted from the resource section with a simple XOR cipher.
3. The key is the single byte '0x3B' and the scheme is a simple XOR cipher.
4. FindCrypt2 didn't work with IDA, but KANAL found references to the base64 alphabet and helped identify the base64encode function.
5. base64 encoding is used to determine the path used in the 'InternetOpenUrlA' call.
6. sub_4010B1.
7. The function doesn't appear to encoding anything longer than 12 bytes.
8. Yes. sub_4010B1 is a standard base64 encoding function.
9. The malware doesn't appear to do anything more than send this specially-encoded request and wait for a response.

## Lab 13-2
### Basic Static Analysis
- **strings**: Nothing sticks outs other tahn than imports and "temp%08X".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports from GDI32.DLL, which are apparently for drawing shapes to the screen, "ReleaseDC", "GetDC", "GetDesktopWindow", and "GetSystemMetrics" from USER32.DLL, and a lot from KERNEL32.DLL.
- **PEview**: Normal section names and headers.

### Advanced Dynamic/Static Analysis
Because regshot does not show any interesting changes, which makes sense since we didn't see registry-writing imports and because procmon also doesn't show anything particularly interesting, we will just right into the debugger. Tracing through the first bit quickly we see that there is a loop that iterates every 10 seconds. In the called function there is a filename built and then saved to the current directory. The contents of the file looks like garbage, so we will look for an encoding/decoding function.

First using the KANAL PEiD plugin finds nothing, and I couldn't get idacrypt to work, so we will look for xor-decrypting patterns. Searching for all xor instructions used and ignoring register-register xors leaves only six occurrences. `xor edx, [ecx]`, in actually has a lot of occurrences of xor, including three of the six 'suspect' xors and a bunch of the 'non-suspect' xors. Both functions look interesting here.

Starting from the simpler one, we see that it makes no other calls. Tracing backwards it's also only referenced once. That referencing function happens to be referenced by the more complicated xor function, so we know they are both related. The middle function is also called by a block of code that IDA doesn't identify as a function, but that block of code seems legal _and_ there is one of the suspect xors shortly after. We can make IDA try to convert this to a function by scrolling up until the previous function ends and select 'create function' from the context menu. Tracing the more complicated xor function for XREFs we can follow a convenient path of single references back to main.

In the main 'work' function that is called in a loop we see three calls to other local functions: One has calls to the GDI32.DLL methods, one calls the big xor function, and the third is responsible for writing out the real file. Stepping through until the function that writes the file, we see that the filename is built from the string "temp%08X" and the return value from 'GetTickCount'. We also see that the size of the file and the contents of the file both correspond exactly to the arguments that were passed to sub_401000. Looking back where these arguments came from, we see that both are local pointers that are modified by the first function and then provided to the second: The first allocates a buffer, fills it with data, and the second encrypts it.

Instead of figuring out how it encrypts the data blob, let's figure out _what_ it's encrypting. Since we know it encrypts the buffer in place, and then saves that buffer, we can just NOP the call to the encrypt function and then open the resulting file. Since the function that builds the buffer has a bunch of calls to GDI32.DLL imports, we can assume it has to do with graphics, and since I didn't see any imports for special types, I assumed it saved as bmp. Sure enough, NOPing the call at 0x401880 and then adding a '.bmp' extension to the end of the file that is saved I can see a screen shot of my desktop. It appears that this malware simply takes screen shots every ten seconds and then encrypts and saves them to disk.

Since the question asked to decrypt an existing file (though I would rather just prevent the encryption in the first place), I wrote a python script for immunity which replaces the screenshot in memory with an encrypted copy from a previous run, so that the file is encrypted twice (which with this cipher effectively decrypts) and is saved unencrypted in place of the new screen shot. I implemented it as a PyCommand that takes the filename of the encrypted file as its only argument.

```python
import immlib

def main(args):
    imm = immlib.Debugger()
    imm.setBreakpoint(0x401880) # Before encrypt call
    imm.run()
    fn = "C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis Labs\BinaryCollection\Chapter_13L\{}".format(args[0])
    with open(fn, 'rb') as f:
        buf = f.read()
    regs = imm.getRegs()
    # Get the address of the buffer
    bufadr = imm.readLong(regs['ESP'])
    # Overwrite it with the encrypted file
    imm.writeMemory(bufadr, buf)
    imm.setBreakpoint(0x004018BD) # After the file is written
    imm.run()
```

### Questions
1. The malware creates a file named "temp<hex digits>" a couple times every minute. The contents looks like gibberish.
2. KANAL found nothing, but searching for XORs lead us to the two encrypt function.
3. 'WriteFile' since is it likely soon after the encoding is done.
4. The encoding function is in sub_40181F.
5. The source of the content is from the function sub_401070, which makes a lot of calls from GDI32.DLL. By skipping the encryption it was determine that this function takes a screen shot.
6. The algorithm seems rather complicated. We can see the content before it's encrypted, easily, but it's also possible to 'decrypt' by encrypting twice.
7. By replacing the buffer of the screenshot in memory with the contents of an encrypted file from a previous run, I can 'trick' the malware into decrypting a screen shot for me.

## Lab 13-3
### Basic Static Analysis
- **strings**: A non-standard base64 alphabet (starting with "C"), "ijklmnopqrstuvwx", "www.practicalmalwareanalysis.com", some error messages, some of which seem crypto-related.
- **PEiD**: Microsoft Visual C++ 6.0, as well as Rijndael S-box and S-inv at 0xC908 and 0xCA08, respectively. These are used for AES.
- **Dependency Walker**: Imports to make network connections from WS2_32.DLL, 'wsprintfA' from USER32.DLL, and a bunch from KERNEL32.DLL including those used to create or destroy processes, and threads.
- **PEview**: Normal section names and headers.
- **Resource Hacker** (Because of the presence of 'FindResourceA' and the .rsrc section): A single resource named "RCData", which appears to be encrypted in some way.

### Basic Dynamic Analysis
Running the malware spawns a console window that seems to stay alive. There aren't any interesting writes to the registry, as expected. Looking through procmon there isn't too much interesting going on, but we do see a connection to the ip "192.0.78.24" on port 8910. This IP, at the time of this writing, points to "www.practicalmalwareanalysis.com", which is expected. After the connection is disconnected a new thread is spawned.

Using _fakedns.py_ and creating a listener on port 8910 with netcat, the malware makes a connection to my listener. If I type in random text into netcat, I get a response that looks like gibberish. This appears is likely encrypted text.

### Advanced Static Analysis
First looking for encryption, I ran a search for all occurrences of 'xor'. Ignoring the ones used to zero-out a register, there are about sixty. Since they seem to be bunched up, it's likely that only a few functions are using them. Identifying these functions and then seeing where they are called from shows two big functions that call a handful of these encryption functions: sub_40352D, and a function that I had to create in IDA at 0x403745. It wasn't considered a function probably because IDA didn't find any cross references to it, but its graph looks _very_ similar to sub_40352D. One is these is likely an encryption function and the other decryption. Since we saw random data in netcat, we can probably assume that sub_40352D is the encrypt function, and that decrypt isn't used. On top of that, one of the xor functions, sub_401AC2, is passed the string "ijklmnopqrstuvwx"

Opening the malware in IDA we see the "ijklmnopqrstuvwx" string passed to sub_401AC2, which we believe is encryption-related. Since that string is 16 bytes long, which is a valid AES key length, I am guessing that it is a hard-coded key and that the complicated function is setting up a cipher. Looking at cross references for the s-box we saw using KANAL in PEiD, we indeed see that it's referenced a lot in that first called function. After this call a 'connect' call is made to www.practicalmalwareanalysis.com, and if the connection succeeded, then sub_4015B7 is called.

sub_4015B7 creates two anonymous pipes using 'CreatePipe', and then calls 'DuplicateHandle' thrice, with the _hSourceProcessHandle_ and _hTargetProcessHandle_ always the result of 'GetCurrentProcess'. The first call creates a copy of the first write end pipe, the second a copy of the first read end pipe, and the third a copy of the second pipe's write end. The original read end of the first pipe handle is closed using 'CloseHandle', as well as the write end of the second pipe. 'GetStdHandle' is called with an argument -10, which corresponds to _STD_INPUT_HANDLE_. After this, 'CreateProcessA' is called, with the command line simply "cmd.exe", but its _stdout/stderr_ pointing to the write end of the first pipe, and _stdin_ pointing to the read end of the second pipe. A boolean flag is set to true, and the handle to the process is saved in a global. Next, the two pipe handles used in the new process are closed as well as the copy of the handle to the write end of the first pipe. Once these are closed, a thread is created with the starting address sub_40147C, and it is passed the socket, the copy of the write end of the second pipe, and the handle to the cmd.exe process. A second thread is started, but this one's params are the copy of the handle of the read end of the first pipe, the socket, and the handle to the cmd.exe process, and its starting address is sub_40132B.

If we follow where each end of each pipe ended up, we see that the first pipe is written into by the cmd.exe process's _stderr_ and _stdout_, and read from by the second thread. The second pipe is written into by the first thread, and read from by the cmd.exe process's _stdin_. This suggest that this malware takes input from the C&C server in one thread and sends the output back from the other thread, because we saw that the output was gibberish, we need to see what type of encoding or encryption is being used by each thread. Sure enough, the second thread is calling our AES encrypt function, and immediately writing that data to the socket. This explains the gibberish we saw in basic dynamic analysis: The output from cmd.exe is encrypted before sending it to the server.

Looking for references for the base64 alphabet, we see it is referenced in sub_40103F, which is only referenced in sub_401082, which is only referenced from the first thread. sub_401082 is called after reading from the socket and before writing to stdin in the cmd process, so it's clear that the malware expects commands to be base64 encoded using the same alphabet.

To test out all of this information, I created a simple command & control script in python. It simply listens on port 8910 for connections, and sends anything typed in so the malware, after base64 encoding it with the special alphabet. It gets the response and decrypts it using AES in CBC mode (lucky guess) with an IV of just 16 null bytes in a row. The code for this server is included as _Lab13-3CnC.py_.

### Questions
1. The random-looking data that is received by netcat doesn't appear in string at all. It appears generated at runtime.
2. Looking for XORs we can find AES encryption and decryption routines, though the decryption routine is never used.
3. Using KANAL we can find the RIJNDAEL s-boxes, which are used by AES and confirm our earlier findings.
4. Base64 decoding, using a custom alphabet, and AES encryption, using a hard-coded key.
5. For base64 the alphabet is "CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/" and for AES the key is "ijklmnopqrstuvwx".
6. They key is sufficient because the IV used is just 16 null bytes. We got lucky that the AES mode was CBC and that the keysize was 16 bytes, with a pretty obvious key.
7. This malware is a reverse shell backdoor with encryption. It spawns a cmd shell and connects to the remote server, and then spawns two threads. One thread takes base64-encoded commands and passes them (after decoding) to the cmd process through a pipe. The second thread reads the output from stdout/stderr from the cmd.exe process, encrypts the output with AES with the key "ijklmnopqrstuvwx", [MODE] and sends it to the server.
8. Code to decrypt responses and encode commands in _Lab13-3CnC.py_. Running it we can clearly see that the command sent over are executed on the infected machine and the output from the command is sent back encrypted.
