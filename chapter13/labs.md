## Lab 13-1
### Basic Static Analysis
- **strings**: The standard base64 alphabet, "Mozilla/4.0", "http://%s/%s/", some prints regarding dialog boxes, and "%02x".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports from WININET.DLL to grab files from the internet, 'gethostname', 'WSAStartup', and 'WSACleanup' from WS2_32.DLL, and a handful from KERNEL32.DLL including 'WriteFile'.
- **PEview**: Normal section names and headers, but includes a .rsrc section.
- **Resource Hacker** (Because of the presence of 'FindResourceA' and the .rsrc section): A single resource named "RCData", which appears to be encrypted in some way.

### Basic Dynamic Analysis
Running the malware with procmon and regshot running we see it attempt to make outgoing connections to ip "192.0.78.25". Nothing interesting was written to the registry, and the process seems to stick around in a console window until I kill it explicitly.

### Advanced Dynamic/Static Analysis
Because these is presumably some decrypting going on and I don't want to have to dig through all the code manually I went ahead with dynamic analysis using OllyDBG. Loading it up (having to pass an access violation exception for some reason) I point breakpoints on a few points of interest. Notably where the string "http://%s/%s/" was used as well as 'InternetOpenUrlA'. I see that the URL requested was "http://www.practicalmalwareanalysis.com/cmVwYw==". Tracing back I see that the base64 alphabet is actually used to encode strings (which explains why we didn't see any base64 encoded strings in the binary: We _encode_ only. No base64 decoding). The domain name wasn't in the binary, so it's presumably encrypted, probably in the 'RCData' resource.

Looking back further we can see where the base64 encoded string came from. There's a call to 'gethostname' which returns "repc" ("reverse engineering pc" is probably what I meant when I set up the VM). sub_4010B1 is passed the hostname and the base64 encoding is copied to the provided buffer.

Tracing back where the hostname came from, we see that there is a loop immediately after a call to 'LoadResource'. Loading the binary in IDA and searching for 'xor's indeed shows many calls to xor, but most are xoring a register with itself (clearing it out) and only one is xoring with a constant. In sub_401190 we see the xor of eax with 0x3B and it is indeed in the same loop we saw in OllyDBG. Stepping through this loop we can see that the resource that was loaded earlier is simply encrypted with a single byte key (0x3B) XOR cipher.

Looking into the base64 encoding implementation, you can see a few references to the alphabet using KANAL with PEiD: There are references at 0x401013, 0x40103E, 0x40106E, and 0x401097. These locations are in sub_401000, whose only call is from sub_4010B1, which is called soon after the call to 'gethostname'. The function probably isn't worth looking into, but we can play with it by placing a breakpoint at 0x40122A and modifying the string that is passed to the encode function. While playing around the only thing I noticed of note is that it won't encode more than 12 characters.

Jumping back to the web request, we see that it simply checks the first byte of the response and returns 1 if it's 'o' and 0 otherwise. This malware doesn't seem to do anything other than advertise that it's running on a host by making a GET request to its C&C server with the (possibly truncated) base64 encoded hostname of the machine it's running on.

### Questions
1. The notable string addition is the hostname "www.practicalmalwareanalysis.com", which comes from the encrypted ciphertext found in the resource section.
2. The hostname was decrypted from the resource section with a simple XOR cipher.
3. The key is the single byte '0x3B' and the scheme is a simple XOR cipher.
4. FindCrypt2 didn't work with IDA, but KANAL found references to the base64 alphabet and helped identify the base64encode function.
5. base64 encoding is used to determine the path used in the 'InternetOpenUrlA' call.
6. sub_4010B1.
7. The function doesn't appear to encoding anything longer than 12 bytes.
8. Yes. sub_4010B1 is a standard base64 encoding function.
9. The malware doesn't appear to do anything more than send this specially-encoded request and wait for a response.

## Lab 13-2
### Basic Static Analysis
- **strings**: Nothing sticks outs other tahn than imports and "temp%08X".
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports from GDI32.DLL, which are apparently for drawing shapes to the screen, "ReleaseDC", "GetDC", "GetDesktopWindow", and "GetSystemMetrics" from USER32.DLL, and a lot from KERNEL32.DLL.
- **PEview**: Normal section names and headers.

### Advanced Dynamic/Static Analysis
Because regshot does not show any interesting changes, which makes sense since we didn't see registry-writing imports and because procmon also doesn't show anything particularly interesting, we will just right into the debugger. Tracing through the first bit quickly we see that there is a loop that iterates every 10 seconds. In the called function there is a filename built and then saved to the current directory. The contents of the file looks like garbage, so we will look for an encoding/decoding function.

First using the KANAL PEiD plugin finds nothing, and I couldn't get idacrypt to work, so we will look for xor-decrypting patterns. Searching for all xor instructions used and ignoring register-register xors leaves only six occurrences. `xor edx, [ecx]`, in actually has a lot of occurrences of xor, including three of the six 'suspect' xors and a bunch of the 'non-suspect' xors. Both functions look interesting here.

Starting from the simpler one, we see that it makes no other calls. Tracing backwards it's also only referenced once. That referencing function happens to be referenced by the more complicated xor function, so we know they are both related. The middle function is also called by a block of code that IDA doesn't identify as a function, but that block of code seems legal _and_ there is one of the suspect xors shortly after. We can make IDA try to convert this to a function by scrolling up until the previous function ends and select 'create function' from the context menu. Tracing the more complicated xor function for XREFs we can follow a convenient path of single references back to main.

In the main 'work' function that is called in a loop we see three calls to other local functions: One has calls to the GDI32.DLL methods, one calls the big xor function, and the third is responsible for writing out the real file. Stepping through until the function that writes the file, we see that the filename is built from the string "temp%08X" and the return value from 'GetTickCount'. We also see that the size of the file and the contents of the file both correspond exactly to the arguments that were passed to sub_401000. Looking back where these arguments came from, we see that both are local pointers that are modified by the first function and then provided to the second: The first allocates a buffer, fills it with data, and the second encrypts it.

Instead of figuring out how it encrypts the data blob, let's figure out _what_ it's encrypting. Since we know it encrypts the buffer in place, and then saves that buffer, we can just NOP the call to the encrypt function and then open the resulting file. Since the function that builds the buffer has a bunch of calls to GDI32.DLL imports, we can assume it has to do with graphics, and since I didn't see any imports for special types, I assumed it saved as bmp. Sure enough, NOPing the call at 0x401880 and then adding a '.bmp' extension to the end of the file that is saved I can see a screen shot of my desktop. It appears that this malware simply takes screen shots every ten seconds and then encrypts and saves them to disk.

Since the question asked to decrypt an existing file (though I would rather just prevent the encryption in the first place), I wrote a python script for immunity which replaces the screenshot in memory with an encrypted copy from a previous run, so that the file is encrypted twice (which with this cipher effectively decrypts) and is saved unencrypted in place of the new screen shot. I implemented it as a PyCommand that takes the filename of the encrypted file as its only argument.

```python
import immlib

def main(args):
    imm = immlib.Debugger()
    imm.setBreakpoint(0x401880) # Before encrypt call
    imm.run()
    fn = "C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis Labs\BinaryCollection\Chapter_13L\{}".format(args[0])
    with open(fn, 'rb') as f:
        buf = f.read()
    regs = imm.getRegs()
    # Get the address of the buffer
    bufadr = imm.readLong(regs['ESP'])
    # Overwrite it with the encrypted file
    imm.writeMemory(bufadr, buf)
    imm.setBreakpoint(0x004018BD) # After the file is written
    imm.run()
```


### Questions
1. The malware creates a file named "temp<hex digits>" a couple times every minute. The contents looks like gibberish.
2. KANAL found nothing, but searching for XORs lead us to the two encrypt function.
3. 'WriteFile' since is it likely soon after the encoding is done.
4. The encoding function is in sub_40181F.
5. The source of the content is from the function sub_401070, which makes a lot of calls from GDI32.DLL. By skipping the encryption it was determine that this function takes a screen shot.
6. The algorithm seems rather complicated. We can see the content before it's encrypted, easily, but it's also possible to 'decrypt' by encrypting twice.
7. By replacing the buffer of the screenshot in memory with the contents of an encrypted file from a previous run, I can 'trick' the malware into decrypting a screen shot for me.
