# Chapter 9 labs
## Lab 9-1
This lab's malware is the same as the one we analyzed in Lab 3-4 using basic static and dynamic analysis.

### Advanced Static Analysis
In IDA we see that the malware first checks the number of arguments and jumps to failure code if there are no command line arguments (argc == 1). It then calls 'RegOpenKeyExA' and 'RegQueryValueExA' trying to find a key named "Configuration" at "HKLM\SOFTWARE\Microsoft \XPS". If that key doesn't exist it jumps to the failure code. The failure code gets the name of the running modules using 'GetModuleFileNameA' and crafts a command line string starting with "/c del" and the filename, then passes it to ShellExecuteA: This is how the malware deletes itself when not used successfully. It looks like it must take an argument and if it doesn't get the input it expects it removes itself. Looking as sub_402510, the function that is called if the program is passed at least one argument. This function is passed a pointer to the _last_ command line argument. It first does checks the length of the string using an intrinsic strlen and fails if it isn't 4. It then checks the first character of the string is 'a', that the next character is greater by 1 (so it must be 'b'), that the next is 'c', and finally that the fourth (edx+3) is one greater than that: It looks like the password must be "abcd".

If the password check is successful the program continues to check argv[1] and jumps to a function to handle each of the accepted commands. '-in', '-re', '-c', and '-cc'. The '-in' option installs the service. If there's an extra argument between '-in' and the password then it uses that argument as the service name, otherwise it defaults to the name of the binary. It copies the binary to "%SYSTEMROOT%\system32\" and it registers the service and saves its configuration to "HKLM\SOFTWARE\Microsoft \XPS" (That's "Microsoft" with a space after it). The configuration data includes the strings "ups", "http://www.practicalmalwareanalysis.com", "80", and "60".

The '-re' option works like the install option but removes the service. If a service was installed with a custom name, it must be removed with the custom name, and it uses the number of argument provided to the malware to determine whether it will use the default name of a custom one.

The '-c' option requires argc to be 7, so with the executable's name taking one, the password another, and the command a third, this command appears to take four arguments. These four arguments are passed to sub_401070, the same function that was called from the install option, so these four arguments replace the configuration data that was written to the registry.

The '-cc' option doesn't take any extra arguments. It appears to do nothing more than query the registry for the configuration key and print it to the console.

If the malware is started without any command line arguments, it checks for the configuration information in the registry. If it isn't found it deletes itself as in other failure cases. If it finds the configuration registry key it calls sub_402360. This function calls a lot of other functions and works with a lot of strings. We know it runs forever, and calls send/recv to parse commands, but it seems to build, read, and copy a lot of strings, so we will use OllyDBG to help us analyze it.

### Advanced Dynamic Analysis
The function at 0x402360 is the main loop and runs forever, which we can easily tell by looking at the graph view in IDA. We never enter this loop, though, if the program was run with command line arguments. It appears the loop, when run without errors, calls sub_401280 (which reads the configuration) and then calls sub_4012020 with the hostname and the port (which was converted to an integer with 'atoi'). After this function it just calls 'Sleep' for 1000ms before jumping back to the start of the loop. sub_4012020 calls sub_401E60 and compares its return value to the strings we figured were commands, "SLEEP", "UPLOAD", "DOWNLOAD", "CMD", and "NOTHING". Since we are interested in how the malware gets this command string we will start by putting a breakpoint at 0x401E60. Looking at the disassembly it looks like a pretty straight forward function that makes calls to sub_401420, sub_401470, sub_401D80, sub_401AF0, then some calls to the intrinsic function _strstr. Setting breakpoints at each of these functions (before the call and after returning) we can quickly run through them to see what they are passed and what they return.

sub_401420 is passed the value 0x400 and a pointer to the top of the local stack space that was allocated with '__alloca_probe', and it returns 0. We see, however, that it copied "http://www.practicalmalwareanalysis.com" to the buffer. sub_401470 works similarly, but it copies 0x50 just before the host (and 0x50 = atoi(80)). sub_401D80 is passed another buffer on the stack and the value 16 and returns what looks like random characters that change every run. Re-running the program a few times and checking this function's return value yields "vq6r/tlnx.ux4", "3omL/s0yd.GH3", "urEI/uUD7.uOV" in the first few runs. It looks like the '/' and the '.' are consistent but the rest is random. sub_401AF0 has five values pushed on the stack, all pointers into the local buffer. Arg1 is the http hostname, arg2 is the port, arg3 is the "random" string generated by the previous function, arg4 appears to point to a part of the buffer that is null, and arg5 point to the value 0x100. This function appears to fail, probably because it's trying to connect to the server, while I have my DNS disabled. Sure enough, with fakedns.py running I see a request to resolve http://www.practicalmalwareanalysis.com. Looking in the function briefly I see references to "GET", "HTTP/1.0", plus calls to 'send', 'recv', etc.

Using fakedns.py plus netcat listening on port 80 we see that the malware makes a GET request for the random string we saw generated earlier. We could craft a python script that responds to any GET request to allow the malware to proceed, or patch the binary to skip over the check of the return value of sub_401AF0, but the former would take too long and the latter would probably fail or crash somewhere later (since the recv buffer would be empty). We will just analyze the code statically.

Jumping back into IDA we can see that '_strstr' is called on the received buffer twice, first compared to "\`'\`'\`" and then to "'\`'\`'". The pointers returned are compared to find the length of the command received (It appears these strings are used as delimiters) and if it fits in the supplied buffer it is copied back into the supplied buffer.

Back in sub_402020 we can see that there is a nested set of if statements that call each '_strncmp' to check if the command accepted is one of the commands we identified. The 'SLEEP' command just sleeps for the specified time, 'UPLOAD' calls sub_4019E0 where a file is downloaded from the server, 'DOWNLOAD' calls sub_401870 where the specified file is uploaded to the server. 'CMD' calls sub_401790 which calls sub_401740 to send the output of the specified command to the server over the requested port. 'NOTHING' does nothing.

### Questions
1. We can get this malware to install itself by providing it with the correct set of arguments. It expects a password of 'abcd' as the last argument and it will install if the second argument is '-in'. We can also patch the malware to skip over the password check for convenience, but it was easy to determine what password it was expecting so that's what I did.
2. This malware accepts four different commands:
 * `-in [service name]`: Install the service. Use the binary name if 'service name' is not provided.
 * `-re [service name]`: Remove the service. Use the binary name if 'service name' is not provided.
 * `-c <k> <h> <p> <per>`: Write new configuration to the registry
 * `-cc`: Print out the current configuration.
3. We can simply patch the call to sub_402B1D so that it instead sets eax to 1. Open the binary in OllyDBG and highlight from the push instruction at 0x402B2D to the "add esp, 4" and hit space, and then type in "mov eax, 1" with "Fill with NOP's" checked. The patch can be saved to the binary by right clicking in the dissasembly window and selecting "Copy to Executable -> All Modifications".
4. The name of the registry key. Notably, it uses "Microsoft" with a space after it. The name of the service also follows a pattern: "<name> Manager Service".
5. The malware accepts five commands:
 * `SLEEP <ms>`: Sleep for specified time
 * `UPLOAD <port> <filename>`: Download the data from the server over the specified port and save it to _filename_.
 * `DOWNLOAD <port> <filename>`: Open the specified _filename_ and upload it to the server over _port_.
 * `CMD <port> <command>`: Run the specified _command_ and send its output to the server over _port_.
 * `NOTHING`: Do nothing.
6. Network based signatures would be the special GET request that it makes, in the form of `[a-zA-Z0-9]{4}\/[a-zA-Z0-9]{4}\.[a-zA-Z0-9]{3}`. It also could use the default host "http://www.practicalmalwareanalysis.com", though this is configurable.

## Lab 9-2
### Advanced Dynamic Analysis
Running `strings` on this binary we see the regular set of imports from kernel32.dll and WS2_32.dll, though the imports from WS2_32.dll are by ordinal. Running the binary with process monitor we see the normal loading process but not much more. We will have to see if there's anything interesting going on in OllyDBG.

Putting breakpoints on the function calls we don't immediately recognize, we car see their arguments and their output. We see that soon after getting the name of the file that was executed it is compared to "ocl.exe", and the program exits without doing much if they do not match. If the filename matches "ocl.exe" (or we just patch the jump) then it immediately starts setting up some sockets. the function at 0x401089 appears to decrypt a string, and its result is "www.practicalmalwareanalysis.com". The malware attempts to connect to this host on port 9999, and on failure sleeps for 30 seconds before trying again. If both the host lookup and the call to 'connect' succeed then it calls the function at 0x401000, where we presume it does most of its work. After this call is just socket clean up and then another sleep before retrying everything.

Looking into the decoding function more, we see it is passed two arguments. One of the arguments is the string "1qaz2wsx3edc" and the other is a pointer to a location on the stack with non-ascii data. First we want to see where this data came from. We start by placing a breakpoint at the start of main and then a write breakpoint at 0x12FDD0. We see that it's almost immediately written at the start of main. From 0x401133 to 0x4011BF we see immediate values being written byte-by-byte onto the stack. Stepping through we see it copy the first argument we were curious about, as well as "ocl.exe", the string that is checked against the name of the binary. We now do the same for 0x12FD290 and see that it's written to 8 times at four byte each with a 'REP MOVS DWORD PTR' instruction at 0x4011D6 (for a total of 32 bytes). The source for this copy is at 0x405034 which we see is in the .data section by pressing on the 'M' button to look at the memory map. Going back to the CPU view ('C') we can jump ahead to the actual decryption in the function at 0x401089.

This function first gets the length of the ASCII string and then enters a for loop that iterates 32 times (which coincides with the length of the other argument's data). On each iteration the index into the data is divided by the length of the ascii string, and the remainder used as an index into the ASCII string and xored against the current byte of the other argument. This looks like a simple decryption scheme that uses the shorter string as a repeating key. This is a simple routine that can be used to also encrypt the desired string (fully symmetrical), if we wanted to modify this malware to connect to another host.

Now jumping to what happens when a connection is established, we go to the function at 0x401000. The most significant part of this function is the call to 'CreateProcessA'. The _CommandLine_ argument to this function is the `cmd` utility, and most of the options are NULL or 0. the _pProcessInfo_ argument and the _pStartupInfo_ arguments are both pointers to objects created in the local frame, so we must look at how they are setup. Looking up 'CreateProcess' on MSDN we see that these two arguments are pointers to structures of types 'PROCESS_INFORMATION' and 'STARTUP_INFORMATION', respectively. The 'PROCESS_INFORMATION' structure seems uninteresting (all 0), but the 'STARTUP_INFORMATION' structure has a few custom flags, and the _hStdInput_, _hStdOutput_, and _hStdError_ members are all 0x60. The _dwFlags_ member is 0x101, which represents 'STARTF_USESTDHANDLES' and 'STARTF_USESHOWWINDOW'. These just means to use the aforementioned handles and to set the window to 'SW_HIDE' so that the user cannot see it. It looks like this malware is trying to set up a reverse shell.

Running the malware with `fakedns.py` and `nc -l -p 9999` we immediately see the `cmd` banner show up, giving us a prompt and proving our theory. If we set a breakpoint just before calling 'CreateProcessA' we can clear the lowest bit of _dwFlags_ and we see that in this case a `cmd` window does pop up on the victim machine.

### Questions
1. There are the names of some imports, a bunch of errors messages, some codes in the format R60##, and the string "cmd".
2. This program does nothing by default when executed.
3. The program can be run successfully by passing the check at the beginning of main. This can be done by renaming the binary to 'ocl.exe' or patching out the check.
4. Two strings are written to the stack, byte by byte. "1qaz2wsx3edc" and "ocl.exe". This is why these strings were not found by the strings utility.
5. The string that was constructed on the stack is somehow being decoded to "www.practicalmalwareanalysis.com".
6. "www.practicalmalwareanalysis.com".
7. The function at 0x401089 takes an encoded string and uses it as an xor key against a constant that was copied to the stack at the start of main.
8. The malware is piping all input and output from this socket to `cmd` so that it can be used as a reverse shell.

## Lab 9-3
### Advanced Static Analysis
Loading the lab 3 executable we see that its behaviour is largely contained in the accompanying dlls. It appears to call 'DLL1Print', 'DLL2Print', and 'DLL2ReturnJ' which are exported by the respective dlls and can be found in the executable's import table. 'DLL3.DLL', on the otherhand, is not found in the import table at all. We see that it is instead loaded manually using a call to 'LoadLibraryA'. 'GetProcAddress' is then called to get the address of the 'DLL3Print' and 'Dll3GetStructure' (which it uses to then call). Looking at DLL2.DLL we see it only exports 'DLL1Print' and 'DllEntryPoint' (which all DLLs must export). DLL2.DLL exports 'DLL2Print' and 'DLL2ReturnJ', and DLL3.DLL exports 'DLL3Print' and 'DLL3GetStructure'.

Loading DLL1.DLL in IDA we see DLL1Print pushes two values on to the stack before calling sub_10001038. The first being the value of dword_10008030, and the second being the string "DLL 1 mystery data %d\n". sub_10001038 presumably prints out this string, but we need to figure out where dword_10008030 is written to so we know what value is passes. Double clicking on the global variable and then pressing Ctrl-x to find cross-references shows that it is written to from DllMain with the return value from 'GetCurrentProccesId', and we can see that DllMain is called from DllEntryPoint.

Loading DLL2.DLL now we see DLL2Print is similar to DLL1Print and we see that the dword it passes to its print function (dword_1000B078) is written to from DllMain. This time it's passed the handle returned from 'CreateFileA', which was called attempting to open `temp.txt`. DLL2ReturnJ seems to return this same handle.

DLL3.DLL is also very similar, we see it's the address of some uninitialized data IDA has decided to name 'WideCharStr'. This value would therefore change if we changed the load order of the DLLs since it is relative to the DLL's base address. The dword is again written to from DllMain, where the function calls 'MultiByteToWideChar' with the ASCII string "ping www.malwareanalysisbook.com", writing it to 'WideCharStr' at offset 0x40C0 into the data section (0x1000B0C0 according to IDA). This means that this DLL prints the address where the unicode string "ping www.malwareanalysisbook.com" is stored.

Dll3GetStructure just seems to write the address of word_1000B0A0 to the address provided as an argument. This dword is written to from DllMain with the value 0x36EE80. This global variable immediately precedes other global variables that are written to, including the unicode string offset. It looks like is it building some kind of structure.

Back in the main function of Lab09-03.exe, we see that the address of a local variable on the stack was passed to 'Dll3GetStructure' and the pointer to the structure it copies over is then passed to 'NetScheduleJobAdd'. Looking on MSDN we see this function expects a _Buffer_ argument that points to an AT_INFO structure. Looking back at the values written to the struct in DLL3's 'DllMain' we see that the 0x36EE80 value is the _JobTime_, 0 is the _DaysOfMonth_, 0x7F is the _DaysOfWeek_, and 0x11 is the _Flags_, while the command itself is the string "ping www.malwareanalysisbook.com". 0x36EE80 is 3600000 in decimal, or 1 hour (in milliseconds) which means the _JobTime_ is 1AM. _DaysOfMonth_ is a bitfield where each bit represents a day, with no bits set it means to run only once. _DaysOfWeek_ is another bitfield, and 0x7F is 0b01111111, meaning every day of the week. The _Flags_ field is a bit field , and the two set bits in 0x11 represent JOB_NONINTERACTIVE and JOB_RUN_PERIODICALLY. This executable is made to ping www.malwareanalysisbook.com at 1AM every day. We can run the `at` utility in the shell and see the jobs that have been scheduled.

    C:\Documents and Settings\Debugger>at
    Status ID   Day                     Time          Command Line
    -------------------------------------------------------------------------------
            1   Each M T W Th F S Su    1:00 AM       ping www.malwareanalysisbook.com

### Advanced Dynamic Analysis

Loading up the executable in OllyDBG and putting a breakpoint at the start of main, we click on the 'M' button to see the loaded modules. We see that DLL1 is loaded at 0x10000000 (where it requests), while DLL2 is loaded at 0x330000. DLL3 has not been loaded yet. Putting a breakpoint after the call to 'LoadLibraryA' we can see it's loaded at 0x390000. By setting breakpoints after the calls to each dll print function we can verify it prints the strings as expected.

### Questions
1. This lab's executable imports functions from DLL1.DLL, DLL2.DLL, KERNEL32.DLL, and NETAPI32.DLL
2. The base address requested by each DLL is 0x10000000, which we find at offset 0x114 of the IMAGE_OPTIONAL_HEADER.
3. DLL1: 0x10000000, DLL2: 0x330000, DLL3: 0x390000.
4. DLL1Print is called and it prints the string "DLL 1 mystery data %d\n", where the %d is replaced with the process id of the process that loaded the dll.
5. WriteFile is passed the handle to the 'temp.txt' file that was opened by 'DllMain' in DLL1.DLL.
6. The _Buffer_ argument is provided by the call to 'Dll3GetStructure'. The values in this structure are created dynamically in DLL3.DLL's 'DllMain' function.
7. Dll1: The process id of the executable, Dll2: Handle to the 'temp.txt' file it opened, Dll3: The address of the unicode string "ping www.malwareanalysisbook.com".
8. Although the analysis was simple and I didn't need to, I could load DLL2.DLL and DLL3.DLL into IDA at a custom address so that it was consistent to where it was loaded in memory by selecting 'Manual Load' when loading the file and then specifying the custom base address.

