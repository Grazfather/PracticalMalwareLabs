# Chapter 9 labs
## Lab 9-1
This lab's malware is the same as the one we analyzed in Lab 3-4 using basic static and dynamic analysis.

### Advanced Static Analysis
In IDA we see that the malware first checks the number of arguments and jumps to failure code if there are no command line arguments (argc == 1). It then calls 'RegOpenKeyExA' and 'RegQueryValueExA' trying to find a key named "Configuration" at "HKLM\SOFTWARE\Microsoft \XPS". If that key doesn't exist it jumps to the failure code. The failure code gets the name of the running modules using 'GetModuleFileNameA' and crafts a command line string starting with "/c del" and the filename, then passes it to ShellExecuteA: This is how the malware deletes itself when not used successfully. It looks like it must take an argument and if it doesn't get the input it expects it removes itself. Looking as sub_402510, the function that is called if the program is passed at least one argument. This function is passed a pointer to the _last_ command line argument. It first does checks the length of the string using an intrinsic strlen and fails if it isn't 4. It then checks the first character of the string is 'a', that the next character is greater by 1 (so it must be 'b'), that the next is 'c', and finally that the fourth (edx+3) is one greater than that: It looks like the password must be "abcd".

If the password check is successful the program continues to check argv[1] and jumps to a function to handle each of the accepted commands. '-in', '-re', '-c', and '-cc'. The '-in' option installs the service. If there's an extra argument between '-in' and the password then it uses that argument as the service name, otherwise it defaults to the name of the binary. It copies the binary to "%SYSTEMROOT%\system32\" and it registers the service and saves its configuration to "HKLM\SOFTWARE\Microsoft \XPS" (That's "Microsoft" with a space after it). The configuration data includes the strings "ups", "http://www.practicalmalwareanalysis.com", "80", and "60".

The '-re' option works like the install option but removes the service. If a service was installed with a custom name, it must be removed with the custom name, and it uses the number of argument provided to the malware to determine whether it will use the default name of a custom one.

The '-c' option requires argc to be 7, so with the executable's name taking one, the password another, and the command a third, this command appears to take four arguments. These four arguments are passed to sub_401070, the same function that was called from the install option, so these four arguments replace the configuration data that was written to the registry.

The '-cc' option doesn't take any extra arguments. It appears to do nothing more than query the registry for the configuration key and print it to the console.

If the malware is started without any command line arguments, it checks for the configuration information in the registry. If it isn't found it deletes itself as in other failure cases. If it finds the configuration registry key it calls sub_402360. This function calls a lot of other functions and works with a lot of strings. We know it runs forever, and calls send/recv to parse commands, but it seems to build, read, and copy a lot of strings, so we will use OllyDBG to help us analyze it.

### Advanced Dynamic Analysis
The function at 0x402360 is the main loop and runs forever, which we can easily tell by looking at the graph view in IDA. We never enter this loop, though, if the program was run with command line arguments. It appears the loop, when run without errors, calls sub_401280 (which reads the configuration) and then calls sub_4012020 with the hostname and the port (which was converted to an integer with 'atoi'). After this function it just calls 'Sleep' for 1000ms before jumping back to the start of the loop. sub_4012020 calls sub_401E60 and compares its return value to the strings we figured were commands, "SLEEP", "UPLOAD", "DOWNLOAD", "CMD", and "NOTHING". Since we are interested in how the malware gets this command string we will start by putting a breakpoint at 0x401E60. Looking at the disassembly it looks like a pretty straight forward function that makes calls to sub_401420, sub_401470, sub_401D80, sub_401AF0, then some calls to the intrinsic function _strstr. Setting breakpoints at each of these functions (before the call and after returning) we can quickly run through them to see what they are passed and what they return.

sub_401420 is passed the value 0x400 and a pointer to the top of the local stack space that was allocated with '__alloca_probe', and it returns 0. We see, however, that it copied "http://www.practicalmalwareanalysis.com" to the buffer. sub_401470 works similarly, but it copies 0x50 just before the host (and 0x50 = atoi(80)). sub_401D80 is passed another buffer on the stack and the value 16 and returns what looks like random characters that change every run. Re-running the program a few times and checking this function's return value yields "vq6r/tlnx.ux4", "3omL/s0yd.GH3", "urEI/uUD7.uOV" in the first few runs. It looks like the '/' and the '.' are consistent but the rest is random. sub_401AF0 has five values pushed on the stack, all pointers into the local buffer. Arg1 is the http hostname, arg2 is the port, arg3 is the "random" string generated by the previous function, arg4 appears to point to a part of the buffer that is null, and arg5 point to the value 0x100. This function appears to fail, probably because it's trying to connect to the server, while I have my DNS disabled. Sure enough, with fakedns.py running I see a request to resolve http://www.practicalmalwareanalysis.com. Looking in the function briefly I see references to "GET", "HTTP/1.0", plus calls to 'send', 'recv', etc.

Using fakedns.py plus netcat listening on port 80 we see that the malware makes a GET request for the random string we saw generated earlier. We could craft a python script that responds to any GET request to allow the malware to proceed, or patch the binary to skip over the check of the return value of sub_401AF0, but the former would take too long and the latter would probably fail or crash somewhere later (since the recv buffer would be empty). We will just analyze the code statically.

Jumping back into IDA we can see that '_strstr' is called on the received buffer twice, first compared to "`'`'`" and then to "'`'`'". The pointers returned are compared to find the length of the command received (It appears these strings are used as delimiters) and if it fits in the supplied buffer it is copied back into the supplied buffer.

Back in sub_402020 we can see that there is a nested set of if statements that call each '_strncmp' to check if the command accepted is one of the commands we identified. The 'SLEEP' command just sleeps for the specified time, 'UPLOAD' calls sub_4019E0 where a file is downloaded from the server, 'DOWNLOAD' calls sub_401870 where the specified file is uploaded to the server. 'CMD' calls sub_401790 which calls sub_401740 to send the output of the specified command to the server over the requested port. 'NOTHING' does nothing.

### Questions
1. We can get this malware to install itself by providing it with the correct set of arguments. It expects a password of 'abcd' as the last argument and it will install if the second argument is '-in'. We can also patch the malware to skip over the password check for convenience, but it was easy to determine what password it was expecting so that's what I did.
2. This malware accepts four different commands:
 * `-in [service name]`: Install the service. Use the binary name if 'service name' is not provided.
 * `-re [service name]`: Remove the service. Use the binary name if 'service name' is not provided.
 * `-c <k> <h> <p> <per>`: Write new configuration to the registry
 * `-cc`: Print out the current configuration.
3. We can simply patch the call to sub_402B1D so that it instead sets eax to 1. Open the binary in OllyDBG and highlight from the push instruction at 0x402B2D to the "add esp, 4" and hit space, and then type in "mov eax, 1" with "Fill with NOP's" checked. The patch can be saved to the binary by right clicking in the dissasembly window and selecting "Copy to Executable -> All Modifications".
4. The name of the registry key. Notably, it uses "Microsoft" with a space after it. The name of the service also follows a pattern: "<name> Manager Service".
5. The malware accepts five commands:
 * `SLEEP <ms>`: Sleep for specified time
 * `UPLOAD <port> <filename>`: Download the data from the server over the specified port and save it to _filename_.
 * `DOWNLOAD <port> <filename>`: Open the specified _filename_ and upload it to the server over _port_.
 * `CMD <port> <command>`: Run the specified _command_ and send its output to the server over _port_.
 * `NOTHING`: Do nothing.
6. Network based signatures would be the special GET request that it makes, in the form of `[a-zA-Z0-9]{4}\/[a-zA-Z0-9]{4}\.[a-zA-Z0-9]{3}`. It also could use the default host "http://www.practicalmalwareanalysis.com", though this is configurable.
