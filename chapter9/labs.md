# Chapter 9 labs
## Lab 9-1
This lab's malware is the same as the one we analyzed in Lab 3-4 using basic static and dynamic analysis.

### Advanced Static Analysis
In IDA we see that the malware first checks the number of arguments and jumps to failure code if there are no command line arguments (argc == 1). It then calls 'RegOpenKeyExA' and 'RegQueryValueExA' trying to find a key named "Configuration" at "HKLM\SOFTWARE\Microsoft \XPS". If that key doesn't exist it jumps to the failure code. The failure code gets the name of the running modules using 'GetModuleFileNameA' and crafts a command line string starting with "/c del" and the filename, then passes it to ShellExecuteA: This is how the malware deletes itself when not used successfully. It looks like it must take an argument and if it doesn't get the input it expects it removes itself. Looking as sub_402510, the function that is called if the program is passed at least one argument. This function is passed a pointer to the _last_ command line argument. It first does checks the length of the string using an intrinsic strlen and fails if it isn't 4. It then checks the first character of the string is 'a', that the next character is greater by 1 (so it must be 'b'), that the next is 'c', and finally that the fourth (edx+3) is one greater than that: It looks like the password must be "abcd".

If the password check is successful the program continues to check argv[1] and jumps to a function to handle each of the accepted commands. '-in', '-re', '-c', and '-cc'. The '-in' option installs the service. If there's an extra argument between '-in' and the password then it uses that argument as the service name, otherwise it defaults to the name of the binary. It copies the binary to "%SYSTEMROOT%\system32\" and it registers the service and saves its configuration to "HKLM\SOFTWARE\Microsoft \XPS" (That's "Microsoft" with a space after it). The configuration data includes the strings "ups", "http://www.practicalmalwareanalysis.com", "80", and "60".

The '-re' option works like the install option but removes the service. If a service was installed with a custom name, it must be removed with the custom name, and it uses the number of argument provided to the malware to determine whether it will use the default name of a custom one.

The '-c' option requires argc to be 7, so with the executable's name taking one, the password another, and the command a third, this command appears to take four arguments. These four arguments are passed to sub_401070, the same function that was called from the install option, so these four arguments replace the configuration data that was written to the registry.

The '-cc' option doesn't take any extra arguments. It appears to do nothing more than query the registry for the configuration key and print it to the console.

If the malware is started without any command line arguments, it checks for the configuration information in the registry. If it isn't found it deletes itself as in other failure cases. If it finds the configuration registry key it calls sub_402360. This function calls a lot of other functions and works with a lot of strings. We know it runs forever, and calls send/recv to parse commands, but it seems to build, read, and copy a lot of strings, so we will use OllyDBG to help us analyze it.

### Advanced Dynamic Analysis
The function at 0x402360 is the main loop and runs forever, which we can easily tell by looking at the graph view in IDA. We never enter this loop, though, if the program was run with command line arguments. It appears the loop, when run without errors, calls sub_401280 (which reads the configuration) and then calls sub_4012020 with the hostname and the port (which was converted to an integer with 'atoi'). After this function it just calls 'Sleep' for 1000ms before jumping back to the start of the loop. sub_4012020 calls sub_401E60 and compares its return value to the strings we figured were commands, "SLEEP", "UPLOAD", "DOWNLOAD", "CMD", and "NOTHING". Since we are interested in how the malware gets this command string we will start by putting a breakpoint at 0x401E60. Looking at the disassembly it looks like a pretty straight forward function that makes calls to sub_401420, sub_401470, sub_401D80, sub_401AF0, then some calls to the intrinsic function _strstr. Setting breakpoints at each of these functions (before the call and after returning) we can quickly run through them to see what they are passed and what they return.

sub_401420 is passed the value 0x400 and a pointer to the top of the local stack space that was allocated with '__alloca_probe', and it returns 0. We see, however, that it copied "http://www.practicalmalwareanalysis.com" to the buffer. sub_401470 works similarly, but it copies 0x50 just before the host (and 0x50 = atoi(80)). sub_401D80 is passed another buffer on the stack and the value 16 and returns what looks like random characters that change every run. Re-running the program a few times and checking this function's return value yields "vq6r/tlnx.ux4", "3omL/s0yd.GH3", "urEI/uUD7.uOV" in the first few runs. It looks like the '/' and the '.' are consistent but the rest is random. sub_401AF0 has five values pushed on the stack, all pointers into the local buffer. Arg1 is the http hostname, arg2 is the port, arg3 is the "random" string generated by the previous function, arg4 appears to point to a part of the buffer that is null, and arg5 point to the value 0x100. This function appears to fail, probably because it's trying to connect to the server, while I have my DNS disabled. Sure enough, with fakedns.py running I see a request to resolve http://www.practicalmalwareanalysis.com. Looking in the function briefly I see references to "GET", "HTTP/1.0", plus calls to 'send', 'recv', etc.

Using fakedns.py plus netcat listening on port 80 we see that the malware makes a GET request for the random string we saw generated earlier. We could craft a python script that responds to any GET request to allow the malware to proceed, or patch the binary to skip over the check of the return value of sub_401AF0, but the former would take too long and the latter would probably fail or crash somewhere later (since the recv buffer would be empty). We will just analyze the code statically.

Jumping back into IDA we can see that '_strstr' is called on the received buffer twice, first compared to "`'`'`" and then to "'`'`'". The pointers returned are compared to find the length of the command received (It appears these strings are used as delimiters) and if it fits in the supplied buffer it is copied back into the supplied buffer.

Back in sub_402020 we can see that there is a nested set of if statements that call each '_strncmp' to check if the command accepted is one of the commands we identified. The 'SLEEP' command just sleeps for the specified time, 'UPLOAD' calls sub_4019E0 where a file is downloaded from the server, 'DOWNLOAD' calls sub_401870 where the specified file is uploaded to the server. 'CMD' calls sub_401790 which calls sub_401740 to send the output of the specified command to the server over the requested port. 'NOTHING' does nothing.

### Questions
1. We can get this malware to install itself by providing it with the correct set of arguments. It expects a password of 'abcd' as the last argument and it will install if the second argument is '-in'. We can also patch the malware to skip over the password check for convenience, but it was easy to determine what password it was expecting so that's what I did.
2. This malware accepts four different commands:
 * `-in [service name]`: Install the service. Use the binary name if 'service name' is not provided.
 * `-re [service name]`: Remove the service. Use the binary name if 'service name' is not provided.
 * `-c <k> <h> <p> <per>`: Write new configuration to the registry
 * `-cc`: Print out the current configuration.
3. We can simply patch the call to sub_402B1D so that it instead sets eax to 1. Open the binary in OllyDBG and highlight from the push instruction at 0x402B2D to the "add esp, 4" and hit space, and then type in "mov eax, 1" with "Fill with NOP's" checked. The patch can be saved to the binary by right clicking in the dissasembly window and selecting "Copy to Executable -> All Modifications".
4. The name of the registry key. Notably, it uses "Microsoft" with a space after it. The name of the service also follows a pattern: "<name> Manager Service".
5. The malware accepts five commands:
 * `SLEEP <ms>`: Sleep for specified time
 * `UPLOAD <port> <filename>`: Download the data from the server over the specified port and save it to _filename_.
 * `DOWNLOAD <port> <filename>`: Open the specified _filename_ and upload it to the server over _port_.
 * `CMD <port> <command>`: Run the specified _command_ and send its output to the server over _port_.
 * `NOTHING`: Do nothing.
6. Network based signatures would be the special GET request that it makes, in the form of `[a-zA-Z0-9]{4}\/[a-zA-Z0-9]{4}\.[a-zA-Z0-9]{3}`. It also could use the default host "http://www.practicalmalwareanalysis.com", though this is configurable.

## Lab 9-2
### Advanced Dynamic Analysis
Running `strings` on this binary we see the regular set of imports from kernel32.dll and WS2_32.dll, though the imports from WS2_32.dll are by ordinal. Running the binary with process monitor we see the normal loading process but not much more. We will have to see if there's anything interesting going on in OllyDBG.

Putting breakpoints on the function calls we don't immediately recognize, we car see their arguments and their output. We see that soon after getting the name of the file that was executed it is compared to "ocl.exe", and the program exits without doing much if they do not match. If the filename matches "ocl.exe" (or we just patch the jump) then it immediately starts setting up some sockets. the function at 0x401089 appears to decrypt a string, and its result is "www.practicalmalwareanalysis.com". The malware attempts to connect to this host on port 9999, and on failure sleeps for 30 seconds before trying again. If both the host lookup and the call to 'connect' succeed then it calls the function at 0x401000, where we presume it does most of its work. After this call is just socket clean up and then another sleep before retrying everything.

Looking into the decoding function more, we see it is passed two arguments. One of the arguments is the string "1qaz2wsx3edc" and the other is a pointer to a location on the stack with non-ascii data. First we want to see where this data came from. We start by placing a breakpoint at the start of main and then a write breakpoint at 0x12FDD0. We see that it's almost immediately written at the start of main. From 0x401133 to 0x4011BF we see immediate values being written byte-by-byte onto the stack. Stepping through we see it copy the first argument we were curious about, as well as "ocl.exe", the string that is checked against the name of the binary. We now do the same for 0x12FD290 and see that it's written to 8 times at four byte each with a 'REP MOVS DWORD PTR' instruction at 0x4011D6 (for a total of 32 bytes). The source for this copy is at 0x405034 which we see is in the .data section by pressing on the 'M' button to look at the memory map. Going back to the CPU view ('C') we can jump ahead to the actual decryption in the function at 0x401089.

This function first gets the length of the ASCII string and then enters a for loop that iterates 32 times (which coincides with the length of the other argument's data). On each iteration the index into the data is divided by the length of the ascii string, and the remainder used as an index into the ASCII string and xored against the current byte of the other argument. This looks like a simple decryption scheme that uses the shorter string as a repeating key. This is a simple routine that can be used to also encrypt the desired string (fully symmetrical), if we wanted to modify this malware to connect to another host.

Now jumping to what happens when a connection is established, we go to the function at 0x401000. The most significant part of this function is the call to 'CreateProcessA'. The _CommandLine_ argument to this function is the `cmd` utility, and most of the options are NULL or 0. the _pProcessInfo_ argument and the _pStartupInfo_ arguments are both pointers to objects created in the local frame, so we must look at how they are setup. Looking up 'CreateProcess' on MSDN we see that these two arguments are pointers to structures of types 'PROCESS_INFORMATION' and 'STARTUP_INFORMATION', respectively. The 'PROCESS_INFORMATION' structure seems uninteresting (all 0), but the 'STARTUP_INFORMATION' structure has a few custom flags, and the _hStdInput_, _hStdOutput_, and _hStdError_ members are all 0x60. The _dwFlags_ member is 0x101, which represents 'STARTF_USESTDHANDLES' and 'STARTF_USESHOWWINDOW'. These just means to use the aforementioned handles and to set the window to 'SW_HIDE' so that the user cannot see it. It looks like this malware is trying to set up a reverse shell.

Running the malware with `fakedns.py` and `nc -l -p 9999` we immediately see the `cmd` banner show up, giving us a prompt and proving our theory. If we set a breakpoint just before calling 'CreateProcessA' we can clear the lowest bit of _dwFlags_ and we see that in this case a `cmd` window does pop up on the victim machine.

### Questions
1. There are the names of some imports, a bunch of errors messages, some codes in the format R60##, and the string "cmd".
2. This program does nothing by default when executed.
3. The program can be run successfully by passing the check at the beginning of main. This can be done by renaming the binary to 'ocl.exe' or patching out the check.
4. Two strings are written to the stack, byte by byte. "1qaz2wsx3edc" and "ocl.exe". This is why these strings were not found by the strings utility.
5. The string that was constructed on the stack is somehow being decoded to "www.practicalmalwareanalysis.com".
6. "www.practicalmalwareanalysis.com".
7. The function at 0x401089 takes an encoded string and uses it as an xor key against a constant that was copied to the stack at the start of main.
8. The malware is piping all input and output from this socket to `cmd` so that it can be used as a reverse shell.
