# Lab 18
The goal for these labs is simply to unpack the code so that we could proceed with further analysis.

## Lab 18-1
### Basic Static Analysis
- **strings**: Nothing interesting other than some alphabets and imports.
- **PEiD**: Nothing found *.
- **Dependency Walker**: `URLDownloadCacheFileA` from _URLMON.DLL_, `GetUserNameA` from _ADVAPI32.DLL_, `ExitProcess`, `GetProcAddress`, `LoadLibraryA`, `VirtualAlloc`, `VirtualFree`, and `VirtualProtect` from _KERNEL32.DLL_.
- **PEview**: .text, .data, and "UPX2" which suggests it's packed with UPX. Entrypoint is 0x9DC0. With .data's RVA of 0x7000 and size of 0x3000 it falls within there.

### Advanced Static Analysis
IDA only recognizes a single function, `start`. Looking for `jmp` instructions, one in particular stands out: `jmp byte_40154F` at 0x409F43. It's both a long jump, and its target doesn't contain valid instructions.

Setting a bp on this address and then making a single step (avoiding setting a SW breakpoint on code that is changing) indeed hits and goes to what is now normal looking code. Using OllyDump with the default settings I was able to dump the process memory into an executable for analysis in IDA (though IDA warns that the import table is corrupted).

Looking at the now visible strings, I found "http://www.practicalmalwareanalysis.com/%s/%c.png". Grepping for that in my other writeups, I see that the same string was used in Lab 14-1, and can easily verify that they are the same malware.

## Lab 18-2
### Basic Static Analysis
- **strings**: Nothing of interest other than "Init" and two imports.
- **PEiD**: FSG 1.0 -> dulek/xt.
- **Dependency Walker**: Two imports: `GetProcAddress` and `LoadLibraryA` from _KERNEL32.DLL_. This unpacking stub must manually import everything in the original import table.
- **PEview**: No named sections, but two unnamed. Somehow there are headers for three sections. The first section header has no raw data, and is presumably the target where the unpacker will place the malware. Entrypoint is 0x5000, which is an address in the third section.

### Advanced Dynamic/Static Analysis
In this malware, IDA actually identifies three functions in addition to `start`. `sub_40501F` is called immediately, and that function makes all other calls. Placing a breakpoint after the call in `start` hits, meaning that the unpacking functions never make the jump to the OEP. Returning from here actually returns into `sub_40501F`, so unfortunately it won't be that straight forward.

Going back into PEview, we see that the empty section starts at RVA 0x1000. Adding the image base of 0x400000 gives us 0x401000. Putting a **hardware** breakpoint on this address hits, but what is written doesn't appear to be code. Hitting Ctrl-A makes Olly re-analyze the code, though, and it indeed looks legit. Dumping with OllyDump at this point again yields a binary IDA can analyze.

Looking at the strings now, I find "http://www.malwareanalysisbook.com/ad.html". Grepping for this in my writeups I found Lab 7-2 and Lab 10-3. Lab 7-2, however, was the only one that shared the _ole32.dll_ imports, and I can verify that the malware does indeed match.

## Lab 18-3
### Basic Static Analysis
- **strings**: Nothing of interest.
- **PEiD**: PECompact 1.68 - 1.84 -> Jeremy Collake.
- **Dependency Walker**: `WSAStartup` (by ordinal) from _WS2_32.DLL_. `ExitProcess`, `GetModuleHandleA`, `GetProcAddress`, `LoadLibraryA`, `VirtualAlloc`, and `VirtualFree` from _KERNEL32.DLL_.
- **PEview**: No named sections, but two unnamed. Somehow there are headers for three sections. The first section header has no raw data, and is presumably the target where the unpacker will place the malware. Entrypoint is 0x5000, which is an address in the third section.

### Advanced Dynamic/Static Analysis
First thing to try is OllyDump, but both section hop methods dump binaries that are clearly incorrect.

Loading it in IDA there is only a very short blurb visible. There is a point, however, where EBX is pushed onto the stack, and this same address is copied into. When this blurb returns it returns to this newly placed code. Walking through with Olly and dumping at this point allows up to continue our analysis with IDA. For some reason Olly cannot re-analyze the code that it is currently running, but I can dump and re-open the binary. Unfortunately chasing this through doesn't seem fruitful.

Looking back at the original start, we see `pushfd` and `pushad`. Putting a hardware breakpoints (4 Bytes) for one of these stack addresses, we can just continue until it hits, assuming that these values were pushed for a reason and will therefore need to be popped.

Sure enough, we see the values get popped at 0x40754e. After these are popped, the address 0x4014577 is pushed on the stack and then there is a return. Stepping through to where the code returns and dumping indeed yields a binary looks a lot more insane, including imports and everything else you might expect. The sections, according to both Olly and IDA are "pec1", "pec2", and .rsrc.

Identifying the malware isn't completely straight forward, because there aren't really any relevant strings, but there's a function that decodes it, and the imports give another hint. Around the call to `htons` we see that the port is 9999. Just looking through the old writeups for this port only brings up a few. Looking through them it's clear that this malware is Lab 9-2.

## Lab 18-4
### Basic Static Analysis
- **strings**: More imports than you might expect from a packed file, plus "LOADER ERROR" and strings that look related to manually loading parsing a dynamic library.
- **PEiD**: ASPack 2.12 -> Alexey Solodovnikov.
- **Dependency Walker**: `shutdown` from _WS2_32.DLL_ (by ordinal), `ShellExecuteA` from _SHELL32.DLL_, `OpenSCManagerA` from _ADVAPI32.DLL_, and `GetModuleHandleA`, `GetProcAddress`, and `LoadLibraryA` from _KERNEL32.DLL_.
- **PEview**: In addition to .text, .rdata, and .data there are .aspack and .adata sections. The .aspack section has some import and relocation-related data within.

### Advanced Dynamic/Static Analysis
Opening in Olly we see that it starts right away with a `pushad` instruction. Stepping past this and then setting a hardware breakpoint on access (for the pop) and running seems to work fine. Once it hits, it's just a few more steps until there's a `ret` and we are at what looks like a `start` function.

Grepping for some unique strings, such at the web address "http://www.practicalmalwareanalysis.com" or some of the commands such as "NOTHING" narrows us down to Lab 9-1.

## Lab 18-5
### Basic Static Analysis
- **strings**: Very few. "LoadLibraryA", "GetProcAddress", and "MZKERNEL32.DLL" (which seems to be the PE magic as well as the only import) are the only decipherable strings found.
- **PEiD**: Upack 0.39 beta -> Dwing
- **Dependency Walker**: Could not be parsed. "Warning: At least one module was corrupted or unrecognizable to Dependency Walker, but still appeared to be a Windows module.".
- **PEview**: Most sections appear to be missing. No MS-DOS stub, no sections and no section headers. Just IMAGE_DOS_HEADER and IMAGE_NT_HEADERS.

### Advanced Dynamic/Static Analysis
Loading the binary into Olly didn't even work. We get a "Bad or unknown format of 32-bit executable file" error. The EIP starts on a return instruction in `DbgBreakPoint`, which is near where the OS starts the process before even `start`.

IDA warns that the file has unaligned section pointers, but at least it generates a sane-enough looking graph of `start`. Although there are no import or exports according to IDA, there is the string "GetProcAddress", which gives us something to go on.

Back in Olly, I set a breakpoint in `GetProcAddress`, so I can see all the calls and easily inspect the stack to see which function they are trying to grab. Once some were loaded that were clearly not related to the packer (e.g. `CreateServiceA`), I set a breakpoint in that function, and unset the first. Once that hits I look at the stack to see where it came from, and then try to find the top of the highest identifiable function. Dumping the memory into this binary gets us close, but IDA still cannot read it. Still, the strings have been unencrypted. It looks like there were still a few calls, but that's not a problem: I can continue breaking on this call.

Using the tactic from the solution in the book ( :'( ), I still could not get it to work. There were many more calls to `GetProcAddress` and `LoadLibrary*` than expected. This may have been due to the malware itself taking some path that caused those calls. Restarting the VM and trying again this solution seemed to work.

The tactic was to assume that the unpacker would jump to the OEP soon after the last call to `GetProcAddress`, but because we couldn't know which was last until _after_ we had passed it, we would have to do trial-and-error. Because there could be many imported functions, this would have been tedious. A tactic to do is more quickly is to first find all the calls to `LoadLibrary*`, find the last, and then on the next run, once we hit it, put a breakpoint on `GetProcAddress` and repeate the process. Once this was done, we could see that the sixth library was the last to be loaded, and then `InternetOpenA` was the last symbol located. At this point it was only a few more steps (once returning from the kernel32 calls) before the loader `retn`ed to what looked like a sensical binary. At this point we could dump the process into a binary.

Loading this binary into IDA we can follow the malware around, but unfortunately the import table was not properly added to the dumped binary's header. The calls instead would call into a jump table. Luckily for us the debugger will resolve these addresses for us, and we can easily view the table in the memory dump. By setting a register to each address in turn we could see the symbol name resolved and write it to the table in IDA.

Going through a handful of these, along with peeking at the strings, we can easily identify that this malware is the same as the one from Lab 7-1.
