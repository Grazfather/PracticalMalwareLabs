# Lab 21
Because I don't have a 64-bit Windows VM, I can only do these statically.

## Lab 20-1
### Basic Static Analysis
- **strings**: A few date formats, imports, and some weird padding string.
- **CFF Explorer**: Microsoft Visual C++ 8.0, 64 bit.
- **Dependency Walker**: Many imports from KERNEL32.DLL, plus some low-level socket imports from WS2_32.DLL (by ordinal).
- **PEview**: Normal section names and headers, with the addition of .pdata and .rsrc.
- **Resource Hacker** (Because of the presence of the .rsrc section): A single resource that contains the short XML blurb found with `strings`.

### Advanced Static Analysis
Popping the binary into IDA, we don't see `main`, and so have to start with `_start`. Knowing that `main` is passed and int and two pointers, we can simply find the call that sets args in this way. We find this at `sub_1400010c0`.

Here we see a call to `GetModuleFileNameA`, and a bit later a jump that goes to the end of the function. Lab 9-2 required that the malware was named "ocl.exe", so we will see if that's the case here. Looking just before the jump to bail out we see a call to `strncmp`. Going back up we can see where its args come from.

The first is stored on the stack at rbp + 0xe0, and we see that this address is written to a few times. The first at 0x140001157, where an int that happens to be all ASCII is written ("ocl."). There is another write right after with "exe". That would suggest that we need to name the binary "ocl.exe", but actually we can see later that that same local is written to again. Starting at 0x1400011b0 there is a little encoding block. Since I don't have a VM to run this, but didn't want to figure out what this decoded to, I used [unicorn](http://www.unicorn-engine.org/) to emulate this little loop.

```python
from __future__ import print_function
from unicorn import *
from unicorn.x86_const import *

# code to be emulated
code = b"\x0f\xb6\x8c=\xe0\x00\x00\x00\xb8O\xec\xc4N\x80\xe9a\x0f\xbe\xc9\x0f\xaf\xc9\x83\xe9\x05\xf7\xe9\xc1\xfa\x03\x8b\xc2\xc1\xe8\x1f\x03\xd0k\xd2\x1a+\xca\x84\xc9y\x03\x80\xc1\x1a\x80\xc1aH\xff\xc7\x88\x8c=\xdf\x00\x00\x00H\x83\xff\x03\x7c\xbc"

# memory address where emulation starts
ADDRESS = 0x100000
STACK_ADDR = ADDRESS + 0x1000

print("Emulating x64 code")
try:
    # Initialize emulator in X86-64bit mode
    mu = Uc(UC_ARCH_X86, UC_MODE_64)

    # map 2MB memory for this emulation
    mu.mem_map(ADDRESS, 2 * 1024 * 1024)

    # write machine code to be emulated to memory
    mu.mem_write(ADDRESS, code)

    # Write string to 'stack'
    mu.mem_write(STACK_ADDR, b"ocl.exe\x00")

    # initialize machine registers
    mu.reg_write(UC_X86_REG_RDI, 0)
    mu.reg_write(UC_X86_REG_RBP, STACK_ADDR - 0xe0)

    print("Starting emulation")

    # emulate code in infinite time & unlimited instructions
    mu.emu_start(ADDRESS, ADDRESS + len(code))

    # now print out the stack string
    print("Emulation done")

    s = mu.mem_read(STACK_ADDR, 8)
    print(">>> string at 0x%X: %s" % (STACK_ADDR, s.decode('utf-8')))

except UcError as e:
    print("ERROR: %s" % e)
```

This outputs "jzm.exe".

The second arg is r11 + 1, which we see is set soon after the call to `GetModuleFileNameA`, after a call to `strrchr`, with "\\" passed. This is used to find the filename after all the directories. The +1 is to skip past the last backslash itself. We now know what the binary must be named to run this malware (without patching).

Now that we are past the checks we can analyze the actual behaviour of the malware. Glancing over it quickly we see calls to `WSAStartup`, `WSASocket`, `gethostbyname`, `htons`, and `connect`. Before the call to `gethostbyname` there is what looks like another, more complicated decoding loop. This is probably used to get the hostname to connect to, but could just be ignored by breaking on the call to `gethostbyname` and seeing what the result was.

After a connection is established there is a call to `sub_140001000`, which is passed the connected sokcets and eventually calls `CreateProcessA`. The _CommandLine_ argument here is `cmd`, so it looks like this is a rather simple reverse shell application.

### Questions
1. Although I could not run it, I determined it wouldn't run successfully based on the checks done at the start of `main`.
2. `main` can be identified by looking at the calls that come from `_start` that set ecx, rdx, and r8. Although rcx could be set instead of rcx, (depending on what the compiler thought was better), only rcx needs to be set, since the first argument to main, argc, is a four byte int.
3. The string "ocl.exe" is being stored on the stack, though later it is decoded to "jzm.exe".
4. To get around the filename check you can simply patche the call to `strncmp` to instead `xor eax, eax`, so that the success jump is always taken.
5. The filename of the running malware (with the leading paths removed) and "jzm.exe".
6. Yes, this function takes a single argument from rbx, which was where the return value from `WSASocket` was stored.
7. It's hard to tell what's just stored on the stack (since the stack pointer itself doesn't move except in the prologue and epilogue), but we do see many values being written to the stack just before the call, but the easiest way to see is to simply check the MSDN documentation, which indeed shows that 10 arguments are passed to `CreateProcessA`.
