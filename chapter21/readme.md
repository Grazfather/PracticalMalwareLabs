# Lab 21
Because I don't have a 64-bit Windows VM, I can only do these statically.

## Lab 20-1
### Basic Static Analysis
- **strings**: A few date formats, imports, and some weird padding string.
- **CFF Explorer**: Microsoft Visual C++ 8.0, 64 bit.
- **Dependency Walker**: Many imports from KERNEL32.DLL, plus some low-level socket imports from WS2_32.DLL (by ordinal).
- **PEview**: Normal section names and headers, with the addition of .pdata and .rsrc.
- **Resource Hacker** (Because of the presence of the .rsrc section): A single resource that contains the short XML blurb found with `strings`.

### Advanced Static Analysis
Popping the binary into IDA, we don't see `main`, and so have to start with `_start`. Knowing that `main` is passed and int and two pointers, we can simply find the call that sets args in this way. We find this at `sub_1400010c0`.

Here we see a call to `GetModuleFileNameA`, and a bit later a jump that goes to the end of the function. Lab 9-2 required that the malware was named "ocl.exe", so we will see if that's the case here. Looking just before the jump to bail out we see a call to `strncmp`. Going back up we can see where its args come from.

The first is stored on the stack at rbp + 0xe0, and we see that this address is written to a few times. The first at 0x140001157, where an int that happens to be all ASCII is written ("ocl."). There is another write right after with "exe". That would suggest that we need to name the binary "ocl.exe", but actually we can see later that that same local is written to again. Starting at 0x1400011b0 there is a little encoding block. Since I don't have a VM to run this, but didn't want to figure out what this decoded to, I used [unicorn](http://www.unicorn-engine.org/) to emulate this little loop.

```python
from __future__ import print_function
from unicorn import *
from unicorn.x86_const import *

# code to be emulated
code = b"\x0f\xb6\x8c=\xe0\x00\x00\x00\xb8O\xec\xc4N\x80\xe9a\x0f\xbe\xc9\x0f\xaf\xc9\x83\xe9\x05\xf7\xe9\xc1\xfa\x03\x8b\xc2\xc1\xe8\x1f\x03\xd0k\xd2\x1a+\xca\x84\xc9y\x03\x80\xc1\x1a\x80\xc1aH\xff\xc7\x88\x8c=\xdf\x00\x00\x00H\x83\xff\x03\x7c\xbc"

# memory address where emulation starts
ADDRESS = 0x100000
STACK_ADDR = ADDRESS + 0x1000

print("Emulating x64 code")
try:
    # Initialize emulator in X86-64bit mode
    mu = Uc(UC_ARCH_X86, UC_MODE_64)

    # map 2MB memory for this emulation
    mu.mem_map(ADDRESS, 2 * 1024 * 1024)

    # write machine code to be emulated to memory
    mu.mem_write(ADDRESS, code)

    # Write string to 'stack'
    mu.mem_write(STACK_ADDR, b"ocl.exe\x00")

    # initialize machine registers
    mu.reg_write(UC_X86_REG_RDI, 0)
    mu.reg_write(UC_X86_REG_RBP, STACK_ADDR - 0xe0)

    print("Starting emulation")

    # emulate code in infinite time & unlimited instructions
    mu.emu_start(ADDRESS, ADDRESS + len(code))

    # now print out the stack string
    print("Emulation done")

    s = mu.mem_read(STACK_ADDR, 8)
    print(">>> string at 0x%X: %s" % (STACK_ADDR, s.decode('utf-8')))

except UcError as e:
    print("ERROR: %s" % e)
```

This outputs "jzm.exe".

The second arg is r11 + 1, which we see is set soon after the call to `GetModuleFileNameA`, after a call to `strrchr`, with "\\" passed. This is used to find the filename after all the directories. The +1 is to skip past the last backslash itself. We now know what the binary must be named to run this malware (without patching).

Now that we are past the checks we can analyze the actual behaviour of the malware. Glancing over it quickly we see calls to `WSAStartup`, `WSASocket`, `gethostbyname`, `htons`, and `connect`. Before the call to `gethostbyname` there is what looks like another, more complicated decoding loop. This is probably used to get the hostname to connect to, but could just be ignored by breaking on the call to `gethostbyname` and seeing what the result was.

After a connection is established there is a call to `sub_140001000`, which is passed the connected sokcets and eventually calls `CreateProcessA`. The _CommandLine_ argument here is `cmd`, so it looks like this is a rather simple reverse shell application.

### Questions
1. Although I could not run it, I determined it wouldn't run successfully based on the checks done at the start of `main`.
2. `main` can be identified by looking at the calls that come from `_start` that set ecx, rdx, and r8. Although rcx could be set instead of rcx, (depending on what the compiler thought was better), only rcx needs to be set, since the first argument to main, argc, is a four byte int.
3. The string "ocl.exe" is being stored on the stack, though later it is decoded to "jzm.exe".
4. To get around the filename check you can simply patche the call to `strncmp` to instead `xor eax, eax`, so that the success jump is always taken.
5. The filename of the running malware (with the leading paths removed) and "jzm.exe".
6. Yes, this function takes a single argument from rbx, which was where the return value from `WSASocket` was stored.
7. It's hard to tell what's just stored on the stack (since the stack pointer itself doesn't move except in the prologue and epilogue), but we do see many values being written to the stack just before the call, but the easiest way to see is to simply check the MSDN documentation, which indeed shows that 10 arguments are passed to `CreateProcessA`.

## Lab 20-2
### Basic Static Analysis
- **strings**: Many duplicates, some XML, "Practical Malware Analysis %d", "Lab21-02x.dll", "Lab21-02x.exe", "Lab21-02.dll".
- **PEiD**: Nothing found *.
- **CFF Explorer**: Microsoft Visual C++ 8.0, 32 bit.
- **Dependency Walker**: Many imports from KERNEL32.DLL, including `FindResourceA` and `WriteProcessMemory`, `AdjustTokenPrivileges`, `LookupPrivilegeValueA`, `OpenProcessToken` from ADVAPI32.DLL, `ShellExecuteA` from SHELL32.DLL.
- **PEview**: Normal section names and headers, with the addition of .pdata and .rsrc.
- **Resource Hacker** (Because of the presence of the .rsrc section): Four resources:
  1. X64
  2. X64DLL
  3. X86
  4. Manifest: 1
  The former three all looking like standalone binaries. This suggests that this malware extracts and runs the appropriate malware depending on the victim's machine.

### Advanced Static Analysis
Looking at `_start` in IDA it isn't immediately clear where `main` is. Since I have an idea of the functionality, however, I can work _backwards_ to find it. I know that `FindResourceA` is imported, so I first looked for where it was referenced. There's just one, in `sub_401000`. This function also calls other resource-related functions, file-related funtions, `VirtualAlloc`, etc. This function clearly extracts a resource and writes it to disk. It looks like the name of the resource and the name of the target file are both passed in as arguments. The file path is determined with `GetSystemDirectoryA`.

Looking up references to `sub_401000` we see only three, but all from `sub_401260`. Checking xrefs to this function we see just one: `_start`. Looks like we found `main`. That was easy.

Digging into main we see some rather simple behaviour: `LoadLibraryA` and `GetProcAddress` are called a few times to get the address of a few functions: `EnumProcessModules`, `GetModuleBaseNameA`, `EnumProcesses`, and `IsWow64Process`. `IsWow64Process` is of particular interest: It is used by a 32-bit process to determine if it is running on a 64 bit OS. (Wow64 means 'Windows [32bit] on Windows 64bit'. Counter-intuitive, but nothing compared to where they place 64 bit DLLs.

Based on whether the host is 64 bit or not, a different set of resources are extracted and written to disk: For 64 bit, a new exe and DLL are extracted, and the executable is exexcuted using `ShellExecuteA`.

Whether or not the host is 64 bit, the 32 bit resource (which, turns out, is a DLL) is extracted. After this there is a loop that iterates over the process list generated with `EnumProcesses`, calling `sub_4011A0` for each, and although its call graph looks complicated, we can guess that it's just looking for the "explorer.exe" process (Since it contains this string). We can check that this is the case with a debugger easily, since it returns a boolean, so we can just set a breakpoint when it finally returns true. It looks like it's doing this by opening the provided process handle, calling `EnumProcessModules`, and then comparing the basename of the first module (which is the executable itself) with `GetModuleBaseNameA`.

Finally, with a handle to the explorer process, we see a familiar piece of code we've seen in a few other pieces of malware: The combination of `VirtualAllocEx`, `WriteProcessMemory`, the name of a DLL ("Lab21-02.dll in this case), `LoadLibraryA`, and `CreateRemoteThread` is unmistakeable: This is classic DLL injection. First, space for a string is allocated in the target process, then the name of the DLL is written into that buffer, and then a remote thread is created, with its entry point set to `LoadLibraryA` and its argument set to the DLL name.

Using Resource Hacker we can extract the extra resources. The two DLLs are likely identical in their behaviour, and the exe is likely a simpler version of the 32, where it does the DLL injection but doesn't bother extracting anything or checking whether it's running on 64 bit (since it must be). By 'cheating' I guessed that the 32 bit DLL has already been used, and sure enough, when comparing its hash to the others, it matches _Lab12-1.dll_.

### Questions
1. There are three different binaries in the resource section.
2. This malware is compiled for x86, but contains a 64 bit copy of itself in its resource section.
3. The malware uses `IsWow64Process` to determine if it is running on a 64 bit OS or not.
4. On a 64 bit environment the malware extracts a 64 bit executable and a 64-bit DLL and executes the first.
5. It drops a single DLL "Lab21-02.dll" in the system directory.
6. It drops "Lab21-02x.exe" and "Lab21-02x.dll" into _C:\Windows\SysWOW64\_, which is the 32-bit system directory on 64-bit Windows.
7. The malware uses `ShellExecuteA` to launch "Lab21-02x.exe".
8. It determines the type of windows running, and then injects the appropriate DLL into the running "explorer.exe" process.
