# Chapter 10 labs
## Lab 10-1
### Basic Static Analysis
- strings:
 - exe: "C:\Windows\System32\Lab10-01.sys", what looks like a basic set of menus, "Hello World!", "RegWriterApp Version 1.0" and "REGWRITEAPP".
 - sys: References to registry keys, some version information, "c:\winddk\7600.16385.1\src\general\regwriter\wdm\sys\objfre_wxp_x86\i386\sioctl.pdb", and some imports.
- PEiD:
 - exe: Unpacked, Microsoft Visual C++ 6.0.
 - sys: Will not open
- Dependency Walker:
 - exe: Imports 'ControlServer', 'CreateServiceA', 'OpenSCManagerA', 'OpenServiceA', and 'StartServiceA' from ADVAPI32.DLL, as well as a bunch from KERNEL32.DLL that query environmental variables, get various handles, and 'LoadLibraryA'.
 - sys: Only imports 'KeTickCount', 'RtlCreateRegistryKey', and 'RtlWriteRegistryValue' from NTOSKRNL.EXE.
- PEview:
 - exe: Normal section names and headers.
 - sys: Includes a '.rsrc' section as well as a 'INIT' section.

### Advanced Static Analysis
#### Executable
Loading the exe into IDA we see that it is remarkably simple: It just tries to install a driver located at "C:\Windows\System32\Lab10-10.sys" using the calls 'OpenSCManagerA', 'CreateServiceA', 'OpenServiceA', and 'StartServiceA'. It then sends a control code to this service using 'ControlService'. For the call to 'CreateServiceA' the argument _dwServiceType_ is 1, for SERVICE_KERNEL_DRIVER, and the argument _dwStartType_ is 3 for SERVICE_DEMAND_START, which means the service begins when called from 'StartService'. _lpServiceName_ and _lpDisplayName_ are "Lab10-01". If 'CreateServiceA' fails it's assumed that the service is already installed, so it calls 'OpenServiceA' specifying the same name. The program finishes up by calling 'ControlService', sending a _dwControl_ value of 1, representing SERVICE_CONTROL_STOP.

#### Driver
Loading the driver into IDA we don't see anything too interesting: It appears to call sub_10920 and then jumps to loc_10906. sub_10920 seems uninteresting: It reads a global variable dword_10880 and if it's equal to 0xBB40E64E then it returns. If it's not, then it reads from 'KeTickCount' and XORs dword_108880 with the value read, and then returns. loc_10906 appears to just write an address (address of loc_10486) to the address passed in arg_0 (offset by 0x34). If we look at loc_10486 we see what looks to be the main payload of the malware.

### Advanced Dynamic Analysis
Because I need to stop the kernel in the short period of time where the driver is installed and running, I need to use a debugger on the target machine and set a breakpoint before we stop and unload the driver. Loading Lab10-01.exe into WinDBG I can set a bp just before 'ControlService' with `bp 401080`. At this point in time I can start connecting WinDBG on my Windows 7 host through a pipe to the XP machine on VirtualBox. I needed to set up symbols, which I first downloaded using `symchk`:

    symchk /r c:\windows\system32 /s SRV*e:\websymbols\*http://msdl.microsoft.com/download/symbols

And then configured WinDBG to use them:

    .sympath SRV*e:\websymbols*http://msdl.microsoft.com/download/symbols
    .symfix
    .reload

Once connected I viewed where the driver was loaded with `!drvobj Lab10-01` and then superimposed the _\_DRIVER_OBJECT_ structure over the memory there to see the members. At offset 0x34 we see the member _DriverUnload_. Looking back at my static analysis I see that the driver wrote the address of loc_10486 to the offset 0x34 of arg_0. It looks like arg_0 provides the base of the driver, and this malware is putting its payload in the _DriverUnload_ callback. This makes sense of why they would load a driver and then immediately stop it with 'ControlService'. Placing a breakpoint at this address and resuming the OS we can jump to the target machine's debugger and continue. It will immediately freeze as the unload function is called. Back on the host machine we can now step through the function using `p`. Stepping through doesn't look too interesting: It calls four functions, but WinDBG doesn't seem to resolve the name of them and doesn't show what's at the offsets that its pushing.

Rebasing the driver in IDA so that it starts at the address given to us by `!drvobj Lab10-01` we see that loc_10906 does indeed set the _DriverUnload_ callback to the code that is executed after 'ControlService' is called with _dwControl_ = SERVICE_CONTROL_STOP. Looking at this location we see it is very straight-forward: It uses 'RtlCreateRegistryKey' and tries to open some keys:
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile"

...and then write a DWORD of value 0 to a key named "EnableFirewall" to the last two using 'RtlWriteRegistryValue'. It looks like this malware tries to circumvent using syscalls (and some simple detection) to write to the registry and tries to disable the Windows firewall covertly.

### Questions
1. This process doesn't appear to make any changes to the registry at all (unless you include RNG/Seed) according to Procmon, but seems to do so by loading a driver to write to the registry from within the kernel to avoid making any telling syscalls.
2. We can see what the driver is doing in response to this call by setting a breakpoint on the target machine, just before the call to 'ControlService'. Once the program is stopped at this point we can use the host machine to query the OS to find the malicious driver, and then set a kernel breakpoint at its unload callback. Finally, we can resume the operating system, then resume the program to immediately hit the kernel breakpoint we just set. When the driver is loaded it sets its own _DriverUnload_ callback to the malware's payload. When 'ControlService' is called, it is called to stop the driver, thereby jumping to this code.
3. This program disables the Windows firewall by writing two registry keys while avoiding making any 'RegSetValue' syscall.

## Lab 10-2
### Basic Static Analysis
- strings: "C:\Windows\System32\Mlwx486.sys", "c:\winddk\7600.16385.1\syrc\general\rootkit\wdm\sys\objfre_wxp_x86\i386\sioctl.pdb", "Windows (R) Win 7 DDK provider", "Windows (R) Win 7 DDK driver", "SIOCTL.sys", plus some miscellaneous strings and imports.
- PEiD: Unpacked, Microsoft Visual C++ 6.0.
- Dependency Walker: Imports 'CloseServiceHandle', 'CreateServiceA', 'OpenSCManagerA', and 'StartServiceA' from ADVAPI32.DLL, as well as a bunch from KERNEL32.DLL that query environmental variables, get various handles, and 'FindResourceA', 'LoadResource' and 'SizeofResource'.
- PEview: Normal section names and headers, but includes a .rsrc section.
- Resource Hacker (Because of the presence of 'FindResourceA' and the .rsrc section): A single resource of type 'FILE'. It appears to be another PE.

Running the same analysis on this resource (after saving it as a standalone binary):
- strings: A subset of the strings found in the whole binary, including the mentions of the sys file and the Win 7 DDK strings.
- PEiD: "Nothing found *"
- Dependency Walker: Imports 'KeTickCount', 'MmGetSystemRoutineAddress', 'NtQueryDirectoryFile', 'RtlCompareMemory', and 'RtlInitUnicodeString' from NTOSKRNL.EXE.
- PEView: Includes a '.rsrc' section as well as a 'INIT' section.

### Advanced Static Analysis
Loading exe into IDA, it appears to read the binary blob from the resource section and then write it to the filesystem as "C:\Windows\System32\Mlwx486.sys". It then loads this driver and starts it using 'OpenSCManagerA', 'CreateServiceA' (Service name "486 WS Driver"), 'StartServiceA', and then 'CloseServiceHandle'.

Loading the driver we extracted from the resource section into IDA, it appears to convert two strings, "NtQueryDirectoryFile" (Although IDA only recognized the first character as a null-terminated ASCII strings "N"), and "KeServiceDescriptorTable" to unicode, and then calls 'MmGetSystemRoutineAddress' twice with these two strings as arguments. It then appears to search at the start of _KeServiceDescriptorTable_ for a pointer to 'NtQueryDirectoryFile', and once is it found it saves this address, and then patches the pointer with the address of loc_10486.

### Basic Dynamic Analysis
Running the malware with procmon running shows the expected calls to 'CreateFileA' and 'WriteFile', but when we look for the file it doesn't appear to be there. The calls to start the service do not show up because they are not system calls. Restoring the VM to a previous snapshot, we can run it again, but this time step through to see what is happening. Setting a breakpoint at 0x401070 (after CloseHandle) we can indeed find the file in the filesystem. Mousing over the file we see that it has taken on the description, "Sample IOCTL Driver" and the company "Windows (R) Win 7 DDK provider", which are both strings we saw earlier. Stepping through and refreshing the directory listen we see that the sys file seems to disappear right after it's started with a call to 'StartServiceA'. It looks like the driver is making an effort to hide itself.

### Advanced Dynamic Analysis
Opening WinDBG on my host machine and halting my target machine, I can query for installed drivers using `!object \Driver` and I can see that there exists a driver called "486 WS Driver' at 0x89A18558. Because the driver is still in memory, it's unlikely it was deleted from disk, and it's more likely that it's hiding. We can also see the loaded modules using `lm` which shows the module with its original filename "Mlwx486.sys" as well as where it's mapped in memory. In my case it's mapped from 0xF7A88000 to 0xF7A88D80. Dumping the _KeServiceDescriptorTable_ with `dd dwo(KeServiceDescriptorTable)` we see one address out of place: While most the others are in the 0x80XXXXXX range, this one is at 0xF7A88486, right in our new module's memory space. This is obviously the patched routine we expected from our static analysis. We can place a breakpoint on this function and then trigger it by running `dir` from the cmd prompt on the target machine.

At the breakpoint we can see we are indeed running the code we saw at loc_10486 in IDA. The first thing it appears to do is call 'NtQueryDirectoryFile', which makes sense, since it is hooking this function and presumably wants to still provide most of its functionality. After the call, it compares ebp+0x24 with 0x3, the return value from the previous call to zero, and finally ebp+0x28 to zero, all jumping to the same location if the test not equal. The parameters passed in at ebp+0x24 and ebp+0x28 correspond to _FileInformationClass_ and _ReturnSingleEntry_, respectively. Since in most cases it looks like this hook function does nothing, we can create a conditional breakpoint so that we only halt the OS on 'interesting' calls to 'NtQueryDirectoryFile'. We can do this with `bp f7a88486 ".if dwo(esp+0x24)==0 {} .else {gc}"` which will test the _ReturnSingleEntry_ argument and only halt if that argument is false. I found it easier, however, to just set a breakpoint later on in the function, after it has passed all the checks. I did this with `bp f7a884c9`.

Stepping through, we can examine the arguments that are passed to the second function they are calling ('RtlCompareMemory'). It looks like each time this function is called, one of the arguments is a file in the directory I called `dir` from, the other is unicode string "Mlwx", and the last is the value 8 (and "Mlwx" is 8 bytes because it's unicode). Since we know this will only be called if _FileInformationClass_ is 3, we know that the _FileInformation_ pointer is of type 'FILE_ID_BOTH_DIR_INFORMATION'. The address at offset 0x5E from esi (which is a copy of this _FileInformation_ argument) is indeed where the _FileName_ member starts (in band).

So we know what this hook is checking for, and since we know that the sys file didn't show up in a directory listing, we can guess what it's doing here: It's hiding any file that starts with "Mlwx". By creating a directory with only a few files, one of which that starts with "Mlwx" we can see what happens when this case is met. Stepping through we see that it iterates over a list of all the files in the directory by getting the first member _NextEntryOffset_ and adding it to the current entry's address to get the address of the next entry. If the current entry's filename starts with "Mlwx", then the _previous_ entry's _NextEntryOffset_ is incremented by the _current_ entry's _NextEntryOffset_, or set to zero is the current entry is the last entry. This effectively modifies the list so that it 'jumps over' any entry with the problematic filename. If the offset is zero then it is assumed the list is finished and the work is done. Before the loop jumps to the top, it tests bl, which seems to be a flag signifying if a matching file was found. If this flag is not set, then the current (now previous) entry is stored in edi. This is done in case there are multiple files that start with "Mlwx": Without this check we can update the wrong 'previous' entry, allowing some "Mlwx" files to be seen.

### Questions
1. This program creates a file called "Mlwx486.sys" in "C:\Windows\System32\" by extracting it from its resource section. It hides it from being seen by hooking the 'NtQueryDirectoryFile' function and preventing any file that starts with "Mlwx486.sys" from showing up in any listing.
2. Yes. The kernel component is the sys file it writes. It starts this module and the module works to keep itself hidden.
3. This program install a kernel module that hides itself and any other file that starts with "Mlwx" by hooking the kernel function 'NtQueryDirectoryFile'.
