# Chapter 10 labs
## Lab 10-1
### Basic Static Analysis
- strings:
 - exe: "C:\Windows\System32\Lab10-01.sys", what looks like a basic set of menus, "Hello World!", "RegWriterApp Version 1.0" and "REGWRITEAPP".
 - sys: References to registry keys, some version information, "c:\winddk\7600.16385.1\src\general\regwriter\wdm\sys\objfre_wxp_x86\i386\sioctl.pdb", and some imports.
- PEiD:
 - exe: Unpacked, Microsoft Visual C++ 6.0.
 - sys: Will not open
- Dependency Walker:
 - exe: Imports 'ControlServer', 'CreateServiceA', 'OpenSCManagerA', 'OpenServiceA', and 'StartServiceA' from ADVAPI32.DLL, as well as a bunch from KERNEL32.DLL that query environmental variables, get various handles, and 'LoadLibraryA'.
 - sys: Only imports 'KeTickCount', 'RtlCreateRegistryKey', and 'RtlWriteRegistryValue' from NTOSKRNL.EXE.
- PEview:
 - exe: Normal section names and headers.
 - sys: Includes a '.rsrc' section as well as a 'INIT' section.

### Advanced Static Analysis
#### Executable
Loading the exe into IDA we see that it is remarkably simple: It just tries to install a driver located at "C:\Windows\System32\Lab10-10.sys" using the calls 'OpenSCManagerA', 'CreateServiceA', 'OpenServiceA', and 'StartServiceA'. It then sends a control code to this service using 'ControlService'. For the call to 'CreateServiceA' the argument _dwServiceType_ is 1, for SERVICE_KERNEL_DRIVER, and the argument _dwStartType_ is 3 for SERVICE_DEMAND_START, which means the service begins when called from 'StartService'. _lpServiceName_ and _lpDisplayName_ are "Lab10-01". If 'CreateServiceA' fails it's assumed that the service is already installed, so it calls 'OpenServiceA' specifying the same name. The program finishes up by calling 'ControlService', sending a _dwControl_ value of 1, representing SERVICE_CONTROL_STOP.

#### Driver
Loading the driver into IDA we don't see anything too interesting: It appears to call sub_10920 and then jumps to loc_10906. sub_10920 seems uninteresting: It reads a global variable dword_10880 and if it's equal to 0xBB40E64E then it returns. If it's not, then it reads from 'KeTickCount' and XORs dword_108880 with the value read, and then returns. loc_10906 appears to just write an address (address of loc_10486) to the address passed in arg_0 (offset by 0x34). If we look at loc_10486 we see what looks to be the main payload of the malware.

### Advanced Dynamic Analysis
Because I need to stop the kernel in the short period of time where the driver is installed and running, I need to use a debugger on the target machine and set a breakpoint before we stop and unload the driver. Loading Lab10-01.exe into WinDBG I can set a bp just before 'ControlService' with `bp 401080`. At this point in time I can start connecting WinDBG on my Windows 7 host through a pipe to the XP machine on VirtualBox. I needed to set up symbols, which I first downloaded using `symchk`:

    symchk /r c:\windows\system32 /s SRV*e:\websymbols\*http://msdl.microsoft.com/download/symbols

And then configured WinDBG to use them:

    .sympath SRV*e:\websymbols*http://msdl.microsoft.com/download/symbols
    .symfix
    .reload

Once connected I viewed where the driver was loaded with `!drvobj Lab10-01` and then superimposed the _\_DRIVER_OBJECT_ structure over the memory there to see the members. At offset 0x34 we see the member _DriverUnload_. Looking back at my static analysis I see that the driver wrote the address of loc_10486 to the offset 0x34 of arg_0. It looks like arg_0 provides the base of the driver, and this malware is putting its payload in the _DriverUnload_ callback. This makes sense of why they would load a driver and then immediately stop it with 'ControlService'. Placing a breakpoint at this address and resuming the OS we can jump to the target machine's debugger and continue. It will immediately freeze as the unload function is called. Back on the host machine we can now step through the function using `p`. Stepping through doesn't look too interesting: It calls four functions, but WinDBG doesn't seem to resolve the name of them and doesn't show what's at the offsets that its pushing.

Rebasing the driver in IDA so that it starts at the address given to us by `!drvobj Lab10-01` we see that loc_10906 does indeed set the _DriverUnload_ callback to the code that is executed after 'ControlService' is called with _dwControl_ = SERVICE_CONTROL_STOP. Looking at this location we see it is very straight-forward: It uses 'RtlCreateRegistryKey' and tries to open some keys:
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile"

...and then write a DWORD of value 0 to a key named "EnableFirewall" to the last two using 'RtlWriteRegistryValue'. It looks like this malware tries to circumvent using syscalls (and some simple detection) to write to the registry and tries to disable the Windows firewall covertly.

### Questions
1. This process doesn't appear to make any changes to the registry at all (unless you include RNG/Seed) according to Procmon, but seems to do so by loading a driver to write to the registry from within the kernel to avoid making any telling syscalls.
2. We can see what the driver is doing in response to this call by setting a breakpoint on the target machine, just before the call to 'ControlService'. Once the program is stopped at this point we can use the host machine to query the OS to find the malicious driver, and then set a kernel breakpoint at its unload callback. Finally, we can resume the operating system, then resume the program to immediately hit the kernel breakpoint we just set. When the driver is loaded it sets its own _DriverUnload_ callback to the malware's payload. When 'ControlService' is called, it is called to stop the driver, thereby jumping to this code.
3. This program disables the Windows firewall by writing two registry keys while avoiding making any 'RegSetValue' syscall.

