# Chapter 10 labs
## Lab 10-1
### Basic Static Analysis
- **strings**:
 - **exe**: "C:\Windows\System32\Lab10-01.sys", what looks like a basic set of menus, "Hello World!", "RegWriterApp Version 1.0" and "REGWRITEAPP".
 - **sys**: References to registry keys, some version information, "c:\winddk\7600.16385.1\src\general\regwriter\wdm\sys\objfre_wxp_x86\i386\sioctl.pdb", and some imports.
- **PEiD**:
 - **exe**: Unpacked, Microsoft Visual C++ 6.0.
 - **sys**: Will not open
- **Dependency Walker**:
 - **exe**: Imports 'ControlService', 'CreateServiceA', 'OpenSCManagerA', 'OpenServiceA', and 'StartServiceA' from ADVAPI32.DLL, as well as a bunch from KERNEL32.DLL that query environmental variables, get various handles, and 'LoadLibraryA'.
 - **sys**: Only imports 'KeTickCount', 'RtlCreateRegistryKey', and 'RtlWriteRegistryValue' from NTOSKRNL.EXE.
- **PEview**:
 - **exe**: Normal section names and headers.
 - **sys**: Includes a '.rsrc' section as well as a 'INIT' section.

### Advanced Static Analysis
#### Executable
Loading the exe into IDA we see that it is remarkably simple: It just tries to install a driver located at "C:\Windows\System32\Lab10-10.sys" using the calls 'OpenSCManagerA', 'CreateServiceA', 'OpenServiceA', and 'StartServiceA'. It then sends a control code to this service using 'ControlService'. For the call to 'CreateServiceA' the argument _dwServiceType_ is 1, for SERVICE_KERNEL_DRIVER, and the argument _dwStartType_ is 3 for SERVICE_DEMAND_START, which means the service begins when called from 'StartService'. _lpServiceName_ and _lpDisplayName_ are "Lab10-01". If 'CreateServiceA' fails it's assumed that the service is already installed, so it calls 'OpenServiceA' specifying the same name. The program finishes up by calling 'ControlService', sending a _dwControl_ value of 1, representing SERVICE_CONTROL_STOP.

#### Driver
Loading the driver into IDA we don't see anything too interesting: It appears to call sub_10920 and then jumps to loc_10906. sub_10920 seems uninteresting: It reads a global variable dword_10880 and if it's equal to 0xBB40E64E then it returns. If it's not, then it reads from 'KeTickCount' and XORs dword_108880 with the value read, and then returns. loc_10906 appears to just write an address (address of loc_10486) to the address passed in arg_0 (offset by 0x34). If we look at loc_10486 we see what looks to be the main payload of the malware.

### Advanced Dynamic Analysis
Because I need to stop the kernel in the short period of time where the driver is installed and running, I need to use a debugger on the target machine and set a breakpoint before we stop and unload the driver. Loading Lab10-01.exe into WinDBG I can set a bp just before 'ControlService' with `bp 401080`. At this point in time I can start connecting WinDBG on my Windows 7 host through a pipe to the XP machine on VirtualBox. I needed to set up symbols, which I first downloaded using `symchk`:

    symchk /r c:\windows\system32 /s SRV*e:\websymbols\*http://msdl.microsoft.com/download/symbols

And then configured WinDBG to use them:

    .sympath SRV*e:\websymbols*http://msdl.microsoft.com/download/symbols
    .symfix
    .reload

Once connected I viewed where the driver was loaded with `!drvobj Lab10-01` and then superimposed the _\_DRIVER_OBJECT_ structure over the memory there to see the members. At offset 0x34 we see the member _DriverUnload_. Looking back at my static analysis I see that the driver wrote the address of loc_10486 to the offset 0x34 of arg_0. It looks like arg_0 provides the base of the driver, and this malware is putting its payload in the _DriverUnload_ callback. This makes sense of why they would load a driver and then immediately stop it with 'ControlService'. Placing a breakpoint at this address and resuming the OS we can jump to the target machine's debugger and continue. It will immediately freeze as the unload function is called. Back on the host machine we can now step through the function using `p`. Stepping through doesn't look too interesting: It calls four functions, but WinDBG doesn't seem to resolve the name of them and doesn't show what's at the offsets that its pushing.

Rebasing the driver in IDA so that it starts at the address given to us by `!drvobj Lab10-01` we see that loc_10906 does indeed set the _DriverUnload_ callback to the code that is executed after 'ControlService' is called with _dwControl_ = SERVICE_CONTROL_STOP. Looking at this location we see it is very straight-forward: It uses 'RtlCreateRegistryKey' and tries to open some keys:
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile"
 * "\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile"

...and then write a DWORD of value 0 to a key named "EnableFirewall" to the last two using 'RtlWriteRegistryValue'. It looks like this malware tries to circumvent using syscalls (and some simple detection) to write to the registry and tries to disable the Windows firewall covertly.

### Questions
1. This process doesn't appear to make any changes to the registry at all (unless you include RNG/Seed) according to Procmon, but seems to do so by loading a driver to write to the registry from within the kernel to avoid making any telling syscalls.
2. We can see what the driver is doing in response to this call by setting a breakpoint on the target machine, just before the call to 'ControlService'. Once the program is stopped at this point we can use the host machine to query the OS to find the malicious driver, and then set a kernel breakpoint at its unload callback. Finally, we can resume the operating system, then resume the program to immediately hit the kernel breakpoint we just set. When the driver is loaded it sets its own _DriverUnload_ callback to the malware's payload. When 'ControlService' is called, it is called to stop the driver, thereby jumping to this code.
3. This program disables the Windows firewall by writing two registry keys while avoiding making any 'RegSetValue' syscall.

## Lab 10-2
### Basic Static Analysis
- **strings**: "C:\Windows\System32\Mlwx486.sys", "c:\winddk\7600.16385.1\syrc\general\rootkit\wdm\sys\objfre_wxp_x86\i386\sioctl.pdb", "Windows (R) Win 7 DDK provider", "Windows (R) Win 7 DDK driver", "SIOCTL.sys", plus some miscellaneous strings and imports.
- **PEiD**: Unpacked, Microsoft Visual C++ 6.0.
- **Dependency Walker**: Imports 'CloseServiceHandle', 'CreateServiceA', 'OpenSCManagerA', and 'StartServiceA' from ADVAPI32.DLL, as well as a bunch from KERNEL32.DLL that query environmental variables, get various handles, and 'FindResourceA', 'LoadResource' and 'SizeofResource'.
- **PEview**: Normal section names and headers, but includes a .rsrc section.
- **Resource Hacker** (Because of the presence of 'FindResourceA' and the .rsrc section): A single resource of type 'FILE'. It appears to be another PE.

Running the same analysis on this resource (after saving it as a standalone binary):
- **strings**: A subset of the strings found in the whole binary, including the mentions of the sys file and the Win 7 DDK strings.
- **PEiD**: "Nothing found *"
- **Dependency Walker**: Imports 'KeTickCount', 'MmGetSystemRoutineAddress', 'NtQueryDirectoryFile', 'RtlCompareMemory', and 'RtlInitUnicodeString' from NTOSKRNL.EXE.
- **PEview**: Includes a '.rsrc' section as well as a 'INIT' section.

### Advanced Static Analysis
Loading exe into IDA, it appears to read the binary blob from the resource section and then write it to the filesystem as "C:\Windows\System32\Mlwx486.sys". It then loads this driver and starts it using 'OpenSCManagerA', 'CreateServiceA' (Service name "486 WS Driver"), 'StartServiceA', and then 'CloseServiceHandle'.

Loading the driver we extracted from the resource section into IDA, it appears to convert two strings, "NtQueryDirectoryFile" (Although IDA only recognized the first character as a null-terminated ASCII strings "N"), and "KeServiceDescriptorTable" to unicode, and then calls 'MmGetSystemRoutineAddress' twice with these two strings as arguments. It then appears to search at the start of _KeServiceDescriptorTable_ for a pointer to 'NtQueryDirectoryFile', and once is it found it saves this address, and then patches the pointer with the address of loc_10486.

### Basic Dynamic Analysis
Running the malware with procmon running shows the expected calls to 'CreateFileA' and 'WriteFile', but when we look for the file it doesn't appear to be there. The calls to start the service do not show up because they are not system calls. Restoring the VM to a previous snapshot, we can run it again, but this time step through to see what is happening. Setting a breakpoint at 0x401070 (after CloseHandle) we can indeed find the file in the filesystem. Mousing over the file we see that it has taken on the description, "Sample IOCTL Driver" and the company "Windows (R) Win 7 DDK provider", which are both strings we saw earlier. Stepping through and refreshing the directory listen we see that the sys file seems to disappear right after it's started with a call to 'StartServiceA'. It looks like the driver is making an effort to hide itself.

### Advanced Dynamic Analysis
Opening WinDBG on my host machine and halting my target machine, I can query for installed drivers using `!object \Driver` and I can see that there exists a driver called "486 WS Driver' at 0x89A18558. Because the driver is still in memory, it's unlikely it was deleted from disk, and it's more likely that it's hiding. We can also see the loaded modules using `lm` which shows the module with its original filename "Mlwx486.sys" as well as where it's mapped in memory. In my case it's mapped from 0xF7A88000 to 0xF7A88D80. Dumping the _KeServiceDescriptorTable_ with `dd dwo(KeServiceDescriptorTable)` we see one address out of place: While most the others are in the 0x80XXXXXX range, this one is at 0xF7A88486, right in our new module's memory space. This is obviously the patched routine we expected from our static analysis. We can place a breakpoint on this function and then trigger it by running `dir` from the cmd prompt on the target machine.

At the breakpoint we can see we are indeed running the code we saw at loc_10486 in IDA. The first thing it appears to do is call 'NtQueryDirectoryFile', which makes sense, since it is hooking this function and presumably wants to still provide most of its functionality. After the call, it compares ebp+0x24 with 0x3, the return value from the previous call to zero, and finally ebp+0x28 to zero, all jumping to the same location if the test not equal. The parameters passed in at ebp+0x24 and ebp+0x28 correspond to _FileInformationClass_ and _ReturnSingleEntry_, respectively. Since in most cases it looks like this hook function does nothing, we can create a conditional breakpoint so that we only halt the OS on 'interesting' calls to 'NtQueryDirectoryFile'. We can do this with `bp f7a88486 ".if dwo(esp+0x24)==0 {} .else {gc}"` which will test the _ReturnSingleEntry_ argument and only halt if that argument is false. I found it easier, however, to just set a breakpoint later on in the function, after it has passed all the checks. I did this with `bp f7a884c9`.

Stepping through, we can examine the arguments that are passed to the second function they are calling ('RtlCompareMemory'). It looks like each time this function is called, one of the arguments is a file in the directory I called `dir` from, the other is unicode string "Mlwx", and the last is the value 8 (and "Mlwx" is 8 bytes because it's unicode). Since we know this will only be called if _FileInformationClass_ is 3, we know that the _FileInformation_ pointer is of type 'FILE_ID_BOTH_DIR_INFORMATION'. The address at offset 0x5E from esi (which is a copy of this _FileInformation_ argument) is indeed where the _FileName_ member starts (in band).

So we know what this hook is checking for, and since we know that the sys file didn't show up in a directory listing, we can guess what it's doing here: It's hiding any file that starts with "Mlwx". By creating a directory with only a few files, one of which that starts with "Mlwx" we can see what happens when this case is met. Stepping through we see that it iterates over a list of all the files in the directory by getting the first member _NextEntryOffset_ and adding it to the current entry's address to get the address of the next entry. If the current entry's filename starts with "Mlwx", then the _previous_ entry's _NextEntryOffset_ is incremented by the _current_ entry's _NextEntryOffset_, or set to zero is the current entry is the last entry. This effectively modifies the list so that it 'jumps over' any entry with the problematic filename. If the offset is zero then it is assumed the list is finished and the work is done. Before the loop jumps to the top, it tests bl, which seems to be a flag signifying if a matching file was found. If this flag is not set, then the current (now previous) entry is stored in edi. This is done in case there are multiple files that start with "Mlwx": Without this check we can update the wrong 'previous' entry, allowing some "Mlwx" files to be seen.

### Questions
1. This program creates a file called "Mlwx486.sys" in "C:\Windows\System32\" by extracting it from its resource section. It hides it from being seen by hooking the 'NtQueryDirectoryFile' function and preventing any file that starts with "Mlwx486.sys" from showing up in any listing.
2. Yes. The kernel component is the sys file it writes. It starts this module and the module works to keep itself hidden.
3. This program installs a kernel module that hides itself and any other file that starts with "Mlwx" by hooking the kernel function 'NtQueryDirectoryFile'.

## Lab 10-3
### Basic Static Analysis
- strings:
 - exe: "http://www.malwareanalysisbook.com/ad.html", "\\.\ProcHelper", "Process Helper", "C:\Windows\System32\Lab10-03.sys", plus the usual set of imports.
 - sys: "Windows (R) Win 7 DDK provider" and "Windows (R) Win 7 DDK driver".
- PEiD:
 - exe: Unpacked, Microsoft Visual C++ 6.0.
 - sys: Will not open (Nothing found *).
- Dependency Walker:
 - exe: Imports 'CloseServiceHandle', 'CreateServiceA', 'OpenSCManagerA', and 'StartServiceA' from ADVAPI32.DLL, the normal set from KERNEL32.DLL, as well as 'CoCreateInstance', 'OleInitialize', 'OleUninitialize' from OLE32.DLL and 'SysAllocString' and 'VariantInit' from OLEAUT32.DLL.
 - sys: Imports 'IoCreateDevice', 'IoCreateSymbolicLink', 'IoDeleteDevice', 'IoDeleteSymbolicLink', 'IofCompleteRequest', 'KeTickCount', and 'RtlInitUnicodeString' from NTOSKRNL.EXE.
- PEview:
 - exe: Normal section names and headers.
 - sys: Includes a '.rsrc' section, a 'PAGE' section, as well as a 'INIT' section.

### Basic Dynamic Analysis
Running the malware, after placing the sys file in the system32 directory, doesn't look too interesting in procmon, but Internet Explorer pops up trying to load the ad URL we saw from strings. It looks like the browser is reopened periodically with the same address. Since we saw service-related import, and the string "Process Helper", on a hunch we can use `sc` to look for a service with that name. The process itself cannot be found in the task manager.

    C:\Documents and Settings\Debugger\My Documents\Practical Malware Analysis Labs\BinaryCollection\Chapter_10L>sc query "Process Helper"
    
    SERVICE_NAME: Process Helper
            TYPE               : 1  KERNEL_DRIVER
            STATE              : 4  RUNNING
                                    (STOPPABLE,NOT_PAUSABLE,IGNORES_SHUTDOWN)
            WIN32_EXIT_CODE    : 0  (0x0)
            SERVICE_EXIT_CODE  : 0  (0x0)
            CHECKPOINT         : 0x0
            WAIT_HINT          : 0x0

Unfortunately, trying to stop the service doesn't work (as it likely ignores those signals).

### Advanced Static Analysis
The executable itself seems very simple. It attempts to create and start a service using the accompanying sys file. If this is done successfully, then it opens "\\.\ProcHelper" (which is presumably created by the driver) and calls 'DeviceIoControl' on the returned handle with the _dwIoControlCode_ set to 0xABCDEF01 and both _lpOutBuffer_ and _lpInBuffer_ set to NULL. After this is done it calls 'OleInitialize', 'CoCreateInstance', 'VariantInit' and 'SysAllocString' (with the argument being the URL for the ad), and then finally enters an indefinite loop, calling a function that was set up in the ppv pointer when creating the COM object. This is almost definitely what keeps making the ad show up. The driver must be used to hide the process so that the process can continue to show us the add while the user has no apparent way to kill it.

Looking up the CLSID and IID we see they are '0002DF01-0000-0000-C000-000000000046' and 'D30C1661-CDAF-11D0-8A3E-00C04FC9E26E', respectively (the same as we saw in lab 7-2). These correspond to Internet Explorer and _IWebBrowser2_. As in lab 7-2, this program is calling the function at address 0x2C bytes into the _ppv_ which corresponds to the 'Navigate' function, so this is clearly how the malware is getting the page to show.

Understanding what the executable does, we will move on to the driver. Looking at the start function we see that it creates a device called "\Device\ProcHelper" using 'IoCreateDevice'. It also creates a symbolic link to the device named "\DosDevices\ProcHelper" using 'IoCreateSymbolicLink'. After 'IoCreateDevice' is called, a struct pointed to by esi is written to with different offsets that have code at them. loc_10606 is written to the 0x38th and 0x40th byte, loc_10666 is written to the 0x70th byte, and loc_1062A is written to the 0x34th byte. This is probably setting up its function pointers.

### Advanced Dynamic Analysis
Re-running the malware and then halting the kernel with WinDBG we can query the running drivers using `!devobj ProcHelper` which shows us the _DriverObject_ is at 0x89b013b8. Dumping the struct contents with `dt nt!_DRIVER_OBJECT 89b013b8` we see the offsets written to earlier correspond to _DriverUnload_ at 0x34, and a table of functions, _MajorFunction_, starts at 0x38. Dumping the _MajorFunction_ table with `dd 0x89b013b8+0x38` we can see that most pointers point to 0x804fd101, but there are the three that were set explicitly as we saw in IDA. Disassembling at these addresses confirm they correspond to the code offsets we saw earlier. Using `ln 0x804fd101` we see that most the function pointers point to a function called 'IopInvalidDeviceRequest'. Looking up the _DriverObject_ the description for the _MajorFunction_ array points to the "IRP Major Function Codes" which correspond to the index in the array. They are listed alphabetically and their value isn't presented on MSDN, but it's mentioned that they are defined in 'wdm.h'. Looking in 'wdm.h' we see that the offsets that the driver wrote to correspond to 'Create', 'Close', and 'DeviceIoControl'.

We can now name each of those offsets to the function they serve: loc_1062A is 'DriverUnload', loc_10606 is 'Create' and 'Close', and loc_10666 is 'DeviceIoControl'. Looking at our 'Create' and 'Close' handler we see that it just calls 'IofCompleteRequest' and then returns. 'DriverUnload' deletes the symbolic link to "\Device\ProcHelper" and then deletes the device using 'IoDeleteDevice'. 'DeviceIoControl' is the most interesting as we know that the malware makes this call into the driver. The 'DeviceIoControl' handler calls 'IoGetCurrentProcess' and then puts whatever is at 0ffset 0x8C into ecx and whatever is at 0x88 into edx. Looking at the return type (pointer to _EPROCESS_) we see those offsets correspond to LIST_ENTRYs  for the _ActiveProcessLinks_ member: They are the next and previous pointers in a doubly linked list of active processes. With these two pointers, the driver gets the previous and next process and fixes their next and previous links to jump over the current process. Because the operating system probably keep track of some 'head' process and then iterates over the linked list to enumerate all active processes, doing this makes the process invisible to the kernel, effectively keeping it from showing up in any task manager.

### Questions
1. This program opens a COM object to communicate with Internet Explorer to open up an ad every 30 seconds. It also loads a kernel module and calls the 'DeviceIoControl' method on it with a bogus argument.
2. This program doesn't show up in the task manager because the kernel component hides it. You can stop this program from running by restarting the computer.
3. The kernel component installs a driver that a user space application can access. It handles 'DeviceIoControl' calls it receives by removing the calling process from the active process list, effectively hiding its existence.
