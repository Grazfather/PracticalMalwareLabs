# Chapter 12 labs
## Lab 12-1
### Basic Static Analysis
- **strings**:
  - **exe**: Other than the strings "<unknown>" and "Lab12-01.dll" it appears only to have imports. It mentions "psapi.dll".
  - **dll**: What looks like some date/time formats, names of months and days, "Press OK to reboot", and "Practical Malware Analysis %d", plus imports.
- **PEiD**:
  - **exe**: Microsoft Visual C++ 6.0.
  - **dll**: Microsoft Visual C++ 6.0 DLL.
- **Dependency Walker**:
  - **exe**: `OpenProcess`, `CreateRemoteThread`, `WritePRocessMemory`, `GetProcAddress` and `LoadLibraryA` which suggest that this exe is a DLL injector.
  - **dll**: `MessageBoxA` from _USER32.DLL_, plus some locking, Tls (thread local storage) and some dynamic library-related functions from _KERNEL32.DLL_.
- **PEview**:
  - **exe**: Normal section names and headers.
  - **dll**: Normal section names and headers.

### Basic Dynamic Analysis
Runnning with regshot and procmon we run the binary with the dll in the same directory. We immediately see a dialog pop up whose title bar says "Practical Malware Analysis 0" and whose message is "Press OK to reboot". The procmon dump is very short, apparently not doing much more than opening "C:\WINDOWS\system32\psapi.dll" and creating a file mapping of it. Every little bit another dialog pops up with the number in the title bar incremented by one. There doesn't appear to be any relevant changes to the registry. The `MessageBoxA` import and the strings we saw in the dialog were in the dll, so we know that the exe is loading the DLL somehow, but it's not in its IAT.

### Advanced Static Analysis
Starting with the exe, we load it into IDA to see how it gets the DLL into a running process. We see that it loads _psapi.dll_ into its process and then gets and saves the address of three functions using `GetProcAddress`: `EnumProcessModules`, `GetModuleBaseNameA`, and `EnumProcesses`. After this the path the binary was launched from is concatenated with "Lab12-01.dll" while `EnumProcesses` is called, the process identifiers being written to a 4KB buffer on the stack. It then iterates over these pids, opening each (in sub_401000) to check if it is "explorer.exe". If it is it re-opens the process to get a handle, sets the counter to 2000, which serves to jump into another branch at the top of the loop and continue.

Looking into sub_401000 to see how it operates, we see it makes calls to 'EnumProcessModules` and `GetModuleBaseNameA`, whose addresses were found earlier. The first function is called with a length of 4, which is probably to restrict it to only getting the _first_ module loaded from the passed in process. This is presumably the executable itself. Next `GetModuleBaseName` is called, being passed the only module returned from the previous call. The name returned from here is compared to "explorer.exe" and if it's a match the function returns true.

At the top of the loop the when the counter check fails it jumps into a 'loading' branch. This branch allocates 260 bytes into the explorer.exe process using `VirtualAllocEx`, writes the full path to "Lab12-01.dll" into that space, gets the address of the `LoadLibraryA` function from _kernel32.dll_, and then spawns a remote thread in the explorer process, passing in `LoadLibraryA` as the _lpStartAddress_ and the address of the path to the dll we wrote in the process space as the _lpParameter_. This works to inject the malicious dll into the address space of an explorer.exe process in its own thread.

Re-running the malware we can load the explorer.exe process in the Process Explorer and clearly see that our malicious dll is indeed loaded into the process's address space.

Now looking at the dll, we see it is incredibly simple. Since we know that when `LoadLibraryA` loads a dll the `DllMain` function of that dll is called (if it exists) we start there. `DllMain` simply creates a thread whose _lpStartAddress_ is sub_10001030. sub_10001030 simply runs in a loop, creating another thread and then sleeping for 60 seconds. This second thread starts at what IDA labeled `StartAddress` but is at 0x10001000, providing a string "Practical Malware Analysis %d" (formatted with the count). This function does nothing more than call `MessageBoxA` with the provided caption and the text "Press OK to reboot".

### Questions
1. When the malware is run a dialog box appears that says, "Press OK to reboot". This messages keeps coming back periodically.
2. The malware injects the payload into explorer.exe
3. Because this malware has no method of persistence, simply killing the explorer.exe process and re-run it will effectively fix the issue.
4. The malware iterates over the processes running on the system, trying to find one named "explorer.exe". If this process is found, it uses DLL injection to get the malicious malware running in its address space. The malicious DLL simply makes an annoying dialog box pop up every minute, keeping count of how many minutes have passed.

## Lab 12-2
### Basic Static Analysis
- **strings**: "\svchost.exe", imports, plus a lot of strings containing multiple As.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Resource-related imports and `LoadLibraryA`, `CreateProcessA`, `ReadProcessMemory`, and `WritePRocessMemory` are of note from _KERNEL32.DLL_.
- **PEview**: Normal section names and headers, but includes a .rsrc section.
- **Resource Hacker** (Because of the presence of `FindResourceA` and the .rsrc section): A single resource of type "UNICODE" with name "LOCALIZATION". Re-running strings on this extracted resource show that the multiple As we saw were from this resource.

### Basic Dynamic Analysis
Using regshot and procmon, we see that the malware is opening scvhost.exe and mapping it into memory. There doesn't seem to be any relevant changes to the registry.

### Advanced Static Analysis
The application first gets its own handle using `GetModuleHandleA`, and it finds the path to _svchost.exe_ in sub_40149D. In sub_40132C the resource is extracted and its handle loaded using `FindResourceA` and `LoadResource`, respectively. The handle is used to get a pointer to its location in memory using `LockResource`. The size of the resource is found using `SizeofResource` and that much space is allocated in memory using `VirtualAlloc`. The resource is copied into that buffer and sub_401000 is then called, which is passed the pointer to the new copy of the resource, the size, and the character 'A'.

sub_401000 appears to be a decrypting function. It simply iterates over the supplied buffer, XORing each byte with the provided byte (in our case 'A'). Once this is done it simply returns. The pointer to this decrypted copy of the resource is returned from sub_40132C and passed to sub_4010EA, along with the full path to _svchost.exe_.

sub_4010EA is the first function that appears somewhat complicated. Looking at the shape of the function in graph view plus the imported function it uses, we see a call to `CreateProcessA`, and `ReadProcessMemory` followed by calls to `NtUnmapViewOfSection` and `VirtualAllocEx`, followed by `WriteProcessMemory` in a loop. This is textbook _process replacement_: This malware is starting a new svchost process and then replacing its memory contents with what was decrypted earlier.

Looking at this function in detail, to gain a better understanding of how it all works, we start with some checks that are performed on the decrypted payload. The bytes 'ZM' (string "MZ") is checked for at the very start of the payload, and 'EP' (string "PE") is checked for at an offset into the payload. This offset is defined at offset 0x3C into the buffer, which corresponds to the "Offset to the New EXE Header" according to PEview. These checks are checking that the payload has a valid PE header. The location for the start of the PE header is stored in var_8. `CreateProcessA` is then called and supplied the full path to the svchost binary, but also the _dwCreationFlags_ parameter is set to 0x4, which stands for CREATE_SUSPENDED, telling Windows to create a process but to start its main thread in a suspended state.

A buffer is allocated that is 0x2CC bytes long, whose _flAllocationType_ is MEM_COMMIT and the _flProtect_ flag PAGE_READWRITE. `GetThreadContext` is called with the thread handle taken from ebd-0x14, which is 0x4 bytes into the _hProcess_ struct which corresponds to the _hThread_ member. The context is stored in this new buffer. Offset 0xA4 from the start of the thread context is loaded (which corresponds to that thread's stored EBX register) and then eight is added to that value. This address is used as the target for `ReadProcessMemory`, where four bytes are read. According to the lab book, EBX stores the address of the PEB when a process starts, so the malware is reading eight bytes into the PEB, which corresponds to the _ImageBaseAddress_ field. With this address, and the address of `NtUnmapViewOfSection` (retrieved with `GetProcAddress`) the malware unmaps the process from its own process space. Once this is done it allocates a new block in the remote process (using `VirtualAllocEx`), requesting a size taken from 0x50 bytes into the PE header (which corresponds to 'Size of Image' according to PEView). The address requested is also pulled from the PE header, but at offset 0x34, which corresponds to 'Image Base'. This needs to be done so that the branches and jumps in the process jump to where they are expected to. The _flProtect_ flag is set to 0x40 which means PAGE_EXECUTE_READWRITE.

Before entering the copy loop, there is a lone call to `WriteProcessMemory`. The size here is taken from offset 0x54 into the PE header, which corresponds to the "Size of Headers" field. In the copy loop the counter is compared to the value at offset 0x6 of the PE header, "Number of Sections". If it hasn't copied all sections, then it finds the start of the current section by starting at offset 0xF8 into the PE header, plus 40 bytes for each header copied for far. It gets the size, the relative address, and the RVA for that section from offsets 0x10, 0x14, and 0x0C and passes them to `WriteProcessMemory` to copy the sections in the appropriate place.

Once each section is copied into memory the other branch is taken and the context struct of the process is overwritten so that the _ImageBaseAddress_ is replaced with the address specified in the "ImageBase" field in the PE header. The EAX register in the stored context is also replaced with the address of the entry point of the new PE, which will be jumped to when the thread resumes.

With the loading process done, we now want to see what the malicious payload does. We could attach a debugger to the loading process and put a breakpoint on sub_401000 to dump the buffer after the decryption is done, but because it's so simple I just wrote a little script that does it for me:

```python
import sys

outbuf = b""
with open(sys.argv[1], 'rb') as c:
    byte = c.read(1)
    while byte:
        outbuf += chr(ord(byte) ^ ord(sys.argv[3]))
        byte = c.read(1)
with open(sys.argv[2], 'wb') as out:
    out.write(outbuf)
```

### Questions
1. This program loads malware by starting an innocent-looking application and then replacing its memory with another process.
2. The launcher starts an svchost process but replaces its process (code, etc) with a payload it keeps in its resource section.
3. The malicious payload is stored in the resource section of the binary. It is type "UNICODE" and its name is "LOCALIZATION".
4. The payload is encrypted with a simple scheme that XORs each byte with another single byte 0x41.
5. The strings in the binary itself are not protected. The strings in the resource are protected the same way the rest of the payload was: Simple XOR key.

## Lab 12-3
### Basic Static Analysis
- **strings**: "practicalmalwareanalysis.log", and strings to signify modifier keys (e.g. "[CAPS LOCK]") strongly suggest this is a keylogger.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: File-writing imports, `SetWindowsHookExA`, `CallNextHookEx`, `FindWindowA`, and other imports from _USER32.DLL_ that further suggest functionality to see what is being typed and in which window.
- **PEview**: Normal section names and headers.

### Advanced Static Analysis
Popping the binary into IDA we see a simple main function: A console is allocated using `AllocConsole`, and then that console's window handle is retrieved using FindWindowA with the classname "ConsoleWindowClass". A 1KB buffer is memset to 1s at unk_405350 and a windows hook is set on the console window using `SetWindowsHookExA`, whose callback in the function fn at 0x401086 and whose idHook is _WH_KEYBOARD_LL_, which monitors low-level keybaord events. After this it enters a loop, checking messages with `GetMessageA`. If zero is returned (which is the case when a _WM_QUIT_ message is received) then the hook is removed and the process finishes.

The fn function is a simple hook wrapper that calls sub_4010C7 before calling `CallNextHookEx`. sub_4010C7 is where all the logging is done. It starts by opening "practicalmalwareanalysis.log" and setting the file pointer where it needs to continue to write. The current window is fetched and its title retrieved using `GetForegroundWindow` and `GetWindowTextA`. The name of the window is written to the file as well as the key that is pressed. A jump table is used to properly handle keys on the numpad and modifier keys. Once written, the file is closed (until the hook is called again on the next keypress).

### Questions
1. This malware is a keylogger that logs keystrokes as well as the name of the window that was active when the key was pressed.
2. The malware uses `SetWindowsHookExA` with the idHook type of _WH_KEYBOARD_LL_ to get called every time a key is pressed.
3. The logfile is written to "practicalmalwareanalysis.log".

## Lab 12-4
### Basic Static Analysis
- **strings**: "psapi.dll", "\system32\wupdmgrd.exe", "\winup.exe", "http://www.practicalmalwareanalysis.com/updater.exe". There are some import names that don't appear in the binary according to Dependency Walker.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: File-writing imports, `LoadResource`, `WinExec`, `CreateRemoteThread`, and other imports from _KERNEL32.DLL_, `AdjustTokenPrivileges`, `LookupPrivilegeValueA`, and `OpenProcessToken` from _ADVAPI32.DLL_, and some low level c imports such as `exit` from _MSVCRT.DLL_.
- **PEview**: Normal section names and headers, but includes a .rsrc section.
- **Resource Hacker**: A single binary resource named "BIN".

Extracting this binary and doing more basic static analysis:
- **strings**: "\system32\wupdmgrd.exe", "\winup.exe", "http://www.practicalmalwareanalysis.com/updater.exe" (Implying this binary is not encrypted).
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: `GetTempPathA`, `GetWindowsDirectoryA`, `WinExec` from _KERNEL32.DLL_, `URLDownloadToFileA` from _URLMON.DLL_, and more low level c imports from _MSVCRT.DLL_.
- **PEview**: Normal section names and headers.

### Advanced Static Analysis

Viewing the first binary in IDA it seems rather simple. It uses `GetProcAddress` to `LoadLibraryA` to get the addresses of `EnumProcessModules`, `GetModuleBaseNameA`, and `EnumProcesses` from _psapi.dll_, which we saw with strings but not in dependency walker in either binary. `EnumProcesses` is called and it's iterated over, calling sub_401000 for each, passing in the process id.

sub_401000 opens the process and calls `EnumProcessModules` to enumerate the modules for that particular process id, only grabbing the first (which should be the executable itself) and then compares it to "winlogon.exe". If the process is indeed "winlogon.exe" it returns true.

If winlogon is found, its pid is passed to sub_401174. sub_401174 calls sub_4010FC with the string "SeDebugPrivilege" as its only argument. sub_4010FC tries to give the current process the passed in privilege using `OpenProcessToken`, `LookupPrivilegeValueA`, and `AdjustTokenPrivileges`. Back in sub_4010FC, on successful acquisition of _SeDebugPrivilege_, _sfc_os.dll_ is loaded and the address of the function with ordinal 2's address is retrieved with `GetProcessAddress`. This is apparently an undocumented function in _sfc_os.dll_, but some googling has determined that it's a function named `SfcTerminateWatcherThread`. `OpenProcess` is called on the PID passed in (that of winlogon.exe) with _PROCESS_ALL_ACCESS_ as the desired access level. On success a remote thread is created in winlogon.exe with the _lpStartAddress_ set to the address of the function address retrieved from _sfc_os.dll_. _sfc_os.dll_ must already be loaded in the winlogon.exe. According to the book, this ordinal 2 function can allow succeed when called from winlogon.exe, and when called disables "Windows File Protection", which must be needed for the next steps.

Back in main, if the remote thread creation is successful, strings are built as the source and the target of `MoveFileA`. The _ExistingFileName_ is built from the windows directory (likely "C:\Windows"), retrieved from `GetWindowsDirectoryA` and "\system32\wupdmgr.exe". The _NewFileName_ is built from the temp path, retrieved from `GetTempPathA`, and "\winup.exe". `MoveFileA` is followed immediately by sub_4011FC.

sub_4011FC is simple and not worth going into too much detail. The resource named "BIN" at offset "#101" is extracted and written over wupdmgr.exe that was just previously backed up. The function finishes by called `WinExec` on the newly replaced wupdmgr.exe.

Let us now examine the binary extracted from the resource section.

The main function of this binary is very straightforward. It begins by calling `WinExec` on the backup that the loader created of the _real_ Windows update binary. This is presumable so that the behavior of this malicious windows update binary is slightly hidden -- It still works as Windows update. It then calls `URLDownloadToFileA` with the path "http://www.practicalmalwareanalysis.com/updater.exe" as the source and the target being its binary itself. The binary is simply updating itself, and then calling `WinExec` on its newer replacement.

### Questions
1. It determines if the passed in process ID corresponds to winlogon.exe.
2. winlogon.exe.
3. _psapi.dll_ and _sfc_os.dll_.
4. the _lpStartAddress_ argument is the address of the second ordinal exported from _sfc_os.dll_.
5. The malware replaces the Windows update binary with a binary that loads the legit Windows update binary as well as downloads an update for itself.
6. The purpose of this malware is to replace the Windows update binary with one that keeps the normal Windows update behavior but that also replaces itself. This would allow the attacker to implant computers but develop a more malicious payload later on. The 'dropper' binary starts a thread in winlogon.exe running `SfcTerminateWatcherThread` from _sfc_os.dll_ to disable windows file protection, allowing the dropped to replace what should be a protected binary.

