# Chapter 12 labs
## Lab 12-1
### Basic Static Analysis
- **strings**:
  - **exe**: Other than the strings "<unknown>" and "Lab12-01.dll" it appears only to have imports. It mentions "psapi.dll".
  - **dll**: What looks like some date/time formats, names of months and days, "Press OK to reboot", and "Practical Malware Analysis %d", plus imports.
- **PEiD**:
  - **exe**: Microsoft Visual C++ 6.0.
  - **dll**: Microsoft Visual C++ 6.0 DLL.
- **Dependency Walker**:
  - **exe**: 'OpenProcess', 'CreateRemoteThread', 'WritePRocessMemory', 'GetProcAddress' and 'LoadLibraryA' which suggest that this exe is a DLL injector.
  - **dll**: 'MessageBoxA' from USER32.DLL, plus some locking, Tls (thread local storage) and some dynamic library-related functions from KERNEL32.DLL.
- **PEview**:
  - **exe**: Normal section names and headers.
  - **dll**: Normal section names and headers.

### Basic Dynamic Analysis
Runnning with regshot and procmon we run the binary with the dll in the same directory. We immediately see a dialog pop up whose title bar says "Practical Malware Analysis 0" and whose message is "Press OK to reboot". The procmon dump is very short, apparently not doing much more than opening "C:\WINDOWS\system32\psapi.dll" and creating a file mapping of it. Every little bit another dialog pops up with the number in the title bar incremented by one. There doesn't appear to be any relevant changes to the registry. The 'MessageBoxA' import and the strings we saw in the dialog were in the dll, so we know that the exe is loading the DLL somehow, but it's not in its IAT.

### Advanced Static Analysis
Starting with the exe, we load it into IDA to see how it gets the DLL into a running process. We see that it loads psapi.dll into its process and then gets and saves the address of three functions using 'GetProcAddress': 'EnumProcessModules', 'GetModuleBaseNameA', and 'EnumProcesses'. After this the path the binary was launched from is concatenated with "Lab12-01.dll" while 'EnumProcesses' is called, the process identifiers being written to a 4KB buffer on the stack. It then iterates over these pids, opening each (in sub_401000) to check if it is "explorer.exe". If it is it re-opens the process to get a handle, sets the counter to 2000, which serves to jump into another branch at the top of the loop and continue.

Looking into sub_401000 to see how it operates, we see it makes calls to 'EnumProcessModules' and 'GetModuleBaseNameA', whose addresses were found earlier. The first function is called with a length of 4, which is probably to restrict it to only getting the _first_ module loaded from the passed in process. This is presumably the executable itself. Next 'GetModuleBaseName' is called, being passed the only module returned from the previous call. The name returned from here is compared to "explorer.exe" and if it's a match the function returns true.

At the top of the loop the when the counter check fails it jumps into a 'loading' branch. This branch allocates 260 bytes into the explorer.exe process using 'VirtualAllocEx', writes the full path to "Lab12-01.dll" into that space, gets the address of the 'LoadLibraryA' function from kernel32.dll, and then spawns a remote thread in the explorer process, passing in 'LoadLibraryA' as the _lpStartAddress_ and the address of the path to the dll we wrote in the process space as the _lpParameter_. This works to inject the malicious dll into the address space of an explorer.exe process in its own thread.

Re-running the malware we can load the explorer.exe process in the Process Explorer and clearly see that our malicious dll is indeed loaded into the process's address space.

Now looking at the dll, we see it is incredibly simple. Since we know that when 'LoadLibraryA' loads a dll the 'DllMain' function of that dll is called (if it exists) we start there. 'DllMain' simply creates a thread whose _lpStartAddress_ is sub_10001030. sub_10001030 simply runs in a loop, creating another thread and then sleeping for 60 seconds. This second thread starts at what IDA labeled 'StartAddress' but is at 0x10001000, providing a string "Practical Malware Analysis %d" (formatted with the count). This function does nothing more than call 'MessageBoxA' with the provided caption and the text "Press OK to reboot".

### Questions
1. When the malware is run a dialog box appears that says, "Press OK to reboot". This messages keeps coming back periodically.
2. The malware injects the payload into explorer.exe
3. Because this malware has no method of persistence, simply killing the explorer.exe process and re-run it will effectively fix the issue.
4. The malware iterates over the processes running on the system, trying to find one named 'explorer.exe'. If this process is found, it uses DLL injection to get the malicious malware running in its address space. The malicious DLL simply makes an annoying dialog box pop up every minute, keeping count of how many minutes have passed.

## Lab 12-2
### Basic Static Analysis
- **strings**: "\svchost.exe", imports, plus a lot of strings containing multiple As.
- **PEiD**: Microsoft Visual C++ 6.0.
- **Dependency Walker**: Resource-related imports and 'LoadLibraryA', 'CreateProcessA', 'ReadProcessMemory', and 'WritePRocessMemory' are of note from KERNEL32.DLL.
- **PEview**: Normal section names and headers, but includes a .rsrc section.
- **Resource Hacker** (Because of the presence of 'FindResourceA' and the .rsrc section): A single resource of type "UNICODE" with name "LOCALIZATION". Re-running strings on this extracted resource show that the multiple As we saw were from this resource.

### Basic Dynamic Analysis
Using regshot and procmon, we see that the malware is opening scvhost.exe and mapping it into memory. There doesn't seem to be any relevant changes to the registry.

### Advanced Static Analysis
The application first gets its own handle using 'GetModuleHandleA', and it finds the path to _svchost.exe_ in sub_40149D. In sub_40132C the resource is extracted and its handle loaded using 'FindResourceA' and 'LoadResource', respectively. The handle is used to get a pointer to its location in memory using 'LockResource'. The size of the resource is found using 'SizeofResource' and that much space is allocated in memory using 'VirtualAlloc'. The resource is copied into that buffer and sub_401000 is then called, which is passed the pointer to the new copy of the resource, the size, and the character 'A'.

sub_401000 appears to be a decrypting function. It simply iterates over the supplied buffer, XORing each byte with the provided byte (in our case 'A'). Once this is done it simply returns. The pointer to this decrypted copy of the resource is returned from sub_40132C and passed to sub_4010EA, along with the full path to _svchost.exe_.

sub_4010EA is the first function that appears somewhat complicated. Looking at the shape of the function in graph view plus the imported function it uses, we see a call to 'CreateProcessA', and 'ReadProcessMemory' followed by calls to 'NtUnmapViewOfSection' and 'VirtualAllocEx', followed by 'WriteProcessMemory' in a loop. This is textbook _process replacement_: This malware is starting a new svchost process and then replacing its memory contents with what was decrypted earlier.

### Questions
1. This program loads malware by starting an innocent-looking application and then replacing its memory with another process.
2. The launcher starts an svchost process but replaces its process (code, etc) with a payload it keeps in its resource section.
3. The malicious payload is stored in the resource section of the binary. It is type "UNICODE" and its name is "LOCALIZATION".
4. The payload is encrypted with a simple scheme that XORs each byte with another single byte 0x41.
5. The strings in the binary itself are not protected. The strings in the resource are protected the same way the rest of the payload was: Simple XOR key.
