# Chapter 12 labs
## Lab 12-1
### Basic Static Analysis
- **strings**:
  - **exe**: Other than the strings "<unknown>" and "Lab12-01.dll" it appears only to have imports. It mentions "psapi.dll".
  - **dll**: What looks like some date/time formats, names of months and days, "Press OK to reboot", and "Practical Malware Analysis %d", plus imports.
- **PEiD**:
  - **exe**: Microsoft Visual C++ 6.0.
  - **dll**: Microsoft Visual C++ 6.0 DLL.
- **Dependency Walker**:
  - **exe**: 'OpenProcess', 'CreateRemoteThread', 'WritePRocessMemory', 'GetProcAddress' and 'LoadLibraryA' which suggest that this exe is a DLL injector.
  - **dll**: 'MessageBoxA' from USER32.DLL, plus some locking, Tls (thread local storage) and some dynamic library-related functions from KERNEL32.DLL.
- **PEview**:
  - **exe**: Normal section names and headers.
  - **dll**: Normal section names and headers.

### Basic Dynamic Analysis
Runnning with regshot and procmon we run the binary with the dll in the same directory. We immediately see a dialog pop up whose title bar says "Practical Malware Analysis 0" and whose message is "Press OK to reboot". The procmon dump is very short, apparently not doing much more than opening "C:\WINDOWS\system32\psapi.dll" and creating a file mapping of it. Every little bit another dialog pops up with the number in the title bar incremented by one. There doesn't appear to be any relevant changes to the registry. The 'MessageBoxA' import and the strings we saw in the dialog were in the dll, so we know that the exe is loading the DLL somehow, but it's not in its IAT.

### Advanced Static Analysis
Starting with the exe, we load it into IDA to see how it gets the DLL into a running process. We see that it loads psapi.dll into its process and then gets and saves the address of three functions using 'GetProcAddress': 'EnumProcessModules', 'GetModuleBaseNameA', and 'EnumProcesses'. After this the path the binary was launched from is concatenated with "Lab12-01.dll" while 'EnumProcesses' is called, the process identifiers being written to a 4KB buffer on the stack. It then iterates over these pids, opening each (in sub_401000) to check if it is "explorer.exe". If it is it re-opens the process to get a handle, sets the counter to 2000, which serves to jump into another branch at the top of the loop and continue.

Looking into sub_401000 to see how it operates, we see it makes calls to 'EnumProcessModules' and 'GetModuleBaseNameA', whose addresses were found earlier. The first function is called with a length of 4, which is probably to restrict it to only getting the _first_ module loaded from the passed in process. This is presumably the executable itself. Next 'GetModuleBaseName' is called, being passed the only module returned from the previous call. The name returned from here is compared to "explorer.exe" and if it's a match the function returns true.

At the top of the loop the when the counter check fails it jumps into a 'loading' branch. This branch allocates 260 bytes into the explorer.exe process using 'VirtualAllocEx', writes the full path to "Lab12-01.dll" into that space, gets the address of the 'LoadLibraryA' function from kernel32.dll, and then spawns a remote thread in the explorer process, passing in 'LoadLibraryA' as the _lpStartAddress_ and the address of the path to the dll we wrote in the process space as the _lpParameter_. This works to inject the malicious dll into the address space of an explorer.exe process in its own thread.

Re-running the malware we can load the explorer.exe process in the Process Explorer and clearly see that our malicious dll is indeed loaded into the process's address space.

Now looking at the dll, we see it is incredibly simple. Since we know that when 'LoadLibraryA' loads a dll the 'DllMain' function of that dll is called (if it exists) we start there. 'DllMain' simply creates a thread whose _lpStartAddress_ is sub_10001030. sub_10001030 simply runs in a loop, creating another thread and then sleeping for 60 seconds. This second thread starts at what IDA labeled 'StartAddress' but is at 0x10001000, providing a string "Practical Malware Analysis %d" (formatted with the count). This function does nothing more than call 'MessageBoxA' with the provided caption and the text "Press OK to reboot".

### Questions
1. When the malware is run a dialog box appears that says, "Press OK to reboot". This messages keeps coming back periodically.
2. The malware injects the payload into explorer.exe
3. Because this malware has no method of persistence, simply killing the explorer.exe process and re-run it will effectively fix the issue.
4. The malware iterates over the processes running on the system, trying to find one named 'explorer.exe'. If this process is found, it uses DLL injection to get the malicious malware running in its address space. The malicious DLL simply makes an annoying dialog box pop up every minute, keeping count of how many minutes have passed.

